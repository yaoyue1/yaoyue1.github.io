<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="项目总结," />





  <link rel="alternate" href="/atom.xml" title="jiemo blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="数据类型5种基本类型：undefined,null,number,string,boolean 理解原型和原型链Js对象在创建时就包含一个隐式的内部属性proto，这个属性是不可以被直接访问的（proto是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性proto)，这个内部属性指向的就是该对象的原型a.proto = foo.">
<meta name="keywords" content="项目总结">
<meta property="og:type" content="article">
<meta property="og:title" content="收集一些题">
<meta property="og:url" content="http://yaoyue.com/2018/10/30/收集一些题/index.html">
<meta property="og:site_name" content="jiemo blog">
<meta property="og:description" content="数据类型5种基本类型：undefined,null,number,string,boolean 理解原型和原型链Js对象在创建时就包含一个隐式的内部属性proto，这个属性是不可以被直接访问的（proto是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性proto)，这个内部属性指向的就是该对象的原型a.proto = foo.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-10-30T09:50:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="收集一些题">
<meta name="twitter:description" content="数据类型5种基本类型：undefined,null,number,string,boolean 理解原型和原型链Js对象在创建时就包含一个隐式的内部属性proto，这个属性是不可以被直接访问的（proto是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性proto)，这个内部属性指向的就是该对象的原型a.proto = foo.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yaoyue.com/2018/10/30/收集一些题/"/>





  <title> 收集一些题 | jiemo blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  
  <!-- <canvas id="mycanvas" style="position:fixed;top:0;left:0;z-index: -1;"></canvas> -->
  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jiemo blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">前端开发/学生/菜鸟</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yaoyue.com/2018/10/30/收集一些题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="芥末">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jiemo blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jiemo blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                收集一些题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-30T17:49:09+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>5种基本类型：undefined,null,number,string,boolean</p>
<h3 id="理解原型和原型链"><a href="#理解原型和原型链" class="headerlink" title="理解原型和原型链"></a>理解原型和原型链</h3><p>Js对象在创建时就包含一个隐式的内部属性<em>proto</em>，这个属性是不可以被直接访问的（<em>proto</em>是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性<em>proto</em>)，这个内部属性指向的就是该对象的原型<br>a.<em>proto</em> = foo.prototype<br><a id="more"></a><br>Construct:<br>原型对象还包含一个construct属性，这个属性指向的是创建所有实例的指向该原型对象的构造函数，即指向的就是那个构造函数<br>Prototype<br>每个函数对象都有一个prototype属性，当这个函数被用来当作构造函数来创建实例的时候，prototype的属性值就会被用来赋值给实例的的<em>proto</em>属性<br>实际上在JavaScript中，所有对象的原型都将追溯到”Object {}”对象<br>所以：实例.<em>proto</em> = fun.prototype<br>fun.prototype.<em>proto</em> = object<br>fun.prototype.construct = fun 函数本身</p>
<p>函数对象和fun.prototype对象相互引用 ： fun.prototype.construct = fun,  fun.prototype 为该对象</p>
<p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用继承的属性和方法</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>我理解的作用域就是你的代码在运行时，各个变量、函数和对象的可访问性或者说是一个作用范围。因为函数本身也是一个作用域，所以作用域分为全局作用域和局部作用域<br>在全局中声明的变量方法可以在任何地方调用，在函数内部申明的局部变量，只能在函数内部访问。<br>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问</p>
<p>函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量<br>闭包：闭包就是能够读取其他函数内部变量的函数，定义在一个函数内部的函数<br>闭包有两个作用：<br>第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）<br>第二个就是让这些外部变量始终保存在内存中 </p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol>
<li>减少延迟加快网页打开速度</li>
<li>重复利用资源减少网络带宽消耗</li>
<li>降低请求次数或者减少传输内容从而减轻服务器压力。<br>浏览器HTTP缓存可以分为强缓存和协商缓存：<br>#### </li>
<li>强缓存：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache）</li>
<li>协商缓存： 协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。</li>
<li>http1.0中的缓存控制：<br>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）<br>Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41<br>If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li>
<li>http1.1中的缓存控制：<br>Cache-Control：缓存控制头部，有no-cache、max-age等多种取值<br>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算<br>If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li>
</ol>
<h3 id="大公司前端资源部署的方案"><a href="#大公司前端资源部署的方案" class="headerlink" title="大公司前端资源部署的方案"></a>大公司前端资源部署的方案</h3><p><a href="https://www.zhihu.com/question/20790576" target="_blank" rel="external">https://www.zhihu.com/question/20790576</a></p>
<h3 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h3><h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><ol>
<li>客户端发送一个syn标志的报文，seq发送序号为x</li>
<li>服务端发送带ack标志和syn标志的报文，seq发送序号为y，表示对客户端syn报文的回应同时询问客户端是否准备好进行数据通讯</li>
<li>客户端必须再发送ack报文，seq发送序号为z，回应服务端<br>qa：为什么是三次不是两次？<br>主要是为了防止已失效的连接请求报文段突然又传送到服务端导致的出错。因为如果客户端发出的第一个连接请求报文段没有丢失而且是在某些网络结点长时间滞留了，以致延误到连接释放后的某个时间才到达服务端，如果是只有2次的话，服务端这个时候一旦确认，连接就已经建立了，但这个时候客户端并没有发出连接请求也就不会理睬服务端，这样服务端的许多资源就会白白浪费。<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4></li>
<li>客户端向tcp发出连接释放报文段fin=1，序号seq=u，并停止再发送数据，主动关闭tcp连接，进入fin-wait-1（终止等待1）状态，等待服务端的确认</li>
<li>服务端收到连接释放报文段后发出确认报文段，ACK=1，确认号ack=u+1，序号seq=u+1，服务端进入关闭等待状态，此时的tcp处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后，进入fin-wait-2（终止等待2）状态，等待服务端发出连接释放报文段</li>
<li>服务端没有要想客户端发送的数据，服务端发出连接释放报文段，fin=1，ACk=1，序号seq=w，确认号ack=u+1，服务端进入最后确认状态，等待客户端的确认</li>
<li>客户端收到服务端的连接释放报文段后，发出确认报文段，ACK=1,seq=u+1,ack=w+1,客户端进入时间等待状态，此时tcp未释放掉，需要经过时间等待计时器设置的2MSL后，客户端才进入到关闭状态</li>
</ol>
<p>qa：为什么time-wait状态必须等待2MSL（最长报文段寿命）？</p>
<ol>
<li>保证客户端发送的最后一个ack报文段能够到达服务端，因为这个报文段可能丢失，是的处于最后确认状态的服务端收不到确认信息，服务端超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态</li>
<li>防止已失效的连接请求报文段出现在本连接中，A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。<br>qa：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>因为服务端收到客户端发送来的fin报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，等服务端确定不会再发送数据后，在发送fin报文，来释放连接</li>
</ol>
<h3 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a>dns域名解析过程</h3><ol>
<li>浏览器搜索自身dns缓存，看看缓存有没有过期，过期缓存的解析就结束，chrome缓存的时间只有一分钟</li>
<li>搜索操作系统自身的dns缓存，没有找到或失效解析结束</li>
<li>读取本地的hosts文件，hosts文件可以建立域名到ip的绑定</li>
<li>浏览器发起一个dns系统调用，调用解析器后，解析器会向运营商服务器发送查询信息，运营商服务会先查找自身缓存，若没有，则主控服务器会代替浏览器发起一个迭代的DNS解析的请求，先查找根域的，运营商服务器拿到域名的IP，返回给操作系统的内核，同时缓存在了自己的缓存区，操作系统内核从DNS服务商拿来的IP地址返回给浏览器。<br><a href="https://juejin.im/entry/599109d46fb9a03c4c270f82" target="_blank" rel="external">https://juejin.im/entry/599109d46fb9a03c4c270f82</a></li>
</ol>
<h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><ol>
<li>应用层(dns,http) DNS解析成IP并发送http请求</li>
<li>传输层(tcp,udp) 建立tcp连接（三次握手）</li>
<li>网络层(IP,ARP) IP寻址</li>
<li>数据链路层(PPP) 封装成帧</li>
<li>物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</li>
</ol>
<h3 id="浏览器解析资源过程"><a href="#浏览器解析资源过程" class="headerlink" title="浏览器解析资源过程"></a>浏览器解析资源过程</h3><p>浏览器内核拿到内容后，渲染的步骤大致可分为以下几个步骤：</p>
<ol>
<li>解析html，构建dom tree<ul>
<li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li>
<li>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li>
<li>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li>
<li>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</li>
</ul>
</li>
<li>解析css，生成css规则树<br> Bytes → characters → tokens → nodes → CSSOM，和解析html类似，也是最终生成css的规则树结构</li>
<li>合并dom树和css规则树，生成render树（dom树和css规则树并不是严格意义上的一对一关系，head这种不可见的标签或者display：none等就会不显示）</li>
<li>布局render树（layout／reflow），负责各元素尺寸，位置的计算<br>计算css样式，构建渲染树，布局（主要定位坐标和大小，是否换行，各种position，overflow，z-index属性）</li>
<li><p>绘制render树（paint），绘制页面像素信息</p>
</li>
<li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p>
</li>
</ol>
<h3 id="回流和重绘，哪些操作会引起回流，哪些会引起重绘"><a href="#回流和重绘，哪些操作会引起回流，哪些会引起重绘" class="headerlink" title="回流和重绘，哪些操作会引起回流，哪些会引起重绘"></a>回流和重绘，哪些操作会引起回流，哪些会引起重绘</h3><p>回流一定会引起重绘，重绘不一定会引起回流</p>
<ol>
<li>回流：元素的内容，结构，位置或者尺寸发生了变化，需要重新计算样式和渲染树</li>
<li>重绘： 元素的改变只影响元素的外观之类eg：背景色，边框颜色，文字颜色等</li>
</ol>
<p>引起回流：</p>
<ol>
<li>页面首次渲染</li>
<li>dom tree结构改变，添加或者删除可见的DOM元素</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<br> （1）offset(Top/Left/Width/Height)<br>  (2) scroll(Top/Left/Width/Height)<br>  (3) cilent(Top/Left/Width/Height)<br>  (4) width,height<br>  (5) 调用了getComputedStyle()或者IE的currentStyle</li>
</ol>
<h3 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h3><p>浏览器渲染的图层一般分为普通图层和复合图层<br>普通文档流可以看作为一个默认复合层，absolute，fixed等虽然脱离了普通文档流但是仍然属于默认复合层</p>
<p>可以通过硬件加速的方式，声明一个新的复合层，它会单独分配资源，这样久不影响默认复合层里的回流重绘，这是由于浏览器的GPU中，各个复合图层是单独绘制的，互不影响</p>
<h4 id="如何变成复合层？"><a href="#如何变成复合层？" class="headerlink" title="如何变成复合层？"></a>如何变成复合层？</h4><ol>
<li>最常见的方式：translate3d，translateZ</li>
<li>opacity属性／过渡动画（执行的过程才会创建复合层）</li>
<li>video，iframe，canvas，webgl等元素</li>
<li>flash插件等</li>
</ol>
<p>复合图层的作用：可以使得元素独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，但是复合图层过多也会导致资源消耗过度，反而更卡<br>注意：硬件加速请使用index，因为如果加速的元素层级较低的话，后面的层级较高的元素会被隐式的转换为同一个复合图层，如此会影响性能</p>
<h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><ol>
<li><p>正向代理：是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。（翻墙）</p>
</li>
<li><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。（负载均衡）</p>
</li>
</ol>
<h3 id="get和post请求区别"><a href="#get和post请求区别" class="headerlink" title="get和post请求区别"></a>get和post请求区别</h3><ol>
<li>GET使用URL或Cookie传参，而POST将数据放在BODY中。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。</li>
<li>get会产生一个tcp数据包，post产生2个，get请求时，浏览器会把headers和data一起发送出去，服务器响应200返回数据，post请求时，浏览器会先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200返回数据</li>
<li>GET请求是幂等性的，POST请求不是。（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。）正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</li>
</ol>
<h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<p>SSL/TLS握手流程</p>
<ol>
<li>浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </li>
<li>服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器<br>（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li>
<li>浏览器收到服务端的证书后<ul>
<li>验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</li>
<li>用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<code>Premaster secret</code>，发送给服务器。</li>
<li>利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-<code>session key</code></li>
<li>使用约定好的HASH算法计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。 </li>
</ul>
</li>
<li>服务端收到浏览器的回复<ul>
<li>利用已知的加解密方式与自己的私钥进行解密，获取<code>Premaster secret</code></li>
<li>和浏览器相同规则生成<code>session key</code></li>
<li>使用<code>session key</code>解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</li>
<li>使用<code>session key</code>加密一段握手消息，发送给浏览器 </li>
</ul>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</li>
</ol>
<h3 id="数组的slice和splice方法"><a href="#数组的slice和splice方法" class="headerlink" title="数组的slice和splice方法"></a>数组的slice和splice方法</h3><p>slice: 返回数组中的一项或者几项，slice(1) 从位置1到数组最后，slice(1,4)从数组位置1到位置3，位置是从0开始<br>splice: 删除，插入，替换数组中的元素。splice(0,2,’jiemo’,’jiemo1 ‘) 从位置0开始 删除2项，然后插入’jiemo’,’jiemo1’</p>
<h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明：解析器会率先读取函数声明，使其在执行任何代码之前都可访问<br>函数表达式：必须等解析器执行到它所在的代码行，才会真正被解释执行</p>
<h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ol>
<li>工厂模式<br>缺点：没有解决对象的识别问题</li>
<li>构造函数模式</li>
</ol>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>字节按照一定规则在空间上排列就是字节对齐</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>大致分三步：<br>1、找基准（一般是以中间项为基准）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归<br>function quickSort(arr){<br>    //如果数组&lt;=1,则直接返回<br>    if(arr.length&lt;=1){return arr;}<br>    var pivotIndex=Math.floor(arr.length/2);<br>    //找基准，并把基准从原数组删除<br>    var pivot=arr.splice(pivotIndex,1)[0];<br>    //定义左右数组<br>    var left=[];<br>    var right=[];</p>
<pre><code>//比基准小的放在left，比基准大的放在right
for(var i=0;i&lt;arr.length;i++){
    if(arr[i]&lt;=pivot){
        left.push(arr[i]);
    }
    else{
        right.push(arr[i]);
    }
}
//递归
return quickSort(left).concat([pivot],quickSort(right));
</code></pre><p>}</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/项目总结/" rel="tag"># 项目总结</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/16/rem适配/" rel="next" title="rem适配">
                <i class="fa fa-chevron-left"></i> rem适配
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="芥末" />
          <p class="site-author-name" itemprop="name">芥末</p>
          <p class="site-description motion-element" itemprop="description">前端开发/程序媛/菜鸟/搬砖</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yaoyue1" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://yaoyue1.github.io/practice/" target="_blank" title="Practice">
                  
                    <i class="fa fa-fw fa-pencil"></i>
                  
                  Practice
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解原型和原型链"><span class="nav-number">2.</span> <span class="nav-text">理解原型和原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域和作用域链"><span class="nav-number">3.</span> <span class="nav-text">作用域和作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器缓存"><span class="nav-number">4.</span> <span class="nav-text">浏览器缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#好处"><span class="nav-number">4.1.</span> <span class="nav-text">好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大公司前端资源部署的方案"><span class="nav-number">5.</span> <span class="nav-text">大公司前端资源部署的方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp三次握手四次挥手"><span class="nav-number">6.</span> <span class="nav-text">tcp三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手："><span class="nav-number">6.1.</span> <span class="nav-text">三次握手：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手"><span class="nav-number">6.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns域名解析过程"><span class="nav-number">7.</span> <span class="nav-text">dns域名解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五层因特网协议栈"><span class="nav-number">8.</span> <span class="nav-text">五层因特网协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器解析资源过程"><span class="nav-number">9.</span> <span class="nav-text">浏览器解析资源过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回流和重绘，哪些操作会引起回流，哪些会引起重绘"><span class="nav-number">10.</span> <span class="nav-text">回流和重绘，哪些操作会引起回流，哪些会引起重绘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通图层和复合图层"><span class="nav-number">11.</span> <span class="nav-text">普通图层和复合图层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何变成复合层？"><span class="nav-number">11.1.</span> <span class="nav-text">如何变成复合层？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正向代理和反向代理"><span class="nav-number">12.</span> <span class="nav-text">正向代理和反向代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get和post请求区别"><span class="nav-number">13.</span> <span class="nav-text">get和post请求区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http和https区别"><span class="nav-number">14.</span> <span class="nav-text">http和https区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的slice和splice方法"><span class="nav-number">15.</span> <span class="nav-text">数组的slice和splice方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明和函数表达式"><span class="nav-number">16.</span> <span class="nav-text">函数声明和函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象的方式"><span class="nav-number">17.</span> <span class="nav-text">创建对象的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节对齐"><span class="nav-number">18.</span> <span class="nav-text">字节对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">19.</span> <span class="nav-text">快速排序</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">芥末</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  



<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
