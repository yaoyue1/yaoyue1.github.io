<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="项目总结," />





  <link rel="alternate" href="/atom.xml" title="jiemo blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="js基础部分vue相关部分vue生命周期 beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data">
<meta name="keywords" content="项目总结">
<meta property="og:type" content="article">
<meta property="og:title" content="收集一些题">
<meta property="og:url" content="http://yaoyue.com/2018/10/30/收集一些题/index.html">
<meta property="og:site_name" content="jiemo blog">
<meta property="og:description" content="js基础部分vue相关部分vue生命周期 beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-08T03:08:49.498Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="收集一些题">
<meta name="twitter:description" content="js基础部分vue相关部分vue生命周期 beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yaoyue.com/2018/10/30/收集一些题/"/>





  <title> 收集一些题 | jiemo blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  
  <!-- <canvas id="mycanvas" style="position:fixed;top:0;left:0;z-index: -1;"></canvas> -->
  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jiemo blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">前端开发/学生/菜鸟</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yaoyue.com/2018/10/30/收集一些题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="芥末">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jiemo blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jiemo blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                收集一些题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-30T17:49:09+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h2 id="js基础部分"><a href="#js基础部分" class="headerlink" title="js基础部分"></a>js基础部分</h2><h2 id="vue相关部分"><a href="#vue相关部分" class="headerlink" title="vue相关部分"></a>vue相关部分</h2><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><ol>
<li>beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</li>
<li>created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。<br>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。<br>使用场景:ajax请求和页面初始化</li>
<li>beforeMount 和 created 拿到的数据相同 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>mounted中el被创建dom已经更新，vue实例对象中有template参数选项，则将其作为模板编译成render函数，编译优先级render函数选项 &gt; template选项<br>使用场景:常用于获取VNode信息和操作，ajax请求<br>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</li>
<li>由于beforeUpdate和updated使用的比较少，一般用计算属性和watch代替所以在此不在说明</li>
<li>destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ol>
<h3 id="vue响应式原理-数据绑定原理？（get，set；proxy）"><a href="#vue响应式原理-数据绑定原理？（get，set；proxy）" class="headerlink" title="vue响应式原理||数据绑定原理？（get，set；proxy）"></a>vue响应式原理||数据绑定原理？（get，set；proxy）</h3><h3 id="nextTick的理解"><a href="#nextTick的理解" class="headerlink" title="nextTick的理解"></a>nextTick的理解</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>官方：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br>Vue 实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新，即Vue是异步执行DOM更新的<br>异步执行的步骤是：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。<br>所以Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>同步代码执行 -&gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]…<br>nextTick的作用就是修改数据后需要在视图更新之后，基于新的视图进行操作这是时候就要用到nextTick，它相当于一个回调函数<h4 id="nextTick的主要应该场景"><a href="#nextTick的主要应该场景" class="headerlink" title="nextTick的主要应该场景"></a>nextTick的主要应该场景</h4></li>
<li>created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法，mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</li>
<li>点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。获取焦点就需用到nextTick</li>
<li>点击获取元素宽度。原本隐藏的元素显示然后立即获取其宽度属性</li>
<li>使用 swiper 插件通过 ajax 请求图片后的滑动问题。</li>
</ol>
<h3 id="vue更新数组"><a href="#vue更新数组" class="headerlink" title="vue更新数组"></a>vue更新数组</h3><ol>
<li>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<ul>
<li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时，例如：vm.items.length = newLength</li>
</ul>
</li>
<li>不更新的原因：<br>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。<br>这是vue实现响应式的原理，也就是说改变data是会触发setter，但是setter和getter是有局限性的，当属性的值为一个数组时，通过索引修改数组某一项的值或使用数组的某些方法修改数组并不能触发set；当属性的值为一对象时，直接修改对象中属性的值时也无法触发set。</li>
<li>解决<br>解决第一类问题，你可以使用vm.items[indexOfItem] = newValue<br>解决第二类问题，你可以使用 splice：<br>手动触发</li>
</ol>
<h3 id="Vue-data为什么必须是函数"><a href="#Vue-data为什么必须是函数" class="headerlink" title="Vue data为什么必须是函数"></a>Vue data为什么必须是函数</h3><p>因为vue的组件是可以复用的，如果data是一个对象的话，那么复用的组件一个更改其中数据，另外的组件数据也会被更改，因此每个实例必须维护一份被返回对象的独立的拷贝才行</p>
<h3 id="父子组件created，mounted执行顺序？"><a href="#父子组件created，mounted执行顺序？" class="headerlink" title="父子组件created，mounted执行顺序？"></a>父子组件created，mounted执行顺序？</h3><p>父组件beforeCreate =&gt; 父组件created =&gt; 父组件beforeMount =&gt; 子组件beforeCreate =&gt; 子组件created =&gt; 子组件 beforeMount =&gt; 子组件mounted =&gt; 父组件mounted =&gt; 父组件beforeDestroy =&gt; 子组件 beforeDestroy。<br>从创建到挂载，是从外到内，再从内到外，且mixins的钩子函数总是在当前组件之前执行</p>
<h3 id="组件间如何通信？父子组件，兄弟组件，任意组件？"><a href="#组件间如何通信？父子组件，兄弟组件，任意组件？" class="headerlink" title="组件间如何通信？父子组件，兄弟组件，任意组件？"></a>组件间如何通信？父子组件，兄弟组件，任意组件？</h3><p>1.父子组件：props和$emit<br>2.eventBus:$emit/$on<br>    var Event=new Vue();<br>    Event.$emit(事件名,数据);<br>    Event.$on(事件名,data =&gt; {});<br>3.vuex:Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。<br>缺点：<br>4.</p>
<h3 id="vue-computed实现。"><a href="#vue-computed实现。" class="headerlink" title="vue computed实现。"></a>vue computed实现。</h3><h3 id="vue-diff算法实现。"><a href="#vue-diff算法实现。" class="headerlink" title="vue diff算法实现。"></a>vue diff算法实现。</h3><h3 id="vue-complier-实现"><a href="#vue-complier-实现" class="headerlink" title="vue complier 实现"></a>vue complier 实现</h3><h3 id="computer和watch用法区别？"><a href="#computer和watch用法区别？" class="headerlink" title="computer和watch用法区别？"></a>computer和watch用法区别？</h3><h2 id="vue-router相关部分"><a href="#vue-router相关部分" class="headerlink" title="vue-router相关部分"></a>vue-router相关部分</h2><h2 id="react相关部分"><a href="#react相关部分" class="headerlink" title="react相关部分"></a>react相关部分</h2><h3 id="虚拟dom实现？"><a href="#虚拟dom实现？" class="headerlink" title="虚拟dom实现？"></a>虚拟dom实现？</h3><ol>
<li>用JS对象模拟DOM（虚拟DOM）<br>createElement =&gt; {tag, props, children}<br>h函数接受三个参数：标签名、属性、子节点，最终返回一个虚拟 DOM 的对象</li>
<li>把此虚拟DOM转成真实DOM并插入页面中（render）<br>render方法可以将vNode转化成真实dom<ul>
<li>接收一个dom对象，通过dom对象的类型来亲自创建一个元素</li>
<li>for in遍历该dom对象上的props并且给该元素设置属性setAttr</li>
<li>遍历子节点，如果子节点也是Element的实例，那就给子节点递归调用render方法；反之就说明子节点是个文本节点，通过createTextNode来创建一个文本节点就可以了。</li>
<li>最后把子节点添加到创建出的元素中，返回该元素<br>setAttr方法是给元素设置属性的</li>
<li>switch去判断key的值<br>value 有两种标签带有这样的属性，input和textarea 如果是这两种那就直接将value值赋给它的value上 如果不是那就直接调用setAttribute来设置key和value<br>style style属性就可以直接通过cssText来赋值了<br>其他默认的就直接setAttribute设置即可了<br>renderDom将元素插入到页面内</li>
</ul>
</li>
<li><p>如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）<br>先序深度优先遍历<br> function diff (oldNode, newNode) {</p>
<pre><code>const patches = [] // 声明变量patches用来存放补丁的对象
let index = 0; // 第一次比较应该是树的第0个索引 
// 递归树 比较后的结果放到补丁里
walk(oldNode, newNode, patches, index) // 进行深度优先遍历 
// 返回收集到的大补丁
return patches
</code></pre><p> }<br>walk方法里面比较新旧dom，规则如下：<br>每个元素都有一个补丁，所以需要创建一个放当前补丁的数组</p>
<ul>
<li>旧节点不存在，插入新节点；新节点不存在，删除旧节点</li>
<li>新旧节点如果都是 VNode，且新旧节点 tag 相同</li>
<li>对比新旧节点的属性</li>
<li>对比新旧节点的子节点差异，通过 key 值进行重排序，key 值相同节点继续向下遍历</li>
<li>新旧节点如果都是 VText，判断两者文本是否发生变化</li>
<li>其他情况直接用新节点替代旧节点<br>当前补丁里确实有值的情况，就将对应的补丁放进大补丁包里</li>
</ul>
</li>
<li><p>把差异对象应用到真正的DOM树上（patch）</p>
</li>
</ol>
<ul>
<li>用一个变量来得到传递过来的所有补丁allPatches,patch方法接收两个参数(node, patches)</li>
<li>在方法内部调用walk方法，给某个元素打上补丁,walk方法里获取所有的子节点</li>
<li>给子节点也进行先序深度优先遍历，递归walk,如果当前的补丁是存在的，那么就对其打补丁(doPatch)</li>
<li>doPatch打补丁方法会根据传递的patches进行遍历,判断补丁的类型来进行不同的操作<ol>
<li>属性ATTR,for in去遍历attrs对象，当前的key值如果存在，就直接设置属性setAttr； 如果不存在对应的key值那就直接删除这个key键的属性</li>
<li>文字TEXT,直接将补丁的text赋值给node节点的textContent即可</li>
<li>替换REPLACE,新节点替换老节点，需要先判断新节点是不是Element的实例，是的话调用render方法渲染新节点；</li>
<li>不是的话就表明新节点是个文本节点，直接创建一个文本节点就OK了,之后再通过调用父级parentNode的replaceChild方法替换为新的节点</li>
<li>删除REMOVE,直接调用父级的removeChild方法删除该节点<br>虚拟dom总结：如果没有虚拟dom的话，对比dom是极其困难的，所以最好的方法是重新生成一棵新的树来替换，但这种做性能很差，特别是dom节点过多且改变极少的时候。为了解决这个问题，在dom上方放一层只含有部分必要信息的虚拟dom，当改变发生的时候，精确匹配需要更新的dom，attributes、event listener…然后再精确的更新到真实dom上，减少受影响的dom。但既然有了虚拟层，自然就有了跨平台的副产物，比如像RN，taro等多端统一的框架。事实上，虚拟dom并非那么高效。尤其是dom节点足够小的情况下、或者确实需要整个替换的情况下，直接生成一棵树比diff后再生成要明显高效很多。但虚拟dom的好处是提供了多数场景下的一种通用处理方法。<h2 id="http相关部分"><a href="#http相关部分" class="headerlink" title="http相关部分"></a>http相关部分</h2><h2 id="html布局渲染等相关部分"><a href="#html布局渲染等相关部分" class="headerlink" title="html布局渲染等相关部分"></a>html布局渲染等相关部分</h2><h2 id="git操作相关部分"><a href="#git操作相关部分" class="headerlink" title="git操作相关部分"></a>git操作相关部分</h2><h2 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h2></li>
</ol>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>5种基本类型：undefined,null,number,string,boolean</p>
<h3 id="理解原型和原型链"><a href="#理解原型和原型链" class="headerlink" title="理解原型和原型链"></a>理解原型和原型链</h3><p>Js对象在创建时就包含一个隐式的内部属性<em>proto</em>，这个属性是不可以被直接访问的（<em>proto</em>是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性<em>proto</em>)，这个内部属性指向的就是该对象的原型<br>a.<em>proto</em> = foo.prototype<br><a id="more"></a><br>Construct:<br>原型对象还包含一个construct属性，这个属性指向的是创建所有实例的指向该原型对象的构造函数，即指向的就是那个构造函数<br>Prototype<br>每个函数对象都有一个prototype属性，当这个函数被用来当作构造函数来创建实例的时候，prototype的属性值就会被用来赋值给实例的的<em>proto</em>属性<br>实际上在JavaScript中，所有对象的原型都将追溯到”Object {}”对象<br>所以：实例.<em>proto</em> = fun.prototype<br>fun.prototype.<em>proto</em> = object<br>fun.prototype.construct = fun 函数本身</p>
<p>函数对象和fun.prototype对象相互引用 ： fun.prototype.construct = fun,  fun.prototype 为该对象</p>
<p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用继承的属性和方法</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>我理解的作用域就是你的代码在运行时，各个变量、函数和对象的可访问性或者说是一个作用范围。因为函数本身也是一个作用域，所以作用域分为全局作用域和局部作用域<br>在全局中声明的变量方法可以在任何地方调用，在函数内部申明的局部变量，只能在函数内部访问。<br>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问</p>
<p>函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量<br>闭包：闭包就是能够读取其他函数内部变量的函数，定义在一个函数内部的函数<br>闭包有两个作用：<br>第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）<br>第二个就是让这些外部变量始终保存在内存中 </p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol>
<li>减少延迟加快网页打开速度</li>
<li>重复利用资源减少网络带宽消耗</li>
<li>降低请求次数或者减少传输内容从而减轻服务器压力。<br>浏览器HTTP缓存可以分为强缓存和协商缓存：<br>#### </li>
<li>强缓存：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache）</li>
<li>协商缓存： 协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。</li>
<li>http1.0中的缓存控制：<br>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）<br>Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41<br>If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li>
<li>http1.1中的缓存控制：<br>Cache-Control：缓存控制头部，有no-cache、max-age等多种取值<br>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算<br>If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li>
</ol>
<h3 id="大公司前端资源部署的方案"><a href="#大公司前端资源部署的方案" class="headerlink" title="大公司前端资源部署的方案"></a>大公司前端资源部署的方案</h3><p><a href="https://www.zhihu.com/question/20790576" target="_blank" rel="external">https://www.zhihu.com/question/20790576</a></p>
<h3 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h3><h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><ol>
<li>客户端发送一个syn标志的报文，seq发送序号为x</li>
<li>服务端发送带ack标志和syn标志的报文，seq发送序号为y，表示对客户端syn报文的回应同时询问客户端是否准备好进行数据通讯</li>
<li>客户端必须再发送ack报文，seq发送序号为z，回应服务端<br>qa：为什么是三次不是两次？<br>主要是为了防止已失效的连接请求报文段突然又传送到服务端导致的出错。因为如果客户端发出的第一个连接请求报文段没有丢失而且是在某些网络结点长时间滞留了，以致延误到连接释放后的某个时间才到达服务端，如果是只有2次的话，服务端这个时候一旦确认，连接就已经建立了，但这个时候客户端并没有发出连接请求也就不会理睬服务端，这样服务端的许多资源就会白白浪费。<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4></li>
<li>客户端向tcp发出连接释放报文段fin=1，序号seq=u，并停止再发送数据，主动关闭tcp连接，进入fin-wait-1（终止等待1）状态，等待服务端的确认</li>
<li>服务端收到连接释放报文段后发出确认报文段，ACK=1，确认号ack=u+1，序号seq=u+1，服务端进入关闭等待状态，此时的tcp处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后，进入fin-wait-2（终止等待2）状态，等待服务端发出连接释放报文段</li>
<li>服务端没有要想客户端发送的数据，服务端发出连接释放报文段，fin=1，ACk=1，序号seq=w，确认号ack=u+1，服务端进入最后确认状态，等待客户端的确认</li>
<li>客户端收到服务端的连接释放报文段后，发出确认报文段，ACK=1,seq=u+1,ack=w+1,客户端进入时间等待状态，此时tcp未释放掉，需要经过时间等待计时器设置的2MSL后，客户端才进入到关闭状态</li>
</ol>
<p>qa：为什么time-wait状态必须等待2MSL（最长报文段寿命）？</p>
<ol>
<li>保证客户端发送的最后一个ack报文段能够到达服务端，因为这个报文段可能丢失，是的处于最后确认状态的服务端收不到确认信息，服务端超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态</li>
<li>防止已失效的连接请求报文段出现在本连接中，A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。<br>qa：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>因为服务端收到客户端发送来的fin报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，等服务端确定不会再发送数据后，在发送fin报文，来释放连接</li>
</ol>
<h3 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a>dns域名解析过程</h3><ol>
<li>浏览器搜索自身dns缓存，看看缓存有没有过期，过期缓存的解析就结束，chrome缓存的时间只有一分钟</li>
<li>搜索操作系统自身的dns缓存，没有找到或失效解析结束</li>
<li>读取本地的hosts文件，hosts文件可以建立域名到ip的绑定</li>
<li>浏览器发起一个dns系统调用，调用解析器后，解析器会向运营商服务器发送查询信息，运营商服务会先查找自身缓存，若没有，则主控服务器会代替浏览器发起一个迭代的DNS解析的请求，先查找根域的，运营商服务器拿到域名的IP，返回给操作系统的内核，同时缓存在了自己的缓存区，操作系统内核从DNS服务商拿来的IP地址返回给浏览器。<br><a href="https://juejin.im/entry/599109d46fb9a03c4c270f82" target="_blank" rel="external">https://juejin.im/entry/599109d46fb9a03c4c270f82</a></li>
</ol>
<h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><ol>
<li>应用层(dns,http) DNS解析成IP并发送http请求</li>
<li>传输层(tcp,udp) 建立tcp连接（三次握手）</li>
<li>网络层(IP,ARP) IP寻址</li>
<li>数据链路层(PPP) 封装成帧</li>
<li>物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</li>
</ol>
<h3 id="浏览器解析资源过程"><a href="#浏览器解析资源过程" class="headerlink" title="浏览器解析资源过程"></a>浏览器解析资源过程</h3><p>浏览器内核拿到内容后，渲染的步骤大致可分为以下几个步骤：</p>
<ol>
<li>解析html，构建dom tree<ul>
<li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li>
<li>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li>
<li>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li>
<li>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</li>
</ul>
</li>
<li>解析css，生成css规则树<br> Bytes → characters → tokens → nodes → CSSOM，和解析html类似，也是最终生成css的规则树结构</li>
<li>合并dom树和css规则树，生成render树（dom树和css规则树并不是严格意义上的一对一关系，head这种不可见的标签或者display：none等就会不显示）</li>
<li>布局render树（layout／reflow），负责各元素尺寸，位置的计算<br>计算css样式，构建渲染树，布局（主要定位坐标和大小，是否换行，各种position，overflow，z-index属性）</li>
<li><p>绘制render树（paint），绘制页面像素信息</p>
</li>
<li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p>
</li>
</ol>
<h3 id="浏览器对于静态资源的处理方式"><a href="#浏览器对于静态资源的处理方式" class="headerlink" title="浏览器对于静态资源的处理方式"></a>浏览器对于静态资源的处理方式</h3><p>这里将遇到的静态资源分为一下几大类（未列举所有）：<br>CSS样式资源<br>JS脚本资源<br>img图片类资源</p>
<ol>
<li>遇到外链时的处理<br>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</li>
<li>遇到CSS样式资源<br>CSS资源的处理有几个特点：<ul>
<li>CSS下载时异步，不会阻塞浏览器构建DOM树</li>
<li>会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li>
<li>media query声明的CSS是不会阻塞渲染的</li>
</ul>
</li>
<li>遇到JS脚本资源<br>JS脚本资源的处理有几个特点：<ul>
<li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li>
<li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li>
<li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li>
</ul>
</li>
<li>遇到img图片类资源<br>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</li>
</ol>
<h3 id="回流和重绘，哪些操作会引起回流，哪些会引起重绘"><a href="#回流和重绘，哪些操作会引起回流，哪些会引起重绘" class="headerlink" title="回流和重绘，哪些操作会引起回流，哪些会引起重绘"></a>回流和重绘，哪些操作会引起回流，哪些会引起重绘</h3><p>回流一定会引起重绘，重绘不一定会引起回流</p>
<ol>
<li>回流：元素的内容，结构，位置或者尺寸发生了变化，需要重新计算样式和渲染树</li>
<li>重绘： 元素的改变只影响元素的外观之类eg：背景色，边框颜色，文字颜色等</li>
</ol>
<p>引起回流：</p>
<ol>
<li>页面首次渲染</li>
<li>dom tree结构改变，添加或者删除可见的DOM元素</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<br> （1）offset(Top/Left/Width/Height)<br>  (2) scroll(Top/Left/Width/Height)<br>  (3) cilent(Top/Left/Width/Height)<br>  (4) width,height<br>  (5) 调用了getComputedStyle()或者IE的currentStyle</li>
</ol>
<h3 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h3><p>浏览器渲染的图层一般分为普通图层和复合图层<br>普通文档流可以看作为一个默认复合层，absolute，fixed等虽然脱离了普通文档流但是仍然属于默认复合层</p>
<p>可以通过硬件加速的方式，声明一个新的复合层，它会单独分配资源，这样久不影响默认复合层里的回流重绘，这是由于浏览器的GPU中，各个复合图层是单独绘制的，互不影响</p>
<h4 id="如何变成复合层？"><a href="#如何变成复合层？" class="headerlink" title="如何变成复合层？"></a>如何变成复合层？</h4><ol>
<li>最常见的方式：translate3d，translateZ</li>
<li>opacity属性／过渡动画（执行的过程才会创建复合层）</li>
<li>video，iframe，canvas，webgl等元素</li>
<li>flash插件等</li>
</ol>
<p>复合图层的作用：可以使得元素独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，但是复合图层过多也会导致资源消耗过度，反而更卡<br>注意：硬件加速请使用index，因为如果加速的元素层级较低的话，后面的层级较高的元素会被隐式的转换为同一个复合图层，如此会影响性能</p>
<h3 id="script标签中的async和defer的区别"><a href="#script标签中的async和defer的区别" class="headerlink" title="script标签中的async和defer的区别"></a>script标签中的async和defer的区别</h3><p>浏览器在执行HTML的时候如果遇到script时会停止页面的渲染,去下载和执行js的文件直接遇见/scirpt会继续渲染页面。故浏览器在执行js文件的时候浏览器表现为一片空白,为了解决这个问题ECMAScript定义了defer和async两个属性用于控制JS的下载和执行</p>
<ol>
<li>defer: 对于defer，我们可以认为是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用</li>
<li>async的情况下，js一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果js前后有依赖性，用async，就很有可能出错。</li>
</ol>
<h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><ol>
<li><p>正向代理：是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。（翻墙）</p>
</li>
<li><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。（负载均衡）</p>
</li>
</ol>
<h3 id="get和post请求区别"><a href="#get和post请求区别" class="headerlink" title="get和post请求区别"></a>get和post请求区别</h3><ol>
<li>GET使用URL或Cookie传参，而POST将数据放在BODY中。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。</li>
<li>get会产生一个tcp数据包，post产生2个，get请求时，浏览器会把headers和data一起发送出去，服务器响应200返回数据，post请求时，浏览器会先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200返回数据</li>
<li>GET请求是幂等性的，POST请求不是。（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。）正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</li>
</ol>
<h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<p>SSL/TLS握手流程</p>
<ol>
<li>浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </li>
<li>服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器<br>（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li>
<li>浏览器收到服务端的证书后<ul>
<li>验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</li>
<li>用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<code>Premaster secret</code>，发送给服务器。</li>
<li>利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-<code>session key</code></li>
<li>使用约定好的HASH算法计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。 </li>
</ul>
</li>
<li>服务端收到浏览器的回复<ul>
<li>利用已知的加解密方式与自己的私钥进行解密，获取<code>Premaster secret</code></li>
<li>和浏览器相同规则生成<code>session key</code></li>
<li>使用<code>session key</code>解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</li>
<li>使用<code>session key</code>加密一段握手消息，发送给浏览器 </li>
</ul>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</li>
</ol>
<h3 id="首页白屏优化方式"><a href="#首页白屏优化方式" class="headerlink" title="首页白屏优化方式"></a>首页白屏优化方式</h3><h4 id="为什么会存在白屏？"><a href="#为什么会存在白屏？" class="headerlink" title="为什么会存在白屏？"></a>为什么会存在白屏？</h4><p>因为要打开一个webview页面它做了很多的事情：<br>初始化webview =&gt; 域名解析 =&gt; 请求页面 =&gt; 下载数据 =&gt; 解析dom树 =&gt; 解析css规则树 =&gt; 解析js =&gt; js请求数据 =&gt; 解析渲染 =&gt; 下载渲染图片<br>大致上分为以上，页面在 dom 渲染后才能显示雏形，所以这个过程一长就会导致白屏</p>
<h4 id="优化的几种方式"><a href="#优化的几种方式" class="headerlink" title="优化的几种方式"></a>优化的几种方式</h4><ol>
<li>降低请求量：合并请求资源，减少http请求数量，minify / gzip 压缩，懒加载</li>
<li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li>
<li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。</li>
<li>渲染：JS/CSS优化（GUI渲染线程与JS引擎线程互斥，而且js引擎为单线程，js执行时间过长是会阻塞页面加载的），加载顺序，服务端渲染，pipeline</li>
<li>服务端渲染，客户端缓存<br><a href="https://juejin.im/entry/599646856fb9a02484490c13" target="_blank" rel="external">https://juejin.im/entry/599646856fb9a02484490c13</a></li>
</ol>
<h3 id="数组的slice和splice方法"><a href="#数组的slice和splice方法" class="headerlink" title="数组的slice和splice方法"></a>数组的slice和splice方法</h3><p>slice: 返回数组中的一项或者几项，slice(1) 从位置1到数组最后，slice(1,4)从数组位置1到位置3，位置是从0开始<br>splice: 删除，插入，替换数组中的元素。splice(0,2,’jiemo’,’jiemo1 ‘) 从位置0开始 删除2项，然后插入’jiemo’,’jiemo1’</p>
<h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明：解析器会率先读取函数声明，使其在执行任何代码之前都可访问<br>函数表达式：必须等解析器执行到它所在的代码行，才会真正被解释执行</p>
<h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ol>
<li>工厂模式<br>缺点：没有解决对象的识别问题</li>
<li>构造函数模式</li>
</ol>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>字节按照一定规则在空间上排列就是字节对齐</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>大致分三步：<br>1、找基准（一般是以中间项为基准）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归<br>function quickSort(arr){<br>    //如果数组&lt;=1,则直接返回<br>    if(arr.length&lt;=1){return arr;}<br>    var pivotIndex=Math.floor(arr.length/2);<br>    //找基准，并把基准从原数组删除<br>    var pivot=arr.splice(pivotIndex,1)[0];<br>    //定义左右数组<br>    var left=[];<br>    var right=[];</p>
<pre><code>//比基准小的放在left，比基准大的放在right
for(var i=0;i&lt;arr.length;i++){
    if(arr[i]&lt;=pivot){
        left.push(arr[i]);
    }
    else{
        right.push(arr[i]);
    }
}
//递归
return quickSort(left).concat([pivot],quickSort(right));
</code></pre><p>}</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/项目总结/" rel="tag"># 项目总结</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/16/rem适配/" rel="next" title="rem适配">
                <i class="fa fa-chevron-left"></i> rem适配
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/30/shelljs指令学习/" rel="prev" title="收集一些题">
                收集一些题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="芥末" />
          <p class="site-author-name" itemprop="name">芥末</p>
          <p class="site-description motion-element" itemprop="description">前端开发/程序媛/菜鸟/搬砖</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yaoyue1" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://yaoyue1.github.io/practice/" target="_blank" title="Practice">
                  
                    <i class="fa fa-fw fa-pencil"></i>
                  
                  Practice
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#js基础部分"><span class="nav-number">1.</span> <span class="nav-text">js基础部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue相关部分"><span class="nav-number">2.</span> <span class="nav-text">vue相关部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue生命周期"><span class="nav-number">2.1.</span> <span class="nav-text">vue生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue响应式原理-数据绑定原理？（get，set；proxy）"><span class="nav-number">2.2.</span> <span class="nav-text">vue响应式原理||数据绑定原理？（get，set；proxy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick的理解"><span class="nav-number">2.3.</span> <span class="nav-text">nextTick的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解"><span class="nav-number">2.3.1.</span> <span class="nav-text">理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nextTick的主要应该场景"><span class="nav-number">2.3.2.</span> <span class="nav-text">nextTick的主要应该场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue更新数组"><span class="nav-number">2.4.</span> <span class="nav-text">vue更新数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-data为什么必须是函数"><span class="nav-number">2.5.</span> <span class="nav-text">Vue data为什么必须是函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父子组件created，mounted执行顺序？"><span class="nav-number">2.6.</span> <span class="nav-text">父子组件created，mounted执行顺序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件间如何通信？父子组件，兄弟组件，任意组件？"><span class="nav-number">2.7.</span> <span class="nav-text">组件间如何通信？父子组件，兄弟组件，任意组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-computed实现。"><span class="nav-number">2.8.</span> <span class="nav-text">vue computed实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-diff算法实现。"><span class="nav-number">2.9.</span> <span class="nav-text">vue diff算法实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-complier-实现"><span class="nav-number">2.10.</span> <span class="nav-text">vue complier 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computer和watch用法区别？"><span class="nav-number">2.11.</span> <span class="nav-text">computer和watch用法区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router相关部分"><span class="nav-number">3.</span> <span class="nav-text">vue-router相关部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react相关部分"><span class="nav-number">4.</span> <span class="nav-text">react相关部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟dom实现？"><span class="nav-number">4.1.</span> <span class="nav-text">虚拟dom实现？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http相关部分"><span class="nav-number">5.</span> <span class="nav-text">http相关部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html布局渲染等相关部分"><span class="nav-number">6.</span> <span class="nav-text">html布局渲染等相关部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git操作相关部分"><span class="nav-number">7.</span> <span class="nav-text">git操作相关部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开放问题"><span class="nav-number">8.</span> <span class="nav-text">开放问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">8.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解原型和原型链"><span class="nav-number">8.2.</span> <span class="nav-text">理解原型和原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域和作用域链"><span class="nav-number">8.3.</span> <span class="nav-text">作用域和作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器缓存"><span class="nav-number">8.4.</span> <span class="nav-text">浏览器缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#好处"><span class="nav-number">8.4.1.</span> <span class="nav-text">好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大公司前端资源部署的方案"><span class="nav-number">8.5.</span> <span class="nav-text">大公司前端资源部署的方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp三次握手四次挥手"><span class="nav-number">8.6.</span> <span class="nav-text">tcp三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手："><span class="nav-number">8.6.1.</span> <span class="nav-text">三次握手：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手"><span class="nav-number">8.6.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns域名解析过程"><span class="nav-number">8.7.</span> <span class="nav-text">dns域名解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五层因特网协议栈"><span class="nav-number">8.8.</span> <span class="nav-text">五层因特网协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器解析资源过程"><span class="nav-number">8.9.</span> <span class="nav-text">浏览器解析资源过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器对于静态资源的处理方式"><span class="nav-number">8.10.</span> <span class="nav-text">浏览器对于静态资源的处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回流和重绘，哪些操作会引起回流，哪些会引起重绘"><span class="nav-number">8.11.</span> <span class="nav-text">回流和重绘，哪些操作会引起回流，哪些会引起重绘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通图层和复合图层"><span class="nav-number">8.12.</span> <span class="nav-text">普通图层和复合图层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何变成复合层？"><span class="nav-number">8.12.1.</span> <span class="nav-text">如何变成复合层？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#script标签中的async和defer的区别"><span class="nav-number">8.13.</span> <span class="nav-text">script标签中的async和defer的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正向代理和反向代理"><span class="nav-number">8.14.</span> <span class="nav-text">正向代理和反向代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get和post请求区别"><span class="nav-number">8.15.</span> <span class="nav-text">get和post请求区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http和https区别"><span class="nav-number">8.16.</span> <span class="nav-text">http和https区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首页白屏优化方式"><span class="nav-number">8.17.</span> <span class="nav-text">首页白屏优化方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么会存在白屏？"><span class="nav-number">8.17.1.</span> <span class="nav-text">为什么会存在白屏？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化的几种方式"><span class="nav-number">8.17.2.</span> <span class="nav-text">优化的几种方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的slice和splice方法"><span class="nav-number">8.18.</span> <span class="nav-text">数组的slice和splice方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明和函数表达式"><span class="nav-number">8.19.</span> <span class="nav-text">函数声明和函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象的方式"><span class="nav-number">8.20.</span> <span class="nav-text">创建对象的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节对齐"><span class="nav-number">8.21.</span> <span class="nav-text">字节对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">8.22.</span> <span class="nav-text">快速排序</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">芥末</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  



<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
