<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiemo blog</title>
  
  <subtitle>前端开发/学生/菜鸟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaoyue.com/"/>
  <updated>2017-04-05T08:09:04.000Z</updated>
  <id>http://yaoyue.com/</id>
  
  <author>
    <name>芥末</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>canvas学习一点点（四）--仿知乎登录页</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BB%BF%E7%9F%A5%E4%B9%8E%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（四）-仿知乎登录页/</id>
    <published>2017-04-05T07:28:04.000Z</published>
    <updated>2017-04-05T08:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:<a href="https://yaoyue1.github.io/dot.html" target="_blank" rel="external">传送门</a>,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。<br>看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码<br><a id="more"></a></p><p><pre><br><code><br>    $(function(){<br>      var cvs = document.getElementById(“mycanvas”);<br>      var ctx = cvs.getContext(‘2d’);<br>      var docWidth = document.documentElement.clientWidth;<br>      var docHeight = document.documentElement.clientHeight;<br>      cvs.width = docWidth;<br>      cvs.height = docHeight;//初始化准备，让canvas的宽高等于可视区的宽高<br>      var dotNum = 100;//整个区域粒子的数量<br>      var dots = [];//用来存放粒子对象的数组<br>      var mouse = new Object();//声明的对象用来存放鼠标的初始X、Y值<br>      mouse.x = 800;<br>      mouse.y = 350;<br>      for(var i=0;i<dotnum;i++){ 循环dotnum数量的粒子为每个粒子对象添加属性="" var="" dotobj="new" object();="" dotobj.x="Math.random()*docWidth;//初始的x坐标位置" dotobj.y="Math.random()*docHeight;//初始的y坐标位置" dotobj.r="Math.ceil(Math.random()*4);//粒子半径" dotobj.color="white" ;="" 粒子颜色="" dotobj.speedx="Math.floor(Math.random()*2)?1:-1//粒子X轴的运动方向" dotobj.speedy="Math.floor(Math.random()*2)?1:-1//粒子Y轴的运动方向" dots[i]="dotObj;//把粒子对象装进数组" }="" function="" drawball(x,y,r,color){="" 画每个粒子圆="" ctx.beginpath();="" ctx.arc(x,y,r,0,math.pi*2,false);="" ctx.fillstyle="color;" ctx.fill()="" move(obj){="" 粒子的移动函数="" obj.x="" +="obj.speedX*0.2;//粒子x轴方向每次移动的距离" obj.y="" if(obj.y<="obj.r){//上边界小球反弹处理" obj.speedy*="-1;" if(obj.y="">= docHeight-obj.r){//下边界小球反弹处理<br>          obj.y = docHeight-obj.r;<br>          obj.speedY<em>=-1;<br>        }<br>        if(obj.x&lt;=obj.r){//左边界的小球反弹处理<br>          obj.x = obj.x;<br>          obj.speedX</em>=-1;<br>        }<br>        if(obj.x &gt;= docWidth-obj.r){//右边界的小球反弹处理<br>          obj.x = docWidth-obj.r;<br>          obj.speedX<em>=-1;<br>        }<br>      }<br>      function ballAndball(obj1,obj2){//封装函数用来求两个球或者是球和鼠标直接的直线距离<br>        var disX = Math.abs(obj1.x-obj2.x);//相距的X绝对值<br>        var disY = Math.abs(obj1.y-obj2.y);//相距的Y绝对值<br>        return Math.sqrt(disX</em>disX+disY*disY)//平方根求直线距离<br>      }<br>      function mouseball(mouse,obj){//鼠标移动，把鼠标和距离其130内的小球连成线<br>        if(ballAndball(mouse,obj)&lt;130){<br>          ctx.lineWidth = 0.2;<br>          ctx.beginPath();<br>          ctx.moveTo(obj.x,obj.y);<br>          ctx.lineTo(mouse.x,mouse.y);<br>          ctx.strokeStyle = obj.color;<br>          ctx.stroke();</dotnum;i++){></code></pre></p><pre><code>    }  }  render();  function render(){    ctx.clearRect(0, 0, docWidth, docHeight);//清除画布    for(var j= 0;j &lt; dots.length;j++){//两层for循环，第一层是先画小球然后让每个小球移动，鼠标移动连线      little = dots[j]      move(little)      drawball(little.x,little.y,little.r,little.color)      mouseball(mouse,little)      for(var k = 0;k &lt; dots.length;k++){//第二层循环是用来找出两个球如果相距100就把他们用线连接起来        if(ballAndball(dots[j],dots[k])&lt;100){          ctx.lineWidth = 0.2;          ctx.globalAlpha = (130 - ballAndball(dots[j], dots[k])) * 1 / 100;//这句代码是用来控制线的消失和出现的效果          ctx.beginPath();          ctx.moveTo(dots[j].x, dots[j].y);          ctx.lineTo(dots[k].x, dots[k].y);          ctx.strokeStyle = dots[j].color;          ctx.stroke();        }      }      ctx.globalAlpha = 1.0    }    requestAnimationFrame(render);//浏览器自动刷新时间来循环调用render  }  cvs.onmousemove = function(event){//鼠标移动是的X、Y坐标    e = event || window.event;    mouse = new Object();    mouse.x = e.offsetX;    mouse.y = e.offsetY;  }})</code></pre><p><br>代码的核心部分可能就是求两个小球的距离来再次循环连线了。因为注释写的比较清楚，所以我就不多说了，下次的canvas学习一点点（五）还不知道些什么？？？纠结啊，你有啥想法可以告诉我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:&lt;a href=&quot;https://yaoyue1.github.io/dot.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。&lt;br&gt;看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（三）--黑客帝国</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（三）-黑客帝国/</id>
    <published>2017-04-05T07:27:28.000Z</published>
    <updated>2017-04-05T07:27:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间戳</title>
    <link href="http://yaoyue.com/2017/03/31/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <id>http://yaoyue.com/2017/03/31/时间戳/</id>
    <published>2017-03-31T09:31:09.000Z</published>
    <updated>2017-04-05T08:11:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。还是不扯远了，今天主要讲时间戳。<br>我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳：1491030469000；这样一串数字就是时间戳。<br><a id="more"></a><br>你会想知道明明js可以获取到时间啊，为啥还需要这样传，那是因为js是获取到你系统本地的时间，你想如果你自己调快了时间那岂不是不准确了。所以时间戳的用处就是这样。<br>拿到一串时间戳你要怎样把它转化成为XX年xx月xx日这样的呢？</p><p><img src="http://i.imgur.com/ljI4ovd.png" alt=""></p><p>封装一个方法format（）；这样你只有把时间戳传进去就可以给你返回xx年xx月xx日xx:xx</p><pre><code> function add0(m) {    return m &lt; 10 ? &apos;0&apos; + m : m;}function format(t) {    var time = new Date(parseInt(t) * 1000);    var y = time.getFullYear();    var m = time.getMonth() + 1;    var d = time.getDate();    var h = time.getHours();    var mm = time.getMinutes();    var s = time.getSeconds();    return y+&apos;年&apos;+add0(m) + &apos;月&apos; + add0(d) + &apos;日 &apos; + add0(h) + &apos;:&apos; + add0(mm);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。还是不扯远了，今天主要讲时间戳。&lt;br&gt;我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳：1491030469000；这样一串数字就是时间戳。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（二）--</title>
    <link href="http://yaoyue.com/2017/03/31/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/31/canvas学习一点点（二）/</id>
    <published>2017-03-31T05:49:34.000Z</published>
    <updated>2017-04-01T07:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。<br>最终的效果：<a href="https://yaoyue1.github.io/bar.html" target="_blank" rel="external">传送门</a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;canvas id= &quot;mycanvas&quot; width=&apos;500&apos; height=&apos;500&apos;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure><pre><code>//js$(function(){      var cvs = document.getElementById(&apos;mycanvas&apos;);      var ctx = cvs.getContext(&apos;2d&apos;);      var centerX = cvs.width/2;//圆心的x坐标      var centerY = cvs.height/2;//圆心的y坐标      var rad = Math.PI*2/100;//把2π弧度分成100份，每一份的弧度值      var initNum = 0.1;//初始化的基础百分比      var speed = 0.2;//加载速度      function blueCircle(n){画进度的展示蓝圈          ctx.save();//保存画布状态          ctx.strokeStyle = &quot;#49f&quot;;          ctx.lineWidth = 5;          ctx.beginPath();          ctx.arc(centerX, centerY, 200,-Math.PI/2, -Math.PI/2+n*rad,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function  initCircle(){//画最开始的初始化圆圈          ctx.save();          ctx.beginPath();          ctx.strokeStyle = &quot;white&quot;;          ctx.arc(centerX, centerY, 200, 0,Math.PI*2,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function text(n){//画中间的文字          ctx.save();          ctx.strokeStyle = &quot;#49f&quot;;          ctx.font = &apos;40px Arial&apos;          ctx.strokeText(n.toFixed(0)+&apos;%&apos;,centerX-25, centerY+10);          ctx.stroke();          ctx.restore();      }      draw()      function draw(){          window.requestAnimationFrame(draw);//浏览器的刷新频率自动调整动画的时间间隔          ctx.clearRect(0, 0, cvs.width, cvs.height);//清除上一次画布的内容          initCircle()//调用方法          text(initNum);          blueCircle(initNum);          initNum+=speed;          if(initNum&gt;100){//当进度达到100的时候就让他一直为100，不然你的进度条要破100的~~~~              initNum = 100          }      }  })</code></pre><p>是不是觉得很简单~~代码不多确实jq很难做到的，之前用jq写一般都只能写长条形状的进度条。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。&lt;br&gt;最终的效果：&lt;a href=&quot;https://yaoyue1.github.io/bar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>ios touch事件导致的CSS3动画问题</title>
    <link href="http://yaoyue.com/2017/03/30/ios-touch%E4%BA%8B%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84CSS3%E5%8A%A8%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yaoyue.com/2017/03/30/ios-touch事件导致的CSS3动动画问题/</id>
    <published>2017-03-30T05:57:06.000Z</published>
    <updated>2017-03-31T02:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚做完一个腾讯动漫的项目：<a href="https://www.in66.com/html/tonglingfei/index.html" target="_blank" rel="external">传送门</a>,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当你到达这个页面的时候，你会看到5个不同的美男子，你点击其中任何一个都会去一个相对应的故事，假如你点击第二个你会看到第二张图。第二张图中我用红色框框出来的这些对话框都是需要一个一个的接着出现，所以我当时的第一反应是采用CSS3的animation-delay属性来解决，只需要给每个对话框设置一个延迟的属性，让她依次出来不就行了，我也确实是这样做了。然而因为我穷，只买得起安卓手机，所以只测了安卓一点问题都木有，在chrome模拟器上也啥事没有，我就真信了这样做简直不能太好，等全部做完了，来测试上线的时候才发现ios尼玛的又出现问题了。因为这些故事的页面都超过了一屏，所以必须要滑动屏幕才能看下面的，ios出问题就出现在这：ios当你触摸屏幕或者滑动屏幕时它会暂停掉你屏幕上CSS的渲染，所以只要你的手还在屏幕上，对话框的出现就会被截断，你放开手后才能继续加载。但是蛋疼的是后来加载的对话框它的延迟时间会重头开始算起而不是从你松开手的那一刻算，这就真是坑了，等半天都出不来。</p><p><img src="http://i.imgur.com/YVK0j59.png" alt=""><br><img src="http://i.imgur.com/Ch5vXwA.png" alt=""></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>赶紧去google一下才发现这事前端真的很无辜，是ios事件的处理机制有关。<br>ios和安卓不同，他们处理事情的机制顺序不一样。</p><ul><li>ios的处理机制是：它的响应顺序依次为：Touch——Media——Service——Core架构，你可以看到它最先响应的是屏幕的反应，所以只要用户触摸屏幕，系统最先去处理的就是touch了，此时会暂停屏幕上包括js、css的渲染，这个时候不光是css动画不动了，哪怕页面没有加载完如果你手指头还停留在屏幕上那么页面也不会继续加载，直到你的手松开</li><li>Android的处理机制是：它的响应顺序依次为：Application——Framework——Library——Kernal架构，和屏幕显示相关的处于library这一层，所以当你对屏幕操作之后，Android首先会激活应用、框架，然后才是屏幕最后是核心架构。</li></ul><p>以上就是为啥安卓手机很流畅，ios却出现了CSS3动画的滚动停止了。<br>那到底该咋解决呢？？到底该咋解决呢？？<br>其实到现在我的解决方式都不算太好，我把原先用CSS3控制顺序的方式改成了用js的setTimeout()的方式，你也看到了，这真的很不好，写了一堆的setTimeout函数，但是这样做虽不能解决滚动时停止加载，但是最起码时间的计算方式不是从头开始算的了。找不到更好的方法了，如果你知道，请不要害羞的多多指教~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚做完一个腾讯动漫的项目：&lt;a href=&quot;https://www.in66.com/html/tonglingfei/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（一）</title>
    <link href="http://yaoyue.com/2017/03/30/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/30/canvas学习一点点（一）/</id>
    <published>2017-03-30T05:47:18.000Z</published>
    <updated>2017-03-31T07:18:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~</p><p>今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。<br>最终效果链接：<a href="https://yaoyue1.github.io/snow.html" target="_blank" rel="external">传送门</a><br>快和你的妹纸一起来看雪吧~~~<br><a id="more"></a></p><pre><code>//html&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;//js$(function(){ snow()function snow(){    var docWidth = document.documentElement.clientWidth //可见区域宽度    var docHeight = document.documentElement.clientHeight //可见区域高度    // initPage()    function initPage(){        containerWidth = $(&quot;.container&quot;).width();//获取外层容器container宽度        containerHeight = $(&quot;.container&quot;).height();//获取外层容器container高度        initFloatAnimation()    }    function initFloatAnimation(){        var canvas = document.createElement(&apos;canvas&apos;);//创建canvas元素        var ctx = canvas.getContext(&apos;2d&apos;);            canvas.id = &apos;floatCanvas&apos;;//给canvas一个id            canvas.width = containerWidth;//让canvas的宽度等于container的宽度            canvas.height = containerHeight;//让canvas的高度等于container的高度        $(&quot;.container&quot;).append(canvas);//把canvas追加进html的container        var particleNum = 100;//粒子的数量        var particles = [];//定义空数组用来存储每个粒子对象        for (var i=0;i&lt;particleNum;i++){            var particleObj = new Object();//创建一个对象            particleObj.x = Math.random()*docWidth;//在可视区域宽度的范围内随机生成粒子的初始x坐标            particleObj.y = Math.random()*docHeight;//在可视区域g的范围内随机生成粒子的初始y坐标            particleObj.vx = Math.random() * 2-1;//生成粒子横向移动的距离            particleObj.vy = (Math.random() * 0.8 + 0.2);//生成粒子纵向移动的距离：[0.2-1]            particleObj.dw = particleObj.vy*20;//随机生成粒子的宽度            particleObj.dh = particleObj.dw;//粒子的宽度等于高度            particleObj.ag = (Math.random()*2-1)*10;//粒子的初始角度            particles[i] = particleObj;//把这些对象装进事先定义的数组        }        console.log(particles)        // 以上把需要的元素都准备好了，接下来就是渲染让粒子动起来        render()        function render(){            ctx.clearRect(0, 0, containerWidth, containerHeight);//清除画布            var little;            for(var j=0;j&lt;particles.length;j++){                little = particles[j];                if(little.x &lt; 0 || little.x &gt; containerWidth || little.y &gt; containerHeight){//if判断如果粒子已经超出了可视的边界就再重新产生它的x,y值                    little.x = Math.random() * containerWidth;                    little.y = Math.random() * -200;                }                little.x += little.vx;                little.y += little.vy;                drawImage(ctx,img,little.x,little.y,little.dw,little.dh,1,little.ag);            }            requestAnimationFrame(render);//循环调用自身，requestAnimationFrame是一个新的API,作用与setTimeInterval一样，不同的是它会根据浏览器的刷新频率自动调整动画的时间间隔。        }    }    function drawImage (ctx,img,dx,dy,dw,dh,scale,angle) {        ctx.save();        ctx.translate(dx + dw / 2, dy + dh / 2);//移动画布        ctx.scale(scale, scale);        ctx.rotate(angle);        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -1 * dw / 2, -1 * dh / 2, dw, dh);//重新绘制新的粒子        ctx.restore();    }var _base = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAlCAMAAADyQNAxAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALnRSTlMArr2Dd6phklkuBYhdNo0yOmpFFZd/exkOCW4/VkqecqdlJh4Ro04jtVG5KpuwTP8QawAAArlJREFUOMuVlNmSsjAQhXUIIYGEhM0g+6Igou//ev9hsZwZay7+ruLuq3O6T7o5/H+5Z/cQRZfzOT3/DZ2jyHRc8Xmcxz76g7n0nHOpda5zqTg3509BNzWz0mVZDkMxFVMZytlcUve32chlODEmmKCUClaEuebd+BMyXOYDEy0NsqCuSZZRUbCcj5fvVNrLsBBtRjKSnBIrOZEsoGLQSkbfpEaVFzQghCQWyvMsK6kDysJcjm8lrmBHM3KyPN/3HccHCrlWwNS8KKN0yFqYeb4TV3FVxbHjexYhgRjkvLfmrk1lEAJztRvbbppr7HgJIS0LVb931elBBMSynMf1uJZt2wsGU1poHm1SvCxonVh+3NhAXlzlL54s3AZIOzmIzIJUtVK3++22YjE8M6FVdwYVcc0g5fmxDeh5/0Ldnke7iSEWiFKOKaieY0ACwweg29dWd6hVjnWqKZNm0yqhhQErUKvSqnZsFoq0g+wuC6VKaFm+c7WPz51BHe3HEgZluYowouGhCJCo0+yOe2MNKKteori4mBGOATktWvbz3Ra0kP+Wq7vOONH65DkPiN12qYWKHQxJi9XxYDo1tASNVfba/v2G77ik72NGMW1JuEZOYnnqRwOx5yJzB7U+EYIY0NZCjSpk6wshi+a4F3JA8xkddAdqe6JSoH9g2BobZnZzvWJ3EkiVsl8M1yzyYt1By4mxO9fq+oAdIg1oKHnk7rs6qm0LLQ+L6sTOtq01bilUJn3dYjTrSWDv1533EZOXnBYlkSPS93X0Ki9xHjXBAaFgRgCxKefRfuD7AFh9RmlN1sraIKBFoRXme5d7McAG2LYBBbFcd5nnyryR3XTmWheTEAxVsAnTjbD7XVHfzVLn5YRfShhikU0Ku49y3bSbuVKSK87n/tXSJ5deTGd6E6XpT7NPQffwKfIPFOtCNONyh58AAAAASUVORK5CYII=&quot;    //图片我直接用的base64来写的    var img = new Image();    img.src = _base;    img.onload = function() {        initPage()    }}})</code></pre><p>   个人感觉注释已经写的比较详细了，就不再多说了哈~~，来和你的妹纸一起来看雪吧！！！</p><p>   什么？？？你没有没有啊？？</p><p><img src="https://a-ssl.duitang.com/uploads/item/201609/04/20160904102522_Fadn4.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~&lt;/p&gt;
&lt;p&gt;今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。&lt;br&gt;最终效果链接：&lt;a href=&quot;https://yaoyue1.github.io/snow.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;快和你的妹纸一起来看雪吧~~~&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>下拉加载你这个坑货~</title>
    <link href="http://yaoyue.com/2017/03/15/%E4%B8%8B%E6%8B%89%E5%8A%A0%E8%BD%BD%E4%BD%A0%E8%BF%99%E4%B8%AA%E5%9D%91%E8%B4%A7-1/"/>
    <id>http://yaoyue.com/2017/03/15/下拉加载你这个坑货-1/</id>
    <published>2017-03-15T04:00:53.000Z</published>
    <updated>2017-03-15T09:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>   前两天刚做的一个<a href="https://www.in66.com/html/photoShare2017/index.html" target="_blank" rel="external">项目</a>,需要用下拉加载的方式去请求数据。我原以为这会是很简单的，肯定分分钟写完（不过确实也挺简单的），只不过还是坑了我一些的。</p><h3 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h3><p><pre><br>$(window).scroll(function(){<br>　　var scrollTop = $(this).scrollTop();<br>　　var scrollHeight = $(document).height();<br>　　var windowHeight = $(this).height();<br>　　if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“you are in the bottom”);<br>　　}<br>});<br></pre><br><a id="more"></a><br>看完上面的代码是不是觉得完全没有毛病，嗯呐~，当初我也是这样觉得的，很对呀。而且我在安卓手机和chrome模拟器上完全没有问题。scrollTop获取的是滚动条滚动的距离，scrollHeight获取到的是整个文档的高度，windowHeight是获取当前也就是你浏览器所能看到的页面的那部分的高度，你已经滚过的高度+你目前看到的剩下的可视高度等于你整个文档高度的时候，确实表示了滚动条就在文档的最下面了。嗯，灰常好。然后你就灰常开心的去请求数据去了，也就是这样：<br><img src="http://i.imgur.com/OExNWyP.png" alt=""><br>是不是你现在也觉得木有毛病。我当时测的时候也很开心。但是当我去借了个苹果的测试机来测的时候尼玛问题来了。也就是我要讲到的第一个坑。这段js对苹果木有反应。我就想着是咋回事嘛~，搞了半天才发现，原来自己傻了</p><p><pre><br>if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“you are in the bottom”);<br>　　}<br></pre><br>其实坑就在这句话中，因为是写的等于，所以只有一个点能判断到达底部了，如果你不断的触动屏幕，很有可能的你滚动条就已经达不到这个点了，而且加上苹果手机到达底部的时候，你再滑动的时候页面会被拖出一个区域，所以这个点对于苹果手机来说有问题。所以不能改成一个点。而且还有一个重要的原因就是，你的数据是请求得来的，你还需要拿数据去渲染页面，为了用户不等待，你需要预留一段时间来请求，而不是等到已经最底部了再去请求。所以我立马高兴的改成了这样：</p><p><pre><br>if(scrollTop + windowHeight &gt; scrollHeight -100){<br>　　　　alert(“you are in the bottom”);<br>　　}<br></pre><br>这样就是代表你在距离底部100px的时候都会给你触发到达底部了。这样果然苹果没问题了。但是我立马发现了另外一个问题，也就是坑二。</p><h3 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h3><p>数据重复了，啥意思呢？就是说你的滚动条如果一直在距离底部100px的范围内得到话，它就会给你去执行你的render()方法，然后去渲染页面。你想如果你一直在100px的范围的话，那他就会给你不断的去发请求，上一个请求还没执行完，你又去了，请求的数据肯定会被重复。所以解决的办法呢就是你设置一个标志，如果上一次请求成功了之后，页面渲染完成了之后，你再去请求，这样就好了。代码如下：<br><img src="http://i.imgur.com/nCJqq2h.png" alt=""><br>相比于刚刚的代码，我加上了一个isSucc的变量来判断，第一次请求这个变量是true，你可以去请求，一进入后立马把这个变量设置为false，代表我这次的请求还没完全走完，你下一波等等，等到页面完全渲染好了，请求已经done了后你再把这个变量设置为true，然后下一波就可以去请求了。</p><p>你以为写到现在完了，其实还有一个问题，就是当数据库中已经没有数据了，你就不能再狂发请求了，所以你还需要干一件事，就是再设置一个标志来判断数据库中是否还有数据，有，就去请求，没有就不要再去请求了。<br>所以最终的代码应该是这样：<br><img src="http://i.imgur.com/REdmMFd.png" alt=""><br>好啦~到现在为止一个下拉加载才写好了，啦啦啦啦啦~写的不对的地方望大神指教好改正！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   前两天刚做的一个&lt;a href=&quot;https://www.in66.com/html/photoShare2017/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目&lt;/a&gt;,需要用下拉加载的方式去请求数据。我原以为这会是很简单的，肯定分分钟写完（不过确实也挺简单的），只不过还是坑了我一些的。&lt;/p&gt;
&lt;h3 id=&quot;坑一&quot;&gt;&lt;a href=&quot;#坑一&quot; class=&quot;headerlink&quot; title=&quot;坑一&quot;&gt;&lt;/a&gt;坑一&lt;/h3&gt;&lt;p&gt;&lt;pre&gt;&lt;br&gt;$(window).scroll(function(){&lt;br&gt;　　var scrollTop = $(this).scrollTop();&lt;br&gt;　　var scrollHeight = $(document).height();&lt;br&gt;　　var windowHeight = $(this).height();&lt;br&gt;　　if(scrollTop + windowHeight == scrollHeight){&lt;br&gt;　　　　alert(“you are in the bottom”);&lt;br&gt;　　}&lt;br&gt;});&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>和clip-path来场美丽的初识</title>
    <link href="http://yaoyue.com/2017/03/08/%E5%92%8Cclip-path%E6%9D%A5%E5%9C%BA%E7%BE%8E%E4%B8%BD%E7%9A%84%E5%88%9D%E8%AF%86/"/>
    <id>http://yaoyue.com/2017/03/08/和clip-path来场美丽的初识/</id>
    <published>2017-03-08T02:30:01.000Z</published>
    <updated>2017-03-21T08:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>  公司前端的技术分享轮到我了，有点小迷茫，不知道该讲什么，纠结来纠结去，偶然看到了腾讯全端 AlloyTeam团队的一篇博文分享，是关于clip-path的，虽然写的比较简单（也可能是我的level还没有达到辣么个水平,完全不能理解）但是真的被那个炫酷的动画给迷倒了。就想一探究竟，然后讲讲这个。（其实最主要我还是觉得这个属性大家平时用到的不多，可能很多人也不是特别了解，作为一个实习生去讲给一堆大牛听这种偏冷门的属性是最合适不过了，哈哈哈，小心机一下）正式开始写啦啦~</p><h3 id="clip-path基本属性"><a href="#clip-path基本属性" class="headerlink" title="clip-path基本属性"></a>clip-path基本属性</h3><p>clip-path一共有四个基本的属性裁剪再加上一个可以直接引用SVG的属性算是五个吧。前面四个基本的是polygon（多边形），circle（圆形），ellipse（椭圆）、inset（圆弧）。下面先开始说这四个属性：</p><h4 id="裁剪多边形"><a href="#裁剪多边形" class="headerlink" title="裁剪多边形"></a>裁剪多边形</h4><p><pre><br>-webkit-clip-path: polygon(0 25%,25% 0,75% 0,100% 25%,100% 75%,75% 100%,25% 100%,0 75%);<br></pre><br><a id="more"></a><br>一步一步分析：以上一共是8组坐标，每组坐标之间用逗号隔开，前面的一个表示x坐标，后面一个表示y坐标，所有的坐标连接起来就构成你所需要裁剪的形状。（原谅本人较懒随便用qq截图画的这个坐标(^o^)/~，之后的坐标都是这样的，我就更懒得画了）</p><p><img src="http://i.imgur.com/sz4Ch4N.png" alt=""></p><h4 id="裁剪圆形"><a href="#裁剪圆形" class="headerlink" title="裁剪圆形"></a>裁剪圆形</h4><p><pre><br>-webkit-clip-path: circle(300px at 50% 50%);<br></pre><br>画圆是circle:接受三个参数，第一个参数为圆的半径，第二个参数为圆的圆心x坐标，第三个参数为圆的圆心y坐标，用at隔开</p><p><img src="http://i.imgur.com/Nbzb5t7.png" alt=""></p><h4 id="裁剪椭圆"><a href="#裁剪椭圆" class="headerlink" title="裁剪椭圆"></a>裁剪椭圆</h4><p><pre><br>-webkit-clip-path: ellipse(50% 40% at 50% 50%);<br></pre><br>裁剪椭圆为ellipse：at前面的一对值表示椭圆的半径值（a,b），at后面的一对值表示椭圆的圆心值<br><img src="http://i.imgur.com/2ult15m.png" alt=""></p><h4 id="裁剪圆弧"><a href="#裁剪圆弧" class="headerlink" title="裁剪圆弧"></a>裁剪圆弧</h4><p><pre><br>-webkit-clip-path:  inset(30px 90px 50px 90px round 0 25% 0 25%);<br></pre><br>inset属性老版本的chrome浏览器可能不支持。它有8个参数，round前面的四个值表示上、右、下、左的四个坐标值，round后面的四个值表示top-radius right-radius bottom-radius left-radius等弧度。</p><p><img src="http://i.imgur.com/xTdSXJT.png" alt=""></p><h3 id="实际用例"><a href="#实际用例" class="headerlink" title="实际用例"></a>实际用例</h3><p>就这么个普通的clip-path属性你可能会想它在实际的应用中一般都有啥用途呢？我将列举一下它比较常见的通途，如果你有遇到比较好玩的，也可以告诉我哦~~对啦在讲应用前还是先贴一张clip-path属性的浏览器支持情况：<br><img src="http://i.imgur.com/Tuf1SKm.png" alt=""></p><h4 id="小三角形的实现"><a href="#小三角形的实现" class="headerlink" title="小三角形的实现"></a>小三角形的实现</h4><p><img src="http://i.imgur.com/LuuZY9k.png" alt=""></p><p>如图的对话框下面的小三角形就可以使用clip-path的方法实现。当然这个小三角形的实现方法也不是只有这一种，而且此种方法也是有一些弊病的，就是ie浏览器是不会支持你的哈哈哈哈~~<br>关于这个小三角形实现的其他几种方法我也提一下吧，都是自己之前做项目的时候使用过的，顺便写一下，自己再熟悉一下。</p><ul><li>第一种：clip-path    </li></ul><p>也就是把一个小的div裁剪成一个三角形在定位到指定位置</p><pre><code>//html&lt;div class=&quot;tangle1&quot;&gt;  &lt;span&gt;hello world!&lt;/span&gt;  &lt;div class=&quot;icon1&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle1{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon1{        position: absolute;        left:70%;        top:100%;        width: 50px;        height: 30px;        background: #f5a0bd;        -webkit-clip-path: polygon(0 0,100% 0,50% 100%)    }</code></pre><ul><li><p>第二种：transparent</p><pre><code>//html&lt;div class=&quot;tangle2&quot;&gt;    &lt;span&gt;hello world!&lt;/span&gt;    &lt;div class=&quot;icon2&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle2{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon2{        position: absolute;        left:70%;        top:99%;        width: 0px;        height: 0px;        font-size: 0;        border: 20px solid transparent;        border-top-color: #f5a0bd;    }</code></pre></li><li>第三种：transfrom 的旋转功能</li><li><pre><code>//html&lt;div class=&quot;tangle3&quot;&gt;  &lt;span&gt;hello world!&lt;/span&gt;  &lt;div class=&quot;icon3&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle3{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon3{        position: absolute;        left:70%;        top:93%;        width: 30px;        height: 30px;        background-color: #f5a0bd;        transform: rotate(45deg);    }</code></pre><h4 id="species-in-pieces"><a href="#species-in-pieces" class="headerlink" title="species-in-pieces"></a>species-in-pieces</h4><p>先给你看个网站：<a href="http://species-in-pieces.com/#" target="_blank" rel="external">传送门</a>，你会不会和我第一次看到的那样一样惊叹。怎么可以实现这么炫酷的效果。<br>今天我就来讲讲这是咋实现的。<br><img src="http://i.imgur.com/99XETlr.png" alt=""><br>拿这个动物来说，你会发现这些图形都是由30个如下的代码组成。每个shard的宽高都是100%，他们都是position：absolute。</p><p>  <div class="shard-wrap"></div></p><pre><code>&lt;div class=&quot;shard&quot;&gt;&lt;/div&gt;</code></pre><p>  <br>也就是说其实这些图形都是堆叠在一起的他们的宽高都是100%是为了响应式~他们的样式是同个nth-child(n)来实现的，例如：</p><p>   //child one<br>  .shard-wrap:nth-child(1) .shard {</p><pre><code>-webkit-clip-path: polygon(11.1% 81.286%, 13.9% 80.286%, 13.9% 74.429%);        clip-path: polygon(11.1% 81.286%, 13.9% 80.286%, 13.9% 74.429%);background-color: #262327;-webkit-transition-delay: 0.02s;        transition-delay: 0.02s;</code></pre><p>  }<br>   //child two<br>  .shard-wrap:nth-child(2) .shard {</p><pre><code>-webkit-clip-path: polygon(9.6% 71.3%, 11.2% 81.2%, 13.95% 74.571%);        clip-path: polygon(9.6% 71.3%, 11.2% 81.2%, 13.95% 74.571%);background-color: #3C3642;-webkit-transition-delay: 0.04s;        transition-delay: 0.04s;</code></pre><p>  }<br>这样就可以控制每个三角形的样式和颜色。最后组合成为这个图形。你会发现这真没啥难得，想要hover这个图片的时候变化成另外一个动物比方说这个<br><img src="http://i.imgur.com/Pf8WLgN.png" alt=""><br>只需要给每个shard命名的class再加上一个hover的新样式就可：<br><img src="http://i.imgur.com/TENe2KI.png" alt=""><br>这样的直接变化可能会太突然，所以你可以给所有的shard加上一个transition</p><pre><code>-webkit-transition: all 1s;transition: all 1s;</code></pre><p>然后给每个shard加上不同时间的延迟动画，这样就好变的很好了。我写的<a href="https://yaoyue1.github.io/clip_path/last.html" target="_blank" rel="external">demo</a>点击一下第一个动物出现，点击两下第二个动物出现。</p></li></ul><p>也许你也会觉得这确实很简单，但是这些shard的polygon后的裁剪数据是怎样得来的，那我就要告诉你算的的！！就是算出来的。我也觉得真是复杂~所以我觉得真的需要一个强大的设计师~这是一个灵感满满的设计和动效。这些数据是需要事先提取出来的~</p><h4 id="写几个小动画"><a href="#写几个小动画" class="headerlink" title="写几个小动画"></a>写几个小动画</h4><p><a href="https://yaoyue1.github.io/clip_path/littleicon.html" target="_blank" rel="external">demo</a><br>是不是觉得你小瞧了clip-path这个属性了。当初我也是以为他只能裁剪一下图片而已的。</p><p><img src="http://i.imgur.com/ws4s1hb.png" alt=""></p><p>这个动画有一个点需要注意的是：这些字母都是通过一个div裁剪的例如第二个字母K，它是由12个顶点所组成的，所以你的div从刚开始就必须由12个点组成，不然浏览器咋知道你要重一个长方形的div变成是一个字母K，所以这里就存在一条件：动画在一定条件下可以对clip-path生效 . 这里的一定条件即裁剪的多边形必须具有相同的顶点数。</p><p>这里就算是讲完clip-path的前四个基本属性了，把最后一个与SVG相引用的属性方最后讲是因为我最喜欢这个属性了，可好玩了~</p><h3 id="clip-path与SVG配合"><a href="#clip-path与SVG配合" class="headerlink" title="clip-path与SVG配合"></a>clip-path与SVG配合</h3><p>先上张图：</p><p><img src="http://i.imgur.com/lzqH2O7.png" alt=""></p><p>是不是超级美，我可是用代码写不出来这路径的，但是SVG可以。<br>clip-path的最后一个属性是-webkit-clip-path: url(#svgTextPath);url中间引用的是一段SVG的路径。当然我还不会写，但是我知道咋弄，，哈哈哈，来推荐一个<a href="http://www.yyyweb.com/ctools/demo.php?t=http%3A%2F%2Feditor.method.ac%2F&amp;h=2000&amp;c=&amp;n=" target="_blank" rel="external">网站</a>这是一个SVG的在线编辑器</p><p><img src="http://i.imgur.com/SRgETH7.png" alt=""></p><p>我框的这个是用来画路径的</p><ol><li><p>我先画两个<br><img src="http://i.imgur.com/QnUqTGh.png" alt=""></p></li><li><p>然后把这个文件保存为SVG，把这个svg用你的编辑器打开，你会发现他记录了一长串的路径~我们需要的就是这段路径，把它copy下来。像这样放到你的html的body中</p><pre><code>&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;    &lt;svg height=&quot;0&quot; width=&quot;0&quot;&gt;   &lt;defs&gt;       &lt;clipPath id=&quot;svgTextPath&quot;&gt;           //你copy的路径        &lt;/clipPath&gt;   &lt;/defs&gt;&lt;/svg&gt;    </code></pre><p>img的图片换成你自己喜欢的,然后给这个图片加上-webkit-clip-path: url(#svgTextPath)的属性，你想要的效果就出现啦啦啦~</p></li></ol><p><img src="http://i.imgur.com/3ffWx4p.png" alt=""></p><p>是不是很好看~</p><p>最后的最后我要对你说，你真的好厉害~居然看到这里了。我自己都不忍心写到这里的，哈哈哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  公司前端的技术分享轮到我了，有点小迷茫，不知道该讲什么，纠结来纠结去，偶然看到了腾讯全端 AlloyTeam团队的一篇博文分享，是关于clip-path的，虽然写的比较简单（也可能是我的level还没有达到辣么个水平,完全不能理解）但是真的被那个炫酷的动画给迷倒了。就想一探究竟，然后讲讲这个。（其实最主要我还是觉得这个属性大家平时用到的不多，可能很多人也不是特别了解，作为一个实习生去讲给一堆大牛听这种偏冷门的属性是最合适不过了，哈哈哈，小心机一下）正式开始写啦啦~&lt;/p&gt;
&lt;h3 id=&quot;clip-path基本属性&quot;&gt;&lt;a href=&quot;#clip-path基本属性&quot; class=&quot;headerlink&quot; title=&quot;clip-path基本属性&quot;&gt;&lt;/a&gt;clip-path基本属性&lt;/h3&gt;&lt;p&gt;clip-path一共有四个基本的属性裁剪再加上一个可以直接引用SVG的属性算是五个吧。前面四个基本的是polygon（多边形），circle（圆形），ellipse（椭圆）、inset（圆弧）。下面先开始说这四个属性：&lt;/p&gt;
&lt;h4 id=&quot;裁剪多边形&quot;&gt;&lt;a href=&quot;#裁剪多边形&quot; class=&quot;headerlink&quot; title=&quot;裁剪多边形&quot;&gt;&lt;/a&gt;裁剪多边形&lt;/h4&gt;&lt;p&gt;&lt;pre&gt;&lt;br&gt;-webkit-clip-path: polygon(0 25%,25% 0,75% 0,100% 25%,100% 75%,75% 100%,25% 100%,0 75%);&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CSS3" scheme="http://yaoyue.com/categories/CSS3/"/>
    
    
      <category term="CSS3" scheme="http://yaoyue.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃（三）</title>
    <link href="http://yaoyue.com/2017/02/20/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/02/20/vue入门到放弃（三）/</id>
    <published>2017-02-20T03:12:42.000Z</published>
    <updated>2017-02-21T07:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<p> 上两篇关于Vue的博文，一篇是环境的搭建和运行，另一篇是自己回顾之前所学的基本指令。这些准备完毕之后，也是时候来写demo练手了，不然好像一直看文档看API也没啥作用，开始啦，自己一边写demo一边把重要的部分记录下来吧。<br> <a id="more"></a></p><h3 id="新建项目文件夹"><a href="#新建项目文件夹" class="headerlink" title="新建项目文件夹"></a>新建项目文件夹</h3><p>通过Vue init webpack searchdemo新建一个项目。<br><img src="http://i.imgur.com/6352VQQ.png" alt=""><br>进入项目文件：cd searchdemo</p><p>安装项目依赖：cnpm install</p><p>运行项目：npm run dev</p><h3 id="划分目录结构"><a href="#划分目录结构" class="headerlink" title="划分目录结构"></a>划分目录结构</h3><p>这个demo是一个切换搜索浏览器的页面，所以可以划分成一个logo选择的组件和一个搜索面板的组件。目录结构如下：static用于存放静态资源</p><p><img src="http://i.imgur.com/INUMDFO.png" alt=""></p><p>目录结构划分好后App.Vue就可以把连个组件引进来了，但是考虑到logo选择的组件是需要和下面的搜索面板的组件通信的，所以我没有把这个两个组件同时进入到app.vue中而是把logo组件引入到搜索面板组件中，最后再把搜索面板组件引入到APP.Vue中。</p><h3 id="组件logoSelect编写"><a href="#组件logoSelect编写" class="headerlink" title="组件logoSelect编写"></a>组件logoSelect编写</h3><p>在logo组件编写的时候需要注意的点：</p><h4 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h4><p>v-cloak：在使用vuejs、angularjs开发时，经常会遇见在如Chrome这类能够快速解析的浏览器上出现表达式( ),或者是模块(div)的闪烁。对于这个问题由于JavaScript去操作DOM，都会等待DOM加载完成（DOM ready）。对于vuejs、angularjs这些会在DOM ready完会才回去解析html view Template，所以对于Chrome这类快速的浏览器你会看见有闪烁的情况出现。而对于IE7，8这类解析稍慢的浏览器大部分情况下是不会出现这个问题的。</p><h3 id="向父组件传递参数"><a href="#向父组件传递参数" class="headerlink" title="向父组件传递参数"></a>向父组件传递参数</h3><p><img src="http://i.imgur.com/qMDTjFc.png" alt=""><br>使用$emit()像父组件即搜索面板传递参数。触发父组件的自定义事件，向父组件传参数,selectNow是选择了哪个搜索引擎的索引，父组件得到了之后就可以指定搜索时跳转到哪个搜索引擎。父子组件通信可以看vue文档 组件那一章</p><h3 id="组件searchPanel的编写"><a href="#组件searchPanel的编写" class="headerlink" title="组件searchPanel的编写"></a>组件searchPanel的编写</h3><p><img src="http://i.imgur.com/hcx4oWQ.png" alt=""><br>组件搜索面板需要利用jsonp进行跨域请求，所以必须按照网络请求模块 vue-resource</p><p><pre><br>cnpm install  vue-resource –save<br></pre><br>并在main.js中使用</p><p><pre><br>var vueResource = require(‘vue-resource’);<br>Vue.use(vueResource);<br></pre><br>否则会报不认识jsonp属性的错误。</p><p>最后放上GitHub源码地址：<a href="https://github.com/yaoyue1/Vue-" target="_blank" rel="external">https://github.com/yaoyue1/Vue-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 上两篇关于Vue的博文，一篇是环境的搭建和运行，另一篇是自己回顾之前所学的基本指令。这些准备完毕之后，也是时候来写demo练手了，不然好像一直看文档看API也没啥作用，开始啦，自己一边写demo一边把重要的部分记录下来吧。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router(上)</title>
    <link href="http://yaoyue.com/2017/02/17/vue-router-%E4%B8%8A/"/>
    <id>http://yaoyue.com/2017/02/17/vue-router-上/</id>
    <published>2017-02-17T08:59:58.000Z</published>
    <updated>2017-02-17T09:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触了点Vue后，自己屁颠屁颠去搜索一些实例的来看，结果各种出现Vue-router，尼玛这又是干嘛的？？？（黑人问号脸），于是去Vue-router的官方文档上瞅瞅，遂写了这篇笔记式的博文。</p><h3 id="vue-router是干嘛的？"><a href="#vue-router是干嘛的？" class="headerlink" title="vue-router是干嘛的？"></a>vue-router是干嘛的？</h3><p>Vue-router是Vue.js的官方路由插件，Vue的单页面应用是基于路由和组件的，路由用于设定访问的路径，并将路径和组件映射起来。之前我们写项目的时候，页面之前的切换时和跳转是通过超链接等来实现的，在Vue-router单页面应用中，则是通过路径的切换。<br><a id="more"></a></p><h3 id="使用基本步骤"><a href="#使用基本步骤" class="headerlink" title="使用基本步骤"></a>使用基本步骤</h3><ol><li>导入文件<br><pre><br>// 导入Vue，这个是必需的，在使用Vue之前，必须先导入<br>import Vue from ‘vue’<br>// 导入 vue-router，并使用<br>import VueRouter from ‘vue-router’<br>Vue.use(VueRouter) </pre></li></ol><hr><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><ol><li><p>定义路由组件。可以从其他文件import进来</p><pre>const Foo = { template: '<div>foo</div>' }const Bar = { template: '<div>bar</div>' }</pre></li><li><p>配置路由</p><pre>const routes = [   {       path: '/foo',       component: Foo   },   {       path: '/bar',       component: Bar   }  ] </pre></li><li>创建router实例<pre>const router = new VueRouter({   routes  // （缩写）相当于 routes: routes})</pre></li><li>创建和挂载根实例<br><pre><br>// 记得要通过 router 配置参数注入路由，<br>// 从而让整个应用都有路由功能<br>const app = new Vue({<br>router<br>}).$mount(‘#app’)//$mount是在Vue实例在实例化的时候没有收到el选项处于“未挂载”状态时手动挂载。<br></pre><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3>定义：使用 <strong>动态路径参数</strong> 把某种模式下匹配到的所有的路由，全部都映射到同一个组件。<h4 id="example-one"><a href="#example-one" class="headerlink" title="example one"></a>example one</h4><pre><br>const User = {<br>template: ‘<div>User</div>‘<br>}</pre></li></ol><p>const router = new VueRouter({<br>  routes: [<br>    // 动态路径参数 以冒号开头<br>    { path: ‘/user/:id’, component: User }<br>  ]<br>})<br></p><h4 id="example-two"><a href="#example-two" class="headerlink" title="example two"></a>example two</h4><p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用,例如我们可以在user模板中输出当前的用户id.同时可以在一个路由中设置多段【路由参数】，对应的值都会在￥route。params中。</p><pre>const User={   template: '<div>User </div>'}</pre><pre>const User = {  template: '<div>User +</div>'}const router = new VueRouter({  routes: [    // 动态路径参数 以冒号开头    { path: '/user/:id/post/:usename', component: User }  ]})</pre><h4 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h4><p>有时，同一个路径可以匹配对个路由，这时，匹配的优先级就会按照路由的定义顺序来：谁先定义的，谁的优先级就最高。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p><router-link> 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的a标签，可以通过配置 tag 属性生成别的标签。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</router-link></p><p><em>router-link比a链接好的原因在于：</em></p><ol><li>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动 关于history 模式、hash 模式讲解，点击<a href="http://blog.csdn.net/hyy1115/article/details/53021807" target="_blank" rel="external">这里</a></li><li>在h5 history模式下，router-link会拦截点击事件，让浏览器不在重新加载页面</li><li>在h5 history模式下使用base选项后，所有的to属性都不需要写基路径了。</li></ol><p>router-link的属性</p><h4 id="to属性"><a href="#to属性" class="headerlink" title="to属性"></a>to属性</h4><p>表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，这个值可以是一个字符串或者是描述目标位置的对象。<br><img src="http://i.imgur.com/s8Z3lij.png" alt=""></p><h4 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h4><p>如果设置了replace属性的话会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;/abc&apos;&#125;&quot; replace&gt; &lt;/router-link&gt;</div></pre></td></tr></table></figure><h4 id="append属性"><a href="#append属性" class="headerlink" title="append属性"></a>append属性</h4><p>设置 append 属性后，则在当前（相对）路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;relative/path&apos;&#125;&quot; append&gt;&lt;/router-link&gt;</div></pre></td></tr></table></figure></p><h4 id="tag属性"><a href="#tag属性" class="headerlink" title="tag属性"></a>tag属性</h4><p>有时候想要 <router-link> 渲染成某种标签，例如li于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;</div><div class="line">&lt;li&gt;foo&lt;/li&gt;</div></pre></td></tr></table></figure></router-link></p><h4 id="active-class属性"><a href="#active-class属性" class="headerlink" title="active-class属性"></a>active-class属性</h4><p>设置 链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。</p><h4 id="exact属性"><a href="#exact属性" class="headerlink" title="exact属性"></a>exact属性</h4><p>“是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 <router-link to="/a"> 也会被设置 CSS 类名。</router-link></p><h4 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h4><p>声明可以用来触发导航的事件，可以是一个字符串或者是一个包含字符串的数组</p><h4 id="激活时的CSS类名应用在外层元素"><a href="#激活时的CSS类名应用在外层元素" class="headerlink" title="激活时的CSS类名应用在外层元素"></a>激活时的CSS类名应用在外层元素</h4><p>有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 \<a> 标签本身，那么可以用 <router-link> 渲染外层元素，包裹着内层的原生 \<a> 标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt;</div><div class="line">  &lt;a&gt;/foo&lt;/a&gt;</div><div class="line">&lt;/router-link&gt;</div></pre></td></tr></table></figure></a></router-link></a></p><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p>router-view组件是用来渲染路径匹配到的视图组件的，router-view渲染的组件还可以内嵌到自己的router-view，根据嵌套路径，渲染嵌套组件。</p><p>包含的属性:name属性，string类，默认值为default<br>如果router-view设置了名称，则会渲染对应的路由配置中的components下的相应组件<br><img src="http://i.imgur.com/E5J3a4Y.png" alt=""></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>在模板中再嵌套router-view，在配置路由时必须使用children来配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const User = &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div class=&quot;user&quot;&gt;</div><div class="line">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</div><div class="line">      &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre>const routes: [    { path: '/user/:id', component: User,      children: [        {          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 <router-view> 中          path: 'profile',          component: UserProfile        },        {          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 <router-view> 中          path: 'posts',          component: UserPosts        }      ]    }  ]const router = new VueRouter({  routes})</router-view></router-view></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><h4 id="router-push-location"><a href="#router-push-location" class="headerlink" title="router.push(location)"></a>router.push(location)</h4><p>router.push(location)方法等同于<router-link :to="...">这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL</router-link></p><h4 id="router-replace-location"><a href="#router-replace-location" class="headerlink" title="router.replace(location)"></a>router.replace(location)</h4><p>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><pre>声明式：<router-link :to="..." replace="">编程式：router.replace(...)</router-link></pre>#### router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)<pre>// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)</pre><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><pre><router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link></pre>### 命名视图![](http://i.imgur.com/E5J3a4Y.png)### 重定向和别名『重定向』的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b通过routes的配置来完成。* 重定向到页面<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: '/b' }  ]})</pre>* 重定向到命名路由<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: { name: 'foo' }}  ]})</pre>* 可以是一个方法，动态的重定向到目标<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: to => {      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    }}  ]})</pre><p>『别名』的意思是：/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p><p>看到这的时候，公司网速出问题了，已经打不开外网了，正好基础的部分算是已经学习完了，那么后面的进阶就下次来写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触了点Vue后，自己屁颠屁颠去搜索一些实例的来看，结果各种出现Vue-router，尼玛这又是干嘛的？？？（黑人问号脸），于是去Vue-router的官方文档上瞅瞅，遂写了这篇笔记式的博文。&lt;/p&gt;
&lt;h3 id=&quot;vue-router是干嘛的？&quot;&gt;&lt;a href=&quot;#vue-router是干嘛的？&quot; class=&quot;headerlink&quot; title=&quot;vue-router是干嘛的？&quot;&gt;&lt;/a&gt;vue-router是干嘛的？&lt;/h3&gt;&lt;p&gt;Vue-router是Vue.js的官方路由插件，Vue的单页面应用是基于路由和组件的，路由用于设定访问的路径，并将路径和组件映射起来。之前我们写项目的时候，页面之前的切换时和跳转是通过超链接等来实现的，在Vue-router单页面应用中，则是通过路径的切换。&lt;br&gt;
    
    </summary>
    
      <category term="Vue-router" scheme="http://yaoyue.com/categories/Vue-router/"/>
    
    
      <category term="vue-router" scheme="http://yaoyue.com/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃(二)</title>
    <link href="http://yaoyue.com/2017/02/16/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83(%E4%BA%8C)/"/>
    <id>http://yaoyue.com/2017/02/16/vue入门到放弃(二)/</id>
    <published>2017-02-16T08:17:14.000Z</published>
    <updated>2017-02-17T09:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇记录的是Vue的环境搭建以及如何去运行它。此篇文章是回顾一下自己之前所学的Vue的指令，上次学了一些后，后面公司项目忙断了一段时间，现在都有点记得不是特别清楚了，所以趁着这次写博客，来把之前学习的指令回顾一遍。（所以说看的多不如实际操练几把，说多都是泪）</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="v-text-amp-amp-v-html"><a href="#v-text-amp-amp-v-html" class="headerlink" title="v-text &amp;&amp; v-html"></a>v-text &amp;&amp; v-html</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt;</div><div class="line">var app = new Vue(&#123;</div><div class="line">el: &apos;#app&apos;,   </div><div class="line">data: &#123;</div><div class="line">msg:&apos;&lt; h1 &gt; hi &lt; /h1 &gt;&apos;</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>v-text会把message中有html标签的部分都会显示出来，v-html则会把message中的信息根据html规则进行渲染。<br> <a id="more"></a></p><h4 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h4><ol><li>v-if v-else</li><li>v-show 元素始终渲染保存在DOM中，只是控制display属性。</li><li><p>v-else-if 类似于if，else if，else</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</div><div class="line">  A</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</div><div class="line">  B</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</div><div class="line">  C</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div v-else&gt;</div><div class="line">  Not A/B/C</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></li><li><p>key控制元素的可重用性：提供一种方式让你自己决定是否重用元素，key后必须带唯一的值，添加key属性的元素就不具有复用性了</p><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p>循环多次渲染元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div v-for=&quot;(val, key, index) in object&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></li></ol><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">绑定事件监听器</div><div class="line"> 方法处理器 </div><div class="line">&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line">内联语句 </div><div class="line">&lt;button v-on:click=&quot;doThat(&apos;hello&apos;, $event)&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line"> 缩写 </div><div class="line">&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line"> 停止冒泡</div><div class="line">&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line"> 阻止默认行为</div><div class="line">&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line">阻止默认行为，没有表达式</div><div class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</div><div class="line"></div><div class="line">串联修饰符</div><div class="line">&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line">键修饰符，键别名</div><div class="line">&lt;input @keyup.enter=&quot;onEnter&quot;&gt;</div><div class="line"></div><div class="line">键修饰符，键代码</div><div class="line">&lt;input @keyup.13=&quot;onEnter&quot;&gt;</div><div class="line">#### v-bind</div><div class="line">绑定一个属性</div><div class="line">&lt;img v-bind:src=&quot;imageSrc&quot;&gt;</div><div class="line"></div><div class="line">缩写</div><div class="line">&lt;img :src=&quot;imageSrc&quot;&gt;</div><div class="line">with inline string concatenation</div><div class="line">&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;</div><div class="line"></div><div class="line"> class 绑定 </div><div class="line">&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</div><div class="line"></div><div class="line">style 绑定 </div><div class="line">&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line"> 绑定一个有属性的对象</div><div class="line">&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">通过 prop 修饰符绑定 DOM 属性</div><div class="line">&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;</div><div class="line">prop 绑定. “prop” 必须在 my-component 中声明。</div><div class="line">&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;</div><div class="line"></div><div class="line">XLink </div><div class="line">&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</div></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>表单输入和应用状态中做数据的双向绑定，能够实时的改变数据。</p><ol><li>v-model.lazy 懒加载，只有失去焦点时数据才更新</li><li>v-model.number 把文本框中的数组转化为数字类型</li><li>v-model.trim 前后删除空格</li><li><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4></li><li>v-pre 跳过这个元素和其子元素的编译过程</li><li>v-cloak 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</li><li>v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过</li></ol><h3 id="vue的keyCode事件"><a href="#vue的keyCode事件" class="headerlink" title="vue的keyCode事件"></a>vue的keyCode事件</h3><p>Vue在监听键盘事件的时候，常需要检测keyCode，Vue允许为v-on添加键盘修饰符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</div><div class="line">缩写</div><div class="line">&lt;input @keyup.enter=&quot;submit&quot;</div></pre></td></tr></table></figure></p><p>按键别名：enter、tab、delete、ese、space、up、down、left、right</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol><li>Error when rendering root instance：污染了原生数据</li><li>Unexpected identifier 当前行或者是前一行少了逗号</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇记录的是Vue的环境搭建以及如何去运行它。此篇文章是回顾一下自己之前所学的Vue的指令，上次学了一些后，后面公司项目忙断了一段时间，现在都有点记得不是特别清楚了，所以趁着这次写博客，来把之前学习的指令回顾一遍。（所以说看的多不如实际操练几把，说多都是泪）&lt;/p&gt;
&lt;h3 id=&quot;常用指令&quot;&gt;&lt;a href=&quot;#常用指令&quot; class=&quot;headerlink&quot; title=&quot;常用指令&quot;&gt;&lt;/a&gt;常用指令&lt;/h3&gt;&lt;h4 id=&quot;v-text-amp-amp-v-html&quot;&gt;&lt;a href=&quot;#v-text-amp-amp-v-html&quot; class=&quot;headerlink&quot; title=&quot;v-text &amp;amp;&amp;amp; v-html&quot;&gt;&lt;/a&gt;v-text &amp;amp;&amp;amp; v-html&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;span v-text=&amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;span v-html=&amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var app = new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		el: &amp;apos;#app&amp;apos;,   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		data: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			msg:&amp;apos;&amp;lt; h1 &amp;gt; hi &amp;lt; /h1 &amp;gt;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;v-text会把message中有html标签的部分都会显示出来，v-html则会把message中的信息根据html规则进行渲染。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃(一)</title>
    <link href="http://yaoyue.com/2017/02/16/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-%E4%B8%80/"/>
    <id>http://yaoyue.com/2017/02/16/vue入门到放弃-一/</id>
    <published>2017-02-16T03:02:54.000Z</published>
    <updated>2017-02-21T09:53:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>   校招期间每看一次前端招聘的jd就是一次打击，几乎大多数的公司都会要求你会一个框架Vue或者react.js，因为最近Vue特别火，当然也不是说react.js不火，只是听说Vue对于新手更加的友好，遂入了Vue的坑。在网上搜索了一些教程，可是坑的是很多教程都是1.0版本的，但是Vue的1.0版和2.0版的区别还是比较大的，所以就想把自己的学习过程写下来，一方面是锻炼自己，另一方面也是希望更多像我这样的小白入坑比较容易。<br><a id="more"></a><br>环境搭建+sass安装+项目运行</p><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p><a href="https://nodejs.org/en/http://" target="_blank" rel="external">node官网</a>自行安装，安装好后运行node -v查看node版本，node版本最好是不要过低</p><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p><pre><br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org//全局按照淘宝镜像" target="_blank" rel="external">https://registry.npm.taobao.org//全局按照淘宝镜像</a><br></pre></p><h3 id="安装vue-cli脚手架构建工具"><a href="#安装vue-cli脚手架构建工具" class="headerlink" title="安装vue-cli脚手架构建工具"></a>安装vue-cli脚手架构建工具</h3><p><pre><br>cnpm install -g vue-cli//全局安装 Vue-cli，现在开始Vue就会是一个command<br></pre></p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><pre><br>vue init webpack firstVue //其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称<br></pre><br><img src="http://i.imgur.com/jzsWVIS.png" alt=""></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>进入你的项目文件夹，然后安装依赖,安装完成后你的firstVue文件夹中会多出一个叫node_modules的文件，这里边就是我们项目需要的依赖包资源。</p><p><pre><br>cd firstVue<br>cnpm install//安装依赖<br></pre></p><h3 id="sass安装"><a href="#sass安装" class="headerlink" title="sass安装"></a>sass安装</h3><p>安装sass依赖包</p><p><pre><br>npm install –save-dev sass-loader<br>//sass-loader依赖于node-sass<br>npm install –save-dev node-sass<br></pre><br>安装成功后你的package.json文件会相应的多出几项：<br><img src="http://i.imgur.com/Mhg4BSo.png" alt=""></p><p>在.Vue文件中使用sass时还必须修改style标签如下：</p><pre><code>&lt;style lang=&quot;sass&quot;&gt;//如果的sass的写法是使用大括号的语法这需要改成lang=&quot;scss&quot;</code></pre><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p><pre><br>npm run dev<br></pre><br>运行成功的话，浏览器会自动的打开localhost:8080页面，如果8080端口被占用的话，会提示错误。<br><img src="http://i.imgur.com/eUU0Fsp.png" alt=""></p><p>到这里就算是环境和项目运行成功了，入坑（一）成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   校招期间每看一次前端招聘的jd就是一次打击，几乎大多数的公司都会要求你会一个框架Vue或者react.js，因为最近Vue特别火，当然也不是说react.js不火，只是听说Vue对于新手更加的友好，遂入了Vue的坑。在网上搜索了一些教程，可是坑的是很多教程都是1.0版本的，但是Vue的1.0版和2.0版的区别还是比较大的，所以就想把自己的学习过程写下来，一方面是锻炼自己，另一方面也是希望更多像我这样的小白入坑比较容易。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>最常用的ES6特性</title>
    <link href="http://yaoyue.com/2017/01/28/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E7%89%B9%E6%80%A7/"/>
    <id>http://yaoyue.com/2017/01/28/最常用的ES6特性/</id>
    <published>2017-01-28T12:03:41.000Z</published>
    <updated>2017-02-17T09:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><ul><li>var：只有全局作用域和函数作用域，也就是说这样会导致函数里层的变量会覆盖函数外部的变量；</li><li>let：新增块级作用域，用let声明的变量，只有在let命令所在的代码块内有效；</li><li>const:声明常量，常量一旦声明值就不能改变<a id="more"></a><h3 id="class、extend和super"><a href="#class、extend和super" class="headerlink" title="class、extend和super"></a>class、extend和super</h3>constructor是构造方法，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是实例对象可以共享的。<br>class之间通过extends实现继承<br>super它代指父类的实例也即父类的this对象，子类必须在constructor方法中调用super方法，否则新建实例的时候会报错，因为子类是没有自己的实例对象的，而是继承父类的this对象，然后对其加工。<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3>箭头函数解决了this的指向问题，箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。</li></ul><h3 id="template-string"><a href="#template-string" class="headerlink" title="template string"></a>template string</h3><p>模板字符串（template string）是增强版的字符串，用反引号（<code>）标识。用反引号（</code>）来标识起始，用${}来引用变量，而且所有的空格和缩进都会被保留在输出之中</p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。</p><h3 id="default和rest"><a href="#default和rest" class="headerlink" title="default和rest"></a>default和rest</h3><p>default：默认值，es6允许为参数指定默认值，即当无参数的时候，函数采用默认的参数。<br>rest：（…）我们知道在strict mode下，对arguments做了很多限制，而且arguments是个arrayLike对象，不能像操作数组那样直接操作它。但用Rest操作符以后，args参数就是一个数组了，任何操作数组的方法都可以直接对args使用。<br>rest操作符只能放在函数形参的最后，即把剩余的都归集在一起。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;let和const&quot;&gt;&lt;a href=&quot;#let和const&quot; class=&quot;headerlink&quot; title=&quot;let和const&quot;&gt;&lt;/a&gt;let和const&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;var：只有全局作用域和函数作用域，也就是说这样会导致函数里层的变量会覆盖函数外部的变量；&lt;/li&gt;
&lt;li&gt;let：新增块级作用域，用let声明的变量，只有在let命令所在的代码块内有效；&lt;/li&gt;
&lt;li&gt;const:声明常量，常量一旦声明值就不能改变
    
    </summary>
    
      <category term="ES6" scheme="http://yaoyue.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yaoyue.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>canvas多图预加载</title>
    <link href="http://yaoyue.com/2017/01/13/canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/01/13/canvas学习笔记（一）/</id>
    <published>2017-01-13T06:22:37.000Z</published>
    <updated>2017-03-17T12:17:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间接触的项目大多数都涉及到canvas对于图片的操作包括多图的合成、图片从input上传后读取到canvas中、图片的裁剪等，所以觉得自己很有必要的学习一下canvas了。入坑碰到的第一个问题就canvas画图需要等到图片加载完成之后才能进行画图，否则canvas上是显示不出图片。所以首先来解决这个问题。<br> <a id="more"></a></p><h3 id="多图预加载问题"><a href="#多图预加载问题" class="headerlink" title="多图预加载问题"></a>多图预加载问题</h3><h4 id="利用jQuery的deferred对象"><a href="#利用jQuery的deferred对象" class="headerlink" title="利用jQuery的deferred对象"></a>利用jQuery的deferred对象</h4><p>首先介绍一下deferred的对象，他是jQuery1.5版本之后出来的新功能，是为了解决异步回调的问题的。每个deferred对象有三种状态：正在处理中，成功状态，失败状态。deferred对象被resolve/reject触发之后，就会改变其状态，相应的调用不同状态所对应的函数。<br>deferred对象的一些属性：</p><ol><li>$.Deferrd()生成一个deferred对象</li><li>deferred.done()返回成功时执行的回调函数</li><li>deferred.fail()返回失败时执行的回调函数</li><li>$.when().done().fail()多个操作完成后才执行的回调函数</li><li>deferred.promise()deferred对象是一个全局对象，在外部能够被改变，为防止被改变使用deferred.promise()它只开放done和fail方法 </li><li>deferred.resolve()手动改变deferred对象状态为fullfilled</li><li>deferred.rejected()手动改变deferred对象状态为fail</li><li>deferred.then(),then接受两个函数作为参数，是为了省事的时候吧done()和fail()写在一起</li><li><p>deferred.always()不管其状态是reject还是resolve最后都会执行的回调函数<br>deferred对象介绍到这里，我相信你也知道为什么它可以解决多图预加载的问题了。<br><pre><br>$(function(){<br> //初始化图片准备<br> var canvas = document.getElementById(‘mycanvas’);<br> var ctx = canvas.getContext(‘2d’);<br> ctx.fillStyle=”pink”;<br> ctx.fillRect(0,0,canvas.width,canvas.height);</pre></p><p> var imgsrc=[</p><pre><code>{    name:&apos;one&apos;,    src:&apos;http://inimg05.jiuyan.info/in/2016/04/01/2A28B347-7905-722E-8BA5-FF09BEEF8A21-1vQQvMG.jpg?imageMogr2/format/jpg/thumbnail/180x%3E/quality/80!&apos;,    x:0,    y:0,    w:80,    h:80},{    name:&apos;two&apos;,    src:&apos;http://inimg01.jiuyan.info/in/2016/12/29/9E79352A-D161-8C80-26D4-91DC3907BAEF-1GqxPbvq.jpg?imageMogr2/format/jpg/thumbnail/180x%3E/quality/80!&apos;,    x:90,    y:0,    w:80,    h:80,},{    name:&apos;three&apos;,    src:&apos;http://inimg01.jiuyan.info/in/2016/12/31/4803B98C-715E-3D30-D634-219ED81611AA-1gnRyEG.jpg?imageMogr2/format/jpg/thumbnail/180x%3E/quality/80!&apos;,    x:0,    y:90,    w:80,    h:80},</code></pre><p> ]</p><p> // 下载图片</p><pre><code>loadImage()function loadImage(){    var arrs = [];    $.each(imgsrc,function(idx,val){        var defer = $.Deferred();        var img = new Image();        if(/^http/.test(val.src)){img.crossOrigin = &apos;&apos;};        img.onload = function(){            defer.resolve(img)        }        img.src = val.src;        arrs.push(defer)    })    $.when.apply($, arrs).then(function(){        for(var i=0;i&lt;arguments.length;i++){            if(i==arguments.length-1){                imgsrc[i].img = arguments[i];                console.log(&quot;image&quot;,imgsrc )                combineImg(ctx, imgsrc);            }            imgsrc[i].img = arguments[i]        }    })}</code></pre><p> // 合成图片<br> function combineImg(ctx,option){</p><pre><code>$.each(imgsrc,function(idx,val){    ctx.drawImage(val.img,val.x,val.y,val.w,val.h);})</code></pre><p> }<br>})</p></li></ol><p></p><p>imgsrc数组存储的是你需要合成的图片的url，以及他的宽高，还有你将要把它画在canvas上的位置等信息。arrs数组是你用来把这些下载好的图片对象存起来的。<br>$.when.apply($,arrs).then(),这一句可能有一些人不明白，为什么需要用个apply方法呢？？<br>$.when()中需要接受的参数是promise对象，$.when.apply($, array)与$.when(array)是不一样的。$.when.apply($, array)与$.when(array[0], array[1],……）是相同的。而apply是用于调用带有参数数组的函数。它接受数组中的每个元素，并使用每个元素作为函数的参数。.apply也可以改变上下文（this函数内部）。现在的情况是你有一个promise数组; 你不知道你将传递多少参数给$.when。传递数组本身给$.when是行不通的，因为它需要它的参数是承诺，而不是一个数组。这就是.apply用进来的原因，apply接受数组，并调用每个promise给$.when素作为参数（并确保将this设置为jQuery/ $）。哎呀~解释半天也不知道讲清楚了木有~。等所有的操作完成再去执行combineImg()函数去画，这样就多图预加载完毕啦啦~~~。</p><h3 id="比较一下jq的deferred对象和ES6的promise对象"><a href="#比较一下jq的deferred对象和ES6的promise对象" class="headerlink" title="比较一下jq的deferred对象和ES6的promise对象"></a>比较一下jq的deferred对象和ES6的promise对象</h3><h4 id="jQuery的deferred对象"><a href="#jQuery的deferred对象" class="headerlink" title="jQuery的deferred对象"></a>jQuery的deferred对象</h4><ol><li>$.Deferrd()生成一个deferred对象</li><li>deferred.done()返回成功时执行的回调函数</li><li>deferred.fail()返回失败时执行的回调函数</li><li>$.when().done().fail()多个操作完成后才执行的回调函数</li><li>deferred.promise()deferred对象是一个全局对象，在外部能够被改变，为防止被改变使用deferred.promise()它只开放done和fail方法 </li><li>deferred.resolve()手动改变deferred对象状态为fullfilled</li><li>deferred.rejected()手动改变deferred对象状态为fail</li><li>deferred.then(),then接受两个函数作为参数，是为了省事的时候吧done()和fail()写在一起</li><li>deferred.always()不管其状态是reject还是resolve最后都会执行的回调函数</li></ol><h4 id="ES6的Promise"><a href="#ES6的Promise" class="headerlink" title="ES6的Promise"></a>ES6的Promise</h4><p>ES6的promise是一个构造函数，他的prototype属性中含有catch()\then()等方法，他自身含有all()\reject()\resolve\race()等方法</p><ol><li>catch()和写在then()方法中的第二个参数一样执行失败时候的回调函数，只是如果是在执行成功的回调函数失败了也会进入到catch()函数中</li><li>then()执行回调，同deferred对象的一样</li><li>race()谁执行的快就回调谁的函数，只是其他的的回调依然会被执行</li><li>all()全部执行完，会输出一个数组。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间接触的项目大多数都涉及到canvas对于图片的操作包括多图的合成、图片从input上传后读取到canvas中、图片的裁剪等，所以觉得自己很有必要的学习一下canvas了。入坑碰到的第一个问题就canvas画图需要等到图片加载完成之后才能进行画图，否则canvas上是显示不出图片。所以首先来解决这个问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="http://yaoyue.com/2016/12/16/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yaoyue.com/2016/12/16/es6学习笔记/</id>
    <published>2016-12-16T12:03:41.000Z</published>
    <updated>2017-02-14T03:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>感觉好久不学习新东西了，内心十分的惶恐~</p><h3 id="let用法"><a href="#let用法" class="headerlink" title="let用法"></a>let用法</h3><ul><li>所声明的变量只在let所在的代码块内有效</li><li>不存在变量的提升，只能先声明后使用（暂时性死性）</li><li>不允许在相同的作用域重复声明同一个变量（也即不能再函数内部重新声明参数）<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3></li><li>外层代码不受里层代码的影响，无法读取里层作用域的变量</li><li>内层作用域可以定义外层作用域的同名变量</li><li>作用域可以任意嵌套</li><li>可以在块级作用域中声明函数<a id="more"></a><pre>// ES6严格模式'use strict';if (true) {function f() {}}// 不报错</pre></li></ul><p>插一知识点，刚看到书里有提到，但是自己不是太懂特地去查了一下</p><p><strong>立执行函数：</strong><br>( function(){…} )()和( function (){…} () )是两种javascript立即执行函数的常见写法</p><ul><li>函数声明：function abc(){}</li><li>函数表达式：var aaa = function(){}</li><li>匿名函数：function(){}</li><li>只有函数表达式后面加括号才能立即调用函数</li><li>（function(){}）()能执行是因为在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码</li></ul><h3 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h3><p>作用：是的块级作用域可以变为表达式能够有返回值</p><pre>let x = do {let t = f();t*t+1;}</pre>     <h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ol><li>声明一个只读的常量，一旦声明常量的值就不能够改变了也就是说const声明的变量，一旦声明就应该立即的初始化不能够留到以后在进行赋值</li><li>与let一样，只在声明的块级作用域有效</li><li>存在暂时性死区，只能先声明后使用</li><li>不可重复声明</li><li>可对这个常量增加属性等但不可重新赋值覆盖</li></ol><p>对象冻结：Object.freeze({});</p><h3 id="顶层对象属性"><a href="#顶层对象属性" class="headerlink" title="顶层对象属性"></a>顶层对象属性</h3><p>var,function 声明的全局变量依然是顶层对象的属性<br>let，const，class声明的全局变量不再是顶层对象的属性</p><h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><p>定义：es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。</p><ul><li>解构赋值允许使用默认值</li><li>默认值生效的前提是判断那个位置是否有值且要严格的等于undefined即（===）</li><li>如果默认值是一个表达式的话，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</li><li>数组的解构是按照次序的排列来进行的，但是对象的解构是没有顺序的，所以变量名必须与属性名一样，才能取到正确的值。</li><li>如果变量名与属性名不一致，必须写成下面这样。<br><pre><br>var { foo: baz } = { foo: ‘aaa’, bar: ‘bbb’ };<br>baz // “aaa”</pre></li></ul><p>let obj = { first: ‘hello’, last: ‘world’ };<br>let { first: f, last: l } = obj;<br>f // ‘hello’<br>l // ‘world’<br></p><ul><li>将一个已经声明过的变量赋值解构时一定要注意，let和const不能够重复声明：let foo;({foo} = {foo: 1}); // 成功</li></ul><h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串会被转换成一个类似数组的对象进行解构赋值</p><pre>const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o"</pre>类似数组的对象都有一个length属性，因此还可以对这个属性进行解构赋值<pre>let {length : len} = 'hello';len // 5</pre><h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><ol><li>charAt()方法不能识别码点大于0XFFFF的字符串，提出字符串市里的at()方法，可以识别Unicode编号大于0xFFF的字符。</li><li>ES5提供了indexOf()方法可以用来确定字符串中是否包含某个字符，ES6提供了三种新的方法：includes()、startsWith()、endsWith();他们都返回布尔值</li><li>repeat(n)返回一个新字符串，表示将原字符串重复n次；如果n是小数则会被取整。</li><li><p>字符串补全长度功能：<br>padStart(5，’ab’)|padEnd(5,’ab’)</p><p> 1）第一个参数用来接收字符串的最小长度，第二个参数是用来补全的字符串</p><p> 2）如果用来补全的字符串和原字符串的长度超过了最小的长度，则会截去超出位数的补全字符串 </p><p> 3）如果省略第二个参数，则默认用空格补全长度</p></li><li><p>模板字符串：（<code>）模板字符串（template string）是增强版的字符串，用反引号（</code>）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><pre><br>// 普通字符串<br><code>In JavaScript &#39;\n&#39; is a line-feed.</code></pre></p></li></ol><p>// 多行字符串<br><code>In JavaScript this is not legal.</code></p><p>console.log(<code>string text line 1string text line 2</code>);</p><p>// 字符串中嵌入变量<br>var name = “Bob”, time = “today”;<br><code>Hello ${name}, how are you ${time}?</code><br></p><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><ol><li>可为函数的参数设定默认值，直接写在参数定义的后面</li><li>函数的参数指定了默认值后，函数的length属性将失真，返回的是没有指定默认值的参数的个数。</li><li>如果设置默认值的参数不是尾参数，那么length属性也不再计入后面的参数<pre>(function (a = 0, b, c) {}).length // 0(function (a, b = 1, c) {}).length // 1</pre></li><li><p>rest参数：用于获取函数的多余参数，这样就不用使用argument对象<br><pre><br>function add(…values) {<br>let sum = 0;</pre></p><p>for (var val of values) {<br> sum += val;<br>}</p><p>return sum;<br>}</p></li></ol><p>add(2, 5, 3) // 10<br></p><p>箭头函数：</p><ol><li>箭头函数不存在this，他们的this都是指向的最外层的函数的this。</li><li>arguments、super、new.target在箭头函数中也是不存在的，指向外层函数的对应变量。</li><li></li></ol><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><h4 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h4><p>一个模块就是一个独立的文件，文件内部的变量，外部无法获取，如果想要外部能够读取模块内的文件，就必须要使用export关键字输出该变量。</p><ul><li>输出变量<pre>var firstName = "jie";var laststName = "jie";export {firstName,lastname}</pre></li><li>输出函数<pre>export function multiply(x,y){  return x*y;}</pre></li><li>export default<br><pre><br>// 第一组<br>export default function crc32() { // 输出<br>// …<br>}</pre></li></ul><p>import crc32 from ‘crc32’; // 输入</p><p>// 第二组<br>export function crc32() { // 输出<br>  // …<br>};</p><p>import {crc32} from ‘crc32’; // 输入<br></p><h4 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h4><p>与export命令相对应，用于变量和函数等的输入，它不能使用变量表达式等</p><p><strong>import命令具有提升的作用，他会被提升到整个模块的头部首先进行执行，也就是说他可以被写在页面的底部，函数调用可以在他之前</strong></p><pre>import{firstName,lasteName} from './module/profile'</pre><ul><li>支持整体模块加载,用*表示<pre>import { area, circumference } from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14));//整体加载import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14));</pre></li></ul><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><ol><li>es6允许为函数的参数设置默认值直接写在参数定义的后面，参数变量是默认声明的所以在函数体中不能够用let和const再次的申明。</li><li>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</li></ol><h3 id="set数据结构"><a href="#set数据结构" class="headerlink" title="set数据结构"></a>set数据结构</h3><p>类似于数组，本身是一个构造函数，用于生成set数据结构，成员的值都是唯一的<br>可用于数组去重：</p><pre>function dedupe(array) {  return Array.from(new Set(array));//Array.from方法可以将Set结构转为数组}dedupe([1, 1, 2, 3]) // [1, 2, 3]</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉好久不学习新东西了，内心十分的惶恐~&lt;/p&gt;
&lt;h3 id=&quot;let用法&quot;&gt;&lt;a href=&quot;#let用法&quot; class=&quot;headerlink&quot; title=&quot;let用法&quot;&gt;&lt;/a&gt;let用法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;所声明的变量只在let所在的代码块内有效&lt;/li&gt;
&lt;li&gt;不存在变量的提升，只能先声明后使用（暂时性死性）&lt;/li&gt;
&lt;li&gt;不允许在相同的作用域重复声明同一个变量（也即不能再函数内部重新声明参数）&lt;h3 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;外层代码不受里层代码的影响，无法读取里层作用域的变量&lt;/li&gt;
&lt;li&gt;内层作用域可以定义外层作用域的同名变量&lt;/li&gt;
&lt;li&gt;作用域可以任意嵌套&lt;/li&gt;
&lt;li&gt;可以在块级作用域中声明函数
    
    </summary>
    
      <category term="ES6" scheme="http://yaoyue.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yaoyue.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>逻辑操作符</title>
    <link href="http://yaoyue.com/2016/12/05/%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yaoyue.com/2016/12/05/逻辑操作符/</id>
    <published>2016-12-05T03:04:20.000Z</published>
    <updated>2016-12-13T06:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>今日在看项目时遇见逻辑或“||”的相关代码，在自己的印象中我一直认为自己搞明白了，然而今天百度了一番后却发现记得一直是个错的。</p><pre>var a=2;var b=3;var and=a&&b;var or=a||b;</pre>之前一直以为and和or的值都为true，因为在脑海中一直认为 && 和 || 都是求Boolean，今天才发现自己错的离谱。 <a id="more"></a><pre>and = 3；or = 2;</pre>在运算过程中，首先js  会将 && 和||  两边的值转成Boolean 类型，然后再算值 ，&&运算如果返回true，则取后面的值，如果|| 返回true,则取前面的值 ， 而其中数值转换成boolean 的规则 是：**对象、非零整数、非空字符串**返回true,其它为false;<pre>a&&b => true&&true,结果返回true，所以取值取得是后面的值a||b => true||true,结果返回的是true，所以取值取得是前面的值。如 var a = “”  ||  null  || 3  ||  4   —->    var a = fasel || false || true ||  true  结果为true  则返回第一个true,即是3var b = 4 && 5 && null && 0   ——>   var b = true && true && false && false   结果是false   则返回第一个false   即是null .</pre><p>规则：</p><ol><li>&amp;&amp; 若返回的是true取值为后面的值，若返回的是false，则取的是第一个false的值。</li><li>|| 若返回的是true取得是第一个true的值，若返回的是false，则取得是后面的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今日在看项目时遇见逻辑或“||”的相关代码，在自己的印象中我一直认为自己搞明白了，然而今天百度了一番后却发现记得一直是个错的。&lt;/p&gt;
&lt;pre&gt;
var a=2;
var b=3;
var and=a&amp;&amp;b;
var or=a||b;
&lt;/pre&gt;
之前一直以为and和or的值都为true，因为在脑海中一直认为 &amp;&amp; 和 || 都是求Boolean，今天才发现自己错的离谱。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yaoyue.com/2016/11/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yaoyue.com/2016/11/28/正则表达式/</id>
    <published>2016-11-28T03:43:41.000Z</published>
    <updated>2016-12-13T06:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用的元字符"><a href="#常用的元字符" class="headerlink" title="常用的元字符"></a>常用的元字符</h3><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字符，数字或下划线</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或者结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table> <a id="more"></a><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或者更多次</td></tr><tr><td>+</td><td>重复一次或者更多次</td></tr><tr><td>？</td><td>重复零次或者一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或者更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><p>|：把不同的规则分隔开，匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了</p><p>正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</p><h3 id="反义符"><a href="#反义符" class="headerlink" title="反义符"></a>反义符</h3><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字符、数字或下划线的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符</td></tr><tr><td>\D</td><td>匹配任意不是数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词的开始或者结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td>(?<name>exp)</name></td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr><tr><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用的元字符&quot;&gt;&lt;a href=&quot;#常用的元字符&quot; class=&quot;headerlink&quot; title=&quot;常用的元字符&quot;&gt;&lt;/a&gt;常用的元字符&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除换行符以外的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配字符，数字或下划线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配任意的空白符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;匹配单词的开始或者结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配字符串的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配字符串的结束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yaoyue.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>数组方法汇总</title>
    <link href="http://yaoyue.com/2016/11/24/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://yaoyue.com/2016/11/24/数组方法汇总/</id>
    <published>2016-11-24T01:56:15.000Z</published>
    <updated>2016-12-13T06:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><p>从数组中添加/删除项目，然后返回被删除的项目,<strong>该方法会改变原始数组</strong>从1开始计算</p><pre>arrayObject.splice(添加|删除项位置,删除数量若为0则不删除,向数组添加的新项item1,.....,itemX)</pre><pre>var list = [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5]for(var i=0;i < list.length;++i){      list.splice(i,4,list.slice(i,i+4));}console.log(list)输出结果为：[[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4],[5,5,5,5]]</pre><a id="more"></a>## slice()从 start下标起 以end下标为结尾的一段元素（但不包括end下标的元素），然后返回新的数组，**对原数组没有任何是影响**<pre>arrayObject.slice(start,end)</pre>* start从0开始计算* start可以为负，代表从末尾选取* 若end没有指定则表示直到数组的末尾* slice（0）clone整个数组## concat()连接2个或者多个数组，返回新的数组，**不会改变现有的数组**<pre>var a = [1,2,3];document.write(a.concat(4,5));输出：1，2，3，4，5var arr1=[1,2,3];var arr2=[4,5]var arr3=[6,7]document.write(a.concat(arr2,arr3));输出：1，2，3，4，5,6,7</pre><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>把数组中的所有元素通过指定的分隔符进行分隔</p><p><pre><br>arrayObject.join(separator)<br></pre></p><ul><li>省略分隔符则默认使用逗号作为分隔符</li><li>arr.join(“&amp;”)</li></ul><h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><p>把字符串分割成字符串数组，与join（）方法执行的是相反的操作</p><p><pre><br>arrayObject.join(separator，howmany)<br>howmany:数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组</pre></p><p>var str=”How are you doing today?”</p><p>document.write(str.split(“ “) + “<br>“)<br>document.write(str.split(“”) + “<br>“)<br>document.write(str.split(“ “,3))</p><p>How,are,you,doing,today?<br>H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?<br>How,are,you<br></p><ul><li>如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>pop()：移除数组中的最后一个元素并返回该元素。arrayObj.pop()<br>push():将新元素添加到一个数组中，并返回数组的新长度值<br>shift():移除数组中的第一个元素并返回该元素。arrayObj.shift()<br>unshift():将指定的元素插入数组开始位置并返回该数组。<br>reverse():数组顺序反转</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;splice&quot;&gt;&lt;a href=&quot;#splice&quot; class=&quot;headerlink&quot; title=&quot;splice()&quot;&gt;&lt;/a&gt;splice()&lt;/h2&gt;&lt;p&gt;从数组中添加/删除项目，然后返回被删除的项目,&lt;strong&gt;该方法会改变原始数组&lt;/strong&gt;从1开始计算&lt;/p&gt;
&lt;pre&gt;
arrayObject.splice(添加|删除项位置,删除数量若为0则不删除,向数组添加的新项item1,.....,itemX)
&lt;/pre&gt;
&lt;pre&gt;
var list = [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5]
for(var i=0;i &lt; list.length;++i){ 
     list.splice(i,4,list.slice(i,i+4));
}
console.log(list)
输出结果为：[[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4],[5,5,5,5]]
&lt;/pre&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://yaoyue.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yaoyue.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>css3</title>
    <link href="http://yaoyue.com/2016/11/23/css3/"/>
    <id>http://yaoyue.com/2016/11/23/css3/</id>
    <published>2016-11-23T13:07:14.000Z</published>
    <updated>2016-12-13T06:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css3学习"><a href="#css3学习" class="headerlink" title="css3学习"></a>css3学习</h1><hr><h3 id="旋转动画容易漏掉的点"><a href="#旋转动画容易漏掉的点" class="headerlink" title="旋转动画容易漏掉的点"></a>旋转动画容易漏掉的点</h3><ol><li>steps()函数：animation默认以ease方式过渡，会以在每个关键帧之间插入补间动画，所以动画效果是连贯性的。ease，linear等之类的过渡函数都会为其插入补间。但有些效果不需要补间，只需要关键帧之间的跳跃，这时应该使用steps过渡方式。（例如：如果是只需要在两帧动画之间来回切换的话只需要设置steps（2）就可）steps()中设置的数字是每一步动画的跳跃步数而不是整个动画的跳跃步数。<a id="more"></a><a href="http://web.jobbole.com/83657/" target="_blank" rel="external">参考文章</a><pre>.ani-jie{      @include animation(jie steps(4) 2s alternate infinite); }@include keyframes(jie) { 0% ,50%,100%{ -webkit-transform: rotate(0deg); -webkit-transform-origin:20% 40%; transform: rotate(0deg);  transform-origin:center top;} 25% { -webkit-transform: rotate(6deg); -webkit-transform-origin:20% 40%; transform: rotate(4deg);  transform-origin:center top;   } 75% { -webkit-transform: rotate(-6deg); -webkit-transform-origin:20% 40%; transform: rotate(-10deg);  transform-origin:center top; }}</pre></li></ol><h3 id="animation属性"><a href="#animation属性" class="headerlink" title="animation属性"></a>animation属性</h3><table><thead><tr><th>animation</th><th>动画属性</th></tr></thead><tbody><tr><td>animation-name</td><td>规定 @keyframes 动画的名称。</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒</td></tr><tr><td>animation-timing-function</td><td>ease \ease-in\ease-in-out\linear\</td></tr><tr><td>animation-delay</td><td>规定动画何时开始，允许负值：-2s，负值表示动画立马开始，但是会跳过2秒进入动画周期</td></tr><tr><td>animation-iteration-count</td><td>播放次数 infinite\n</td></tr><tr><td>animation-direction</td><td>动画是否在下一个周期逆向播放normal\reverse反向\alternate奇数正\alternate-reverse奇数反</td></tr><tr><td>animation-play-state</td><td>指定动画是否正在运行或已暂停</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;css3学习&quot;&gt;&lt;a href=&quot;#css3学习&quot; class=&quot;headerlink&quot; title=&quot;css3学习&quot;&gt;&lt;/a&gt;css3学习&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;旋转动画容易漏掉的点&quot;&gt;&lt;a href=&quot;#旋转动画容易漏掉的点&quot; class=&quot;headerlink&quot; title=&quot;旋转动画容易漏掉的点&quot;&gt;&lt;/a&gt;旋转动画容易漏掉的点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;steps()函数：animation默认以ease方式过渡，会以在每个关键帧之间插入补间动画，所以动画效果是连贯性的。ease，linear等之类的过渡函数都会为其插入补间。但有些效果不需要补间，只需要关键帧之间的跳跃，这时应该使用steps过渡方式。（例如：如果是只需要在两帧动画之间来回切换的话只需要设置steps（2）就可）steps()中设置的数字是每一步动画的跳跃步数而不是整个动画的跳跃步数。
    
    </summary>
    
      <category term="CSS3" scheme="http://yaoyue.com/categories/CSS3/"/>
    
    
      <category term="css3" scheme="http://yaoyue.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>markdonw学习</title>
    <link href="http://yaoyue.com/2016/11/11/test/"/>
    <id>http://yaoyue.com/2016/11/11/test/</id>
    <published>2016-11-11T06:29:03.000Z</published>
    <updated>2016-12-13T06:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次学习markdown写法</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><blockquote><p>引用引用</p></blockquote><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><h3 id="22222"><a href="#22222" class="headerlink" title="22222"></a>22222</h3><ol><li>有序列表</li><li>有序列表</li><li>有序列表<a id="more"></a><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><a href="http://baidu.com" target="_blank" rel="external">百度</a></li></ol><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p><img src="http://www.cy580.com/file/upload/201307/29/14-03-21-44-88802.png" alt="百度"></p><h3 id="粗体斜体"><a href="#粗体斜体" class="headerlink" title="粗体斜体"></a>粗体斜体</h3><p><strong>粗体粗体</strong><br><em>斜体斜体</em></p><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>1)</p><p><pre><br>.cloud {<br>        width: rem(627);<br>        height: rem(770);<br>        background-image: url(“../images/cloud.png”);<br>        background-repeat: no-repeat;<br>        background-size: contain;<br>    }<br></pre><br>2)</p><p><code>nnnnnn</code></p><p>3)<br><code>nnnn</code></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次学习markdown写法&lt;/p&gt;
&lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;引用引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;22222&quot;&gt;&lt;a href=&quot;#22222&quot; class=&quot;headerlink&quot; title=&quot;22222&quot;&gt;&lt;/a&gt;22222&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;有序列表&lt;/li&gt;
&lt;li&gt;有序列表&lt;/li&gt;
&lt;li&gt;有序列表
    
    </summary>
    
      <category term="Markdown" scheme="http://yaoyue.com/categories/Markdown/"/>
    
    
      <category term="markdown" scheme="http://yaoyue.com/tags/markdown/"/>
    
  </entry>
  
</feed>
