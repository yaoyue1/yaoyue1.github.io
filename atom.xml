<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiemo blog</title>
  
  <subtitle>前端开发/学生/菜鸟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaoyue.com/"/>
  <updated>2017-11-16T06:43:59.000Z</updated>
  <id>http://yaoyue.com/</id>
  
  <author>
    <name>芥末</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rem适配</title>
    <link href="http://yaoyue.com/2017/11/16/rem%E9%80%82%E9%85%8D/"/>
    <id>http://yaoyue.com/2017/11/16/rem适配/</id>
    <published>2017-11-16T07:21:38.000Z</published>
    <updated>2017-11-16T06:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>   实在是惭愧，做h5这么久了，居然连适配的问题一直没有搞明白。在公司写项目的时候总是用的模板，一行命令就生成了，直接就上手用了，适配也是模板中直接弄好的。又由于之前的自己一直是做pc端的，h5基础很是不牢靠，忽略了好的基本的知识。直到今天才真正下决心要把这个rem适配给完全弄明白。</p><h3 id="为什么要是适配"><a href="#为什么要是适配" class="headerlink" title="为什么要是适配"></a>为什么要是适配</h3><p>  面对不同分辨率的手机不同屏幕尺寸的手机希望展示的一样比例的页面</p><h3 id="适配的原理"><a href="#适配的原理" class="headerlink" title="适配的原理"></a>适配的原理</h3><h4 id="相关尺寸和名词介绍"><a href="#相关尺寸和名词介绍" class="headerlink" title="相关尺寸和名词介绍"></a>相关尺寸和名词介绍</h4><p>目前我们选取的一款手机屏幕宽高基准为iphone6的375 x 667。<br>物理像素：物理像素是显示屏上最小的物理显示单元<br>设备独立像素：计算机系统中的一个点，可以由程序使用的最小单元，也可称为css像素<br>位图像素：图片最小的数据单元，1个位图像素对应于1个物理像素时，图片才会清晰的展现<br>设备像素比：<br>    设备像素比 = 物理像素／设备独立像素  //在某一方向上的<br>js：window.devicePixelRatio获取到当前设备的dpr<br>css：-webkit-device-pixel-ratio<br>dpr=1时，1个css像素相当于1个物理像素，比例为1:1<br>retina屏幕（dpr=2），1个物理像素相当于2个物理像素 比例为1:4<br>设备的宽高375*667可以理解为设备独立像素也就是css像素，<br><a id="more"></a><br>从以上知识可知，如果我们的设计稿是375 x 667的话，普通屏幕下，1个位图像素对应于1个物理像素，图片是可以清晰的展现的，但是在retina屏幕下由于物理像素变多，位图像素比较少，比例为1:4，所以就会出现图片模糊，解决方法就是使用2倍图片（@2x）然后再将容器缩小一半，这也就是为什么我们现在的设计稿都是 750x1334的（除去导航栏的高度一般我们用的是750x1206）这样下来retina屏幕上位图像素和物理像素的比例就为1:1了，但是这个时候普通屏幕上就会出现一个问题，位图像素为4，物理像素为1，取色就只能通过一定的算法（显示结果就是像素总数只能为原来的四分之一），图片不会模糊但是会缺少锐利度或者有色差，但是这样还算能够接受<br>上述做法还会引申出另外一个问题就是border：1px的问题<br>我们在css中写下border为1px的属性时，在普通屏幕和retina屏幕下其实高度是一样的，但不同的是普通屏幕下border为1px，物理像素为1行，但是retina屏幕下就会是显示无力像素2行，这样设计师其实是希望retina屏幕下只显示1行的，也就是0.5px，但是很多浏览器并不能识别0.5px会被当作0px，所以我们的解决方案就是dpr为2的时候，添加如下的meta标签，把viewport设置为scale为0.5，这样border：1px就达到了border：0.5px的效果，但是又有一个问题，就是viewport缩小为0.5，相应的字体也会被缩小，页面布局也会被缩放。<br>          <meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"><br>所以接下来我们就需要来谈适配了</p><h4 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h4><h5 id="em"><a href="#em" class="headerlink" title="em"></a>em</h5><p>em是一个相对单位，它不是一个固定的值，是相对于父元素的大小，同时它作为line-height的高度时是相对于自身的字体大小的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;p1&quot;&gt;</div><div class="line">   &lt;div class=&quot;s1&quot;&gt;1&lt;div&gt;</div><div class="line">   &lt;div class=&quot;s2&quot;&gt;1&lt;div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;div class=&quot;p2&quot;&gt;</div><div class="line">   &lt;div class=&quot;s3&quot;&gt;1&lt;div&gt;</div><div class="line">   &lt;div class=&quot;s4&quot;&gt;1&lt;div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">.p1 &#123;font-size: 16px; line-height: 32px;&#125;</div><div class="line">.s1 &#123;font-size: 2em;&#125;</div><div class="line">.s2 &#123;font-size: 2em; line-height: 2em;&#125;</div><div class="line"></div><div class="line">.p2 &#123;font-size: 16px; line-height: 2;&#125;</div><div class="line">.s5 &#123;font-size: 2em;&#125;</div><div class="line">.s6 &#123;font-size: 2em; line-height: 2em;&#125;</div><div class="line">这样一道题，你能算出s1，s2，s3，s4的字体行高的px值，那么你就应该是弄懂了em了</div><div class="line">答案：</div><div class="line">p1：font-size: 16px; line-height: 32px</div><div class="line">s1：font-size: 32px; line-height: 32px</div><div class="line">s2：font-size: 32px; line-height: 64px</div><div class="line">p1 无需解释</div><div class="line">s1 em作为字体单位，相对于父元素字体大小；line-height继承父元素计算值</div><div class="line">s2 em作为行高单位时，相对于自身字体大小</div><div class="line"></div><div class="line">p2：font-size: 16px; line-height: 32px</div><div class="line">s3：font-size: 32px; line-height: 64px</div><div class="line">s4：font-size: 32px; line-height: 64px</div><div class="line">p2 line-height: 2自身字体大小的两倍</div><div class="line">s3 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍</div><div class="line">s4  无需解释</div></pre></td></tr></table></figure></p><h5 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h5><p>rem指的是根字体的大小，其他元素可以从px转换为rem就是除以根字体的大小，这个也是适配的最重要的一点了<br>rem = px／根字体大小（基准值）</p><h5 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h5><p>适配的原理其实也就是等比缩放，你想要想跟着屏幕的大小等比的缩放页面，如果能有个x=屏幕大小／100的单位是不是很好，这样元素以x做单位就会跟着屏幕的大小变了，虽然我们没有这样的x单位但是我们有类似的rem。一般浏览器的根字体大小为16px，我们想要根字体的大小跟随着屏幕改变，那么就需要根据屏幕的大小来动态的改变根字体的大小，所以我们是这样设置的：<br>        rem = document.documentElement.clientWidth <em> dpr / 10<br>这里乘dpr是因为dpr为2的时候，我们缩放了页面的，除以10是为了方便计算，所以通过这样一个等式，屏幕大小开始和根字体相关联了，接下来我们只需要把页面中每个元素的宽高由设计稿上的px值转化为rem的值，这样我们就可以实现根据屏幕的大小来动态的缩放页面中的各个元素了。如何转化呢？也就是我提到的公式：rem = px／根字体大小（基准值），px除以根字体的大小。我们现在一般是取iPhone6的大小来作为我们的写页面的基准，iphone6的手机宽高为375</em>667，dpr为2，所以这样我们计算出来的基准值就是： 375 * 2 ／ 10 = 75，我们常用的做法就是用sass写个函数来把px转化为rem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$em-base:75.000px;</div><div class="line">@function px($px) &#123;</div><div class="line">   @return ($px / $em-base) * 1rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)， 只需要把字体乘相应的dpr就可以，这样缩放后字体都保持一样大小，一般会写如下函数做如下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@mixin dpr($cls, $fs) &#123;</div><div class="line">    #&#123;$cls&#125; &#123;</div><div class="line">            font-size: $fs*1px;</div><div class="line">    &#125;</div><div class="line">    @for $index from 1 through length($cls) &#123;</div><div class="line">      $value: nth($cls, $index);</div><div class="line">        [data-dpr=&quot;2&quot;] #&#123;$value&#125; &#123;</div><div class="line">            font-size: $fs * 2px;</div><div class="line">        &#125;</div><div class="line">        [data-dpr=&quot;3&quot;] #&#123;$value&#125; &#123;</div><div class="line">            font-size: $fs * 3px;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[data-dpr=&quot;2&quot;] .hint-box &#123;  </div><div class="line">    padding: 16px !important;</div><div class="line">    font-size: 28px !important;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[data-dpr=&quot;3&quot;] .hint-box &#123;</div><div class="line">    padding: 24px !important;</div><div class="line">    font-size: 42px !important;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在写vue的时候我是使用的npm的postcss-px2rem包来实现rem移动端适配的，使用这个可以直接在style中写px，就跟我们做pc端项目是一样的。页面计算宽度，插入页面的计算屏幕宽度的一段js代码，我从我们项目中copy过来的,是压缩过的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!function(a,b)&#123;function c()&#123;var b=f.getBoundingClientRect().width;b/i&gt;540&amp;&amp;(b=540*i);var c=b/10;f.style.fontSize=c+&quot;px&quot;,k.rem=a.rem=c&#125;var d,e=a.document,f=e.documentElement,g=e.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;),h=e.querySelector(&apos;meta[name=&quot;flexible&quot;]&apos;),i=0,j=0,k=b.flexible||(b.flexible=&#123;&#125;);if(g)&#123;console.warn(&quot;将根据已有的meta标签来设置缩放比例&quot;);var l=g.getAttribute(&quot;content&quot;).match(/initial\-scale=([\d\.]+)/);l&amp;&amp;(j=parseFloat(l[1]),i=parseInt(1/j))&#125;else if(h)&#123;var m=h.getAttribute(&quot;content&quot;);if(m)&#123;var n=m.match(/initial\-dpr=([\d\.]+)/),o=m.match(/maximum\-dpr=([\d\.]+)/);n&amp;&amp;(i=parseFloat(n[1]),j=parseFloat((1/i).toFixed(2))),o&amp;&amp;(i=parseFloat(o[1]),j=parseFloat((1/i).toFixed(2)))&#125;&#125;if(!i&amp;&amp;!j)&#123;var p=a.navigator.userAgent,q=(!!p.match(/android/gi),!!p.match(/iphone/gi)),r=q&amp;&amp;!!p.match(/OS 9_3/),s=a.devicePixelRatio;i=q&amp;&amp;!r?s&gt;=3&amp;&amp;(!i||i&gt;=3)?3:s&gt;=2&amp;&amp;(!i||i&gt;=2)?2:1:1,j=1/i&#125;if(f.setAttribute(&quot;data-dpr&quot;,i),!g)if(g=e.createElement(&quot;meta&quot;),g.setAttribute(&quot;name&quot;,&quot;viewport&quot;),g.setAttribute(&quot;content&quot;,&quot;initial-scale=&quot;+j+&quot;, maximum-scale=&quot;+j+&quot;, minimum-scale=&quot;+j+&quot;, user-scalable=no&quot;),f.firstElementChild)f.firstElementChild.appendChild(g);else&#123;var t=e.createElement(&quot;div&quot;);t.appendChild(g),e.write(t.innerHTML)&#125;a.addEventListener(&quot;resize&quot;,function()&#123;clearTimeout(d),d=setTimeout(c,300)&#125;,!1),a.addEventListener(&quot;pageshow&quot;,function(a)&#123;a.persisted&amp;&amp;(clearTimeout(d),d=setTimeout(c,300))&#125;,!1),&quot;complete&quot;===e.readyState?e.body.style.fontSize=12*i+&quot;px&quot;:e.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;e.body.style.fontSize=12*i+&quot;px&quot;&#125;,!1),c(),k.dpr=a.dpr=i,k.refreshRem=c,k.rem2px=function(a)&#123;var b=parseFloat(a)*this.rem;return&quot;string&quot;==typeof a&amp;&amp;a.match(/rem$/)&amp;&amp;(b+=&quot;px&quot;),b&#125;,k.px2rem=function(a)&#123;var b=parseFloat(a)/this.rem;return&quot;string&quot;==typeof a&amp;&amp;a.match(/px$/)&amp;&amp;(b+=&quot;rem&quot;),b&#125;&#125;(window,window.lib||(window.lib=&#123;&#125;));</div></pre></td></tr></table></figure></p><p>至此rem适配，我也总算是懂一丢丢了，不知道写的对不对，请指教～～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   实在是惭愧，做h5这么久了，居然连适配的问题一直没有搞明白。在公司写项目的时候总是用的模板，一行命令就生成了，直接就上手用了，适配也是模板中直接弄好的。又由于之前的自己一直是做pc端的，h5基础很是不牢靠，忽略了好的基本的知识。直到今天才真正下决心要把这个rem适配给完全弄明白。&lt;/p&gt;
&lt;h3 id=&quot;为什么要是适配&quot;&gt;&lt;a href=&quot;#为什么要是适配&quot; class=&quot;headerlink&quot; title=&quot;为什么要是适配&quot;&gt;&lt;/a&gt;为什么要是适配&lt;/h3&gt;&lt;p&gt;  面对不同分辨率的手机不同屏幕尺寸的手机希望展示的一样比例的页面&lt;/p&gt;
&lt;h3 id=&quot;适配的原理&quot;&gt;&lt;a href=&quot;#适配的原理&quot; class=&quot;headerlink&quot; title=&quot;适配的原理&quot;&gt;&lt;/a&gt;适配的原理&lt;/h3&gt;&lt;h4 id=&quot;相关尺寸和名词介绍&quot;&gt;&lt;a href=&quot;#相关尺寸和名词介绍&quot; class=&quot;headerlink&quot; title=&quot;相关尺寸和名词介绍&quot;&gt;&lt;/a&gt;相关尺寸和名词介绍&lt;/h4&gt;&lt;p&gt;目前我们选取的一款手机屏幕宽高基准为iphone6的375 x 667。&lt;br&gt;物理像素：物理像素是显示屏上最小的物理显示单元&lt;br&gt;设备独立像素：计算机系统中的一个点，可以由程序使用的最小单元，也可称为css像素&lt;br&gt;位图像素：图片最小的数据单元，1个位图像素对应于1个物理像素时，图片才会清晰的展现&lt;br&gt;设备像素比：&lt;br&gt;    设备像素比 = 物理像素／设备独立像素  //在某一方向上的&lt;br&gt;js：window.devicePixelRatio获取到当前设备的dpr&lt;br&gt;css：-webkit-device-pixel-ratio&lt;br&gt;dpr=1时，1个css像素相当于1个物理像素，比例为1:1&lt;br&gt;retina屏幕（dpr=2），1个物理像素相当于2个物理像素 比例为1:4&lt;br&gt;设备的宽高375*667可以理解为设备独立像素也就是css像素，&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://yaoyue.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yaoyue.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>画画画世界</title>
    <link href="http://yaoyue.com/2017/11/15/%E7%94%BB%E7%94%BB%E7%94%BB%E4%B8%96%E7%95%8C/"/>
    <id>http://yaoyue.com/2017/11/15/画画画世界/</id>
    <published>2017-11-15T05:00:43.000Z</published>
    <updated>2017-11-16T07:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;小学时就对画画比较感兴趣，喜欢涂涂画画，到现在还保存着以前的作品，偶尔拿出来看看，这种感觉很奇妙，后面随着学业的繁忙，也就从来没有拿起笔画过了，大学时代也没有，直到最近，偶然在微博上看见别人画彩铅，觉得真棒，萌生出了一种自己想画画的想法，于是立马就淘宝买了各种工具开始了画画。我想我大学时从没想过要画画的原因极大可能是那时候好玩的东西太多，每天跟各种朋友厮混，也就从来没有空闲来想着这事，不过现在不一样了，现在一个人生活在一个城市，又是住的单间，很多时候都是自己一个人，人一旦空闲起来就会想着怎样去打发时间，所以这也算是自己为什么要重新画画，尤其是最近都在看动漫，很想把这些喜欢的人物给画下来，另外一个影响我画画的原因就是我很喜欢张馨予。画画是一个人的修行<br><a id="more"></a><br><img src="http://chuantu.biz/t6/142/1510815261x2728306563.jpg" alt="乔巴"><br><img src="http://chuantu.biz/t6/142/1510815431x2728306563.jpg" alt="温蒂"><br><img src="http://chuantu.biz/t6/142/1510815512x2728306563.jpg" alt="花花"><br>矫情一句，爱生活爱自己，哈哈～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;小学时就对画画比较感兴趣，喜欢涂涂画画，到现在还保存着以前的作品，偶尔拿出来看看，这种感觉很奇妙，后面随着学业的繁忙，也就从来没有拿起笔画过了，大学时代也没有，直到最近，偶然在微博上看见别人画彩铅，觉得真棒，萌生出了一种自己想画画的想法，于是立马就淘宝买了各种工具开始了画画。我想我大学时从没想过要画画的原因极大可能是那时候好玩的东西太多，每天跟各种朋友厮混，也就从来没有空闲来想着这事，不过现在不一样了，现在一个人生活在一个城市，又是住的单间，很多时候都是自己一个人，人一旦空闲起来就会想着怎样去打发时间，所以这也算是自己为什么要重新画画，尤其是最近都在看动漫，很想把这些喜欢的人物给画下来，另外一个影响我画画的原因就是我很喜欢张馨予。画画是一个人的修行&lt;br&gt;
    
    </summary>
    
      <category term="芥末的绘画生活" scheme="http://yaoyue.com/categories/%E8%8A%A5%E6%9C%AB%E7%9A%84%E7%BB%98%E7%94%BB%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="芥末的绘画生活" scheme="http://yaoyue.com/tags/%E8%8A%A5%E6%9C%AB%E7%9A%84%E7%BB%98%E7%94%BB%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>图解http学习笔记</title>
    <link href="http://yaoyue.com/2017/10/31/%E5%9B%BE%E8%A7%A3http%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yaoyue.com/2017/10/31/图解http学习笔记/</id>
    <published>2017-10-31T14:37:12.000Z</published>
    <updated>2017-11-16T06:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>由于对http知识知道的甚少，最近做项目，调试接口的时候老是喜欢出问题，也因此浪费了很多的时间，所有打算恶补一下关于http协议这方面的知识。《图解http》这本书其实买了好久了，但是自己一直都没有去看，立个flag，最近要把它看完。</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h4><p>应用层 =&gt;传输层 =&gt;网络层 =&gt; 数据链路层<br>分层的好处：</p><ul><li>某个地方需要修改只用替换需要变动的层</li><li>处理应用层上的应用只需要考虑分派给自己的任务不需要考虑其他<br>应用层：决定向用户提供应用服务时通信的服务<br>传输层：对上层应用层提供处于网络连接中的两台计算机之间的数据传输<br>网络层：处理在网络上流动的数据包<br>链路层：用来处理连接网路的硬件部分<a id="more"></a><h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4></li><li>ip网际协议位于网络层，ip协议的作用：把各种数据包传送给对方（满足条件：IP地址，指名节点被分配的地址，mac地址，指网卡所属的固定地址，ip地址可以和mac地址进行配对）</li><li>使用ARP协议凭借MAC地址进行通信（arp协议：用以解析地址的协议，根据通信方的ip地址就可以查出对应的mac地址）</li></ul><h4 id="tcp协议"><a href="#tcp协议" class="headerlink" title="tcp协议"></a>tcp协议</h4><ul><li>tcp协议位于传输层，提供可靠的字节流服务</li><li>为了能过更容易的传输大数据，tcp协议把数据进行分割成以报文段为单位的数据包进行管理</li><li>为了准确将数据送达，tcp协议采用了三次握手策略<br>发送端首先发送一个带SYN标志的数据包给对方，接收方收到后回传一个带SYN/ACK的数据包表示传达确认信息，最后，发送端再回传一个带ACK的数据包表示握手结束</li><li>握手过程中任意某个阶段中断，tcp协议会再次以相同的顺序发送数据包</li></ul><h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><ul><li>位于应用层，提供域名到ip地址之间的解析服务</li></ul><h4 id="uri（统一资源标识符）"><a href="#uri（统一资源标识符）" class="headerlink" title="uri（统一资源标识符）"></a>uri（统一资源标识符）</h4><p>由某个协议方案表示的资源的定位标识符，url表示资源的地点，url是uri的子集</p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ol><li>请求是先从客户端开始建立的，服务端在没有接收到请求之前是不会发送响应的</li><li>http是无状态协议，不会对请求和响应之间的通信状态进行保存。</li><li>告知服务器意图的http方法<ul><li>get：请求访问已被uri识别的资源</li><li>post：传输实体的主体</li><li>put：传输文件</li><li>head：获取报文首部，用于确认uri的有效性及资源更新的日期时间等</li><li>delete：删除文件</li><li>options：询问支持的方法</li><li>trace：追踪路径</li></ul><ol><li>持久连接，只要任意一端没有明确的提出断开连接，则保持tcp连接的状态</li></ol><ul><li>减少tcp连接的重复建立和断开造成的额外开销，减轻服务器端的负载</li><li>减少开销的时间，web页面的显示速度相应提高</li></ul><ol><li>管线化，同时并行发送多个请求，不需要一个接一个的等待响应</li><li>使用cookie的状态管理<br>由于http是无状态协议，它不会对之前发生过的请求和响应的状态进行管理。也就是无法更具之前的状态进行接下来的请求处理，cookie技术通过在请求和响应的报文中写入cookie信息来控制客户端的状态（Set-Cookie报文）<br>没有cookie状态下请求：客户端=&gt;请求=&gt;服务器生成cookie=&gt;在响应中添加cookie后返回响应 =&gt; 客户端保存cookie<br>存有cookie状态下的请求：客户端=&gt;请求中添加cookie后放送请求 =&gt;服务器检查cookie =&gt; 返回响应</li></ol></li></ol><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h4 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h4><p>好像也没讲啥</p><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>状态码以3位数字和原因短语组成，数字第一位指定响应的类别，后两位无分类<br>1XX =&gt; 接受的请求正在处理 （信息性状态码）<br>2xx =&gt; 请求正常处理完成 （成功状态码）<br>3xx =&gt; 需要进行附加操作以完成请求 （重定向状态码）<br>4xx =&gt; 服务器无法处理请求（客户端错误状态码）<br>5xx =&gt; 服务器处理请求出错（服务器错误状态码）</p><p>常用状态码：<br>200 – ok<br>204 – no content 请求处理成功但是没有资源可以返回<br>206 – partial content 对资源某一部分请求<br>301 – moved permanently 永久重定向<br>302 – found 临时重定向<br>304 – not modified 客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件<br>400 – bad request！请求报文中存在语法错误<br>403 – forbidden 请求访问的资源被服务器拒绝<br>404 – not found 服务器上没有请求的资源<br>500 – internal server error 服务器端在执行请求时发生了错误<br>503 – service unavailable 服务器暂时处于超负载或者正在进行停机维护</p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="单台虚拟主机实现多个域名"><a href="#单台虚拟主机实现多个域名" class="headerlink" title="单台虚拟主机实现多个域名"></a>单台虚拟主机实现多个域名</h4><p>即使物理层面只有一台服务器，但是只要使用虚拟主机的功能，可以假想成已具有多台服务器</p><h4 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h4><ol><li>代理</li></ol><ul><li>接受由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端，代理不会改变请求的uri</li><li>每次通过代理服务器转发请求或者响应时，会追加写入via首部信息以标出经过的主机信息<br>为什么要使用代理服务器？</li><li>利用缓存技术减少网络带宽的流量（缓存代理会预先将资源的副本缓存保存在代理服务器，当接受到相同请求的时候就不从源服务器那里获取资源，而是将之前的缓存资源作为响应返回）</li><li>组织内部针对特定网站的访问控制</li></ul><ol><li>网关<br>转发其他服务器通信数据的服务器</li></ol><p>缓存服务器，客户端都会缓存，同时这个缓存是有时间限制的，会像源服务器从新确认资源的有效性</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h4 id="4种http首部字段类型"><a href="#4种http首部字段类型" class="headerlink" title="4种http首部字段类型"></a>4种http首部字段类型</h4><ol><li>通用首部字段（geeral header fields）<br>请求报文和响应报文两方都会使用的首部</li><li>请求首部字段（request header fields）<br>从客户端向服务器端发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</li><li>响应首部字段（response header fields）<br>从服务器端向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息</li><li>实体首部字段（entity header fields）<br>针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等和实体有关的信息</li></ol><h3 id="第七章-确保web安全的https"><a href="#第七章-确保web安全的https" class="headerlink" title="第七章 确保web安全的https"></a>第七章 确保web安全的https</h3><p>http不足之处：</p><ul><li>通信使用明文，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改<br>通信加密：http协议</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于对http知识知道的甚少，最近做项目，调试接口的时候老是喜欢出问题，也因此浪费了很多的时间，所有打算恶补一下关于http协议这方面的知识。《图解http》这本书其实买了好久了，但是自己一直都没有去看，立个flag，最近要把它看完。&lt;/p&gt;
&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;h4 id=&quot;TCP-IP的分层管理&quot;&gt;&lt;a href=&quot;#TCP-IP的分层管理&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP的分层管理&quot;&gt;&lt;/a&gt;TCP/IP的分层管理&lt;/h4&gt;&lt;p&gt;应用层 =&amp;gt;传输层 =&amp;gt;网络层 =&amp;gt; 数据链路层&lt;br&gt;分层的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个地方需要修改只用替换需要变动的层&lt;/li&gt;
&lt;li&gt;处理应用层上的应用只需要考虑分派给自己的任务不需要考虑其他&lt;br&gt;应用层：决定向用户提供应用服务时通信的服务&lt;br&gt;传输层：对上层应用层提供处于网络连接中的两台计算机之间的数据传输&lt;br&gt;网络层：处理在网络上流动的数据包&lt;br&gt;链路层：用来处理连接网路的硬件部分
    
    </summary>
    
      <category term="http" scheme="http://yaoyue.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yaoyue.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>怂过了丧过了就好好努力活～</title>
    <link href="http://yaoyue.com/2017/10/27/%E6%80%82%E8%BF%87%E4%BA%86%E4%B8%A7%E8%BF%87%E4%BA%86%E5%B0%B1%E5%A5%BD%E5%A5%BD%E5%8A%AA%E5%8A%9B%E6%B4%BB%EF%BD%9E/"/>
    <id>http://yaoyue.com/2017/10/27/怂过了丧过了就好好努力活～/</id>
    <published>2017-10-27T06:17:47.000Z</published>
    <updated>2017-10-27T06:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28283305&auto=1&height=66"></iframe><br>&emsp;&emsp;不知道什么时候开始活的小心翼翼，一个人在一座城市的人可能大都和我一样吧，习惯于把自己最好的展现出来，把沮丧落寞这些负面的情绪埋在自己内心，不敢轻易对人说起。其实也是无从说起，或者说根本就没有倾诉的对象，对父母讲，太多的负面情绪可能更会引起他们的担心，对姐姐讲，但是她没有经历我所经历的，很多时候也无法明白我的内心，对闺蜜讲，我又觉得把负能量传递别人是一种不好的行为，我也不希望我是这种人。所以很多的时候，当我有想倾诉的那种想法时我都会把它压制下来，现在更习惯于用键盘把它敲出来，慢慢的写，慢慢的敲，也算讲给自己听吧。有时想想觉得很好笑，初中高中的时候被老师逼迫天天写日记都没有养成一个写日记的习惯，反倒是在离开学校后，主动的想去把内心的一些东西写出来了。<br><a id="more"></a><br>&emsp;&emsp;最近发生在身上最大的两件事一个是搬家，一个是最近接的项目。搬家总算也是尘埃落定了，回头想想的时候好像也没觉得有什么不容易的。连续三天看房，买打包袋打包到凌晨，联系搬家公司，搬进新住处，开始一件件的整理到傍晚，最好还在傍晚的时候和闺蜜出去吃了川炉的火锅。一切都很顺其自然，井井有条，其实也没有很艰难嘛～但是内心最不舍的算是原来小区的环境，到处的桂花香味，过条马路就到的浙大。深夜再晚夜跑也能随处可见的保安，只是就像你喜欢的人不喜欢你一样，单方面的情愿是没有用的。索性搬进来的地方，房间我很喜欢，有我最爱的吧台桌。虽然经常加班到深夜，它看起来也没有什么用处。<br>&emsp;&emsp;再说说另外一件事情，就是最近手上的项目。比较复杂，算是我来公司接的最复杂的一个项目了吧，刚开始没有想清楚逻辑结构就开始写了页面了，导致后面写逻辑的时候无从下手，有只得重新整理页面结构，后面的逻辑也费了很大的功夫。后台对接既需要和php对接也需要和java对接，调接口的时候我又不是很熟悉，所以浪费了很多的时间，很感激点滴，这么帮我，有时候写的真的想哭，周末加班，连续一周每天加班到11点，所以以后一定要努力一点好不好，这样没错遇到问题就不需要寻求他人的帮助了，也不会坑到别人了，我真的不是一个很喜欢麻烦别人的人，也很怕麻烦别人，所以也是一个别人对我好一点我就能感激到不行的人。<br>&emsp;&emsp;最近负能量满满的，周末打算去骑行，断了一段时间的画画也会捡起来。我只是想证明自己可以一个人过的很好！ 夜深了，晚安～～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=28283305&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;&amp;emsp;&amp;emsp;不知道什么时候开始活的小心翼翼，一个人在一座城市的人可能大都和我一样吧，习惯于把自己最好的展现出来，把沮丧落寞这些负面的情绪埋在自己内心，不敢轻易对人说起。其实也是无从说起，或者说根本就没有倾诉的对象，对父母讲，太多的负面情绪可能更会引起他们的担心，对姐姐讲，但是她没有经历我所经历的，很多时候也无法明白我的内心，对闺蜜讲，我又觉得把负能量传递别人是一种不好的行为，我也不希望我是这种人。所以很多的时候，当我有想倾诉的那种想法时我都会把它压制下来，现在更习惯于用键盘把它敲出来，慢慢的写，慢慢的敲，也算讲给自己听吧。有时想想觉得很好笑，初中高中的时候被老师逼迫天天写日记都没有养成一个写日记的习惯，反倒是在离开学校后，主动的想去把内心的一些东西写出来了。&lt;br&gt;
    
    </summary>
    
      <category term="生活杂记" scheme="http://yaoyue.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="生活杂记" scheme="http://yaoyue.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>three.js初始（一）</title>
    <link href="http://yaoyue.com/2017/10/13/three-js%E5%88%9D%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/10/13/three-js初始（一）/</id>
    <published>2017-10-13T06:02:15.000Z</published>
    <updated>2017-10-16T06:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="三大组建"><a href="#三大组建" class="headerlink" title="三大组建"></a>三大组建</h3><pre><code>渲染物体到网页所需的三大组建：场景（scene）、相机（camera）和渲染器（renderer）场景：var scene = new THREE.Scene();相机： var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);渲染器：var renderer = new THREE.WebGLRenderer();        renderer.setSize(window.innerWidth, window.innerHeight);        document.body.appendChild(renderer.domElement);</code></pre><p>场景=》相机=》渲染器=》添加物体到场景中=》渲染=》渲染循环<br><a id="more"></a><br>芥末</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三大组建&quot;&gt;&lt;a href=&quot;#三大组建&quot; class=&quot;headerlink&quot; title=&quot;三大组建&quot;&gt;&lt;/a&gt;三大组建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;渲染物体到网页所需的三大组建：场景（scene）、相机（camera）和渲染器（renderer）
场景：var scene = new THREE.Scene();
相机： var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
渲染器：var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;场景=》相机=》渲染器=》添加物体到场景中=》渲染=》渲染循环&lt;br&gt;
    
    </summary>
    
      <category term="three.js" scheme="http://yaoyue.com/categories/three-js/"/>
    
    
      <category term="three.js" scheme="http://yaoyue.com/tags/three-js/"/>
    
  </entry>
  
  <entry>
    <title>所以等我好不好</title>
    <link href="http://yaoyue.com/2017/10/13/10%E6%9C%88%E6%9C%88%E5%88%9D/"/>
    <id>http://yaoyue.com/2017/10/13/10月月初/</id>
    <published>2017-10-13T03:17:49.000Z</published>
    <updated>2017-10-27T06:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36496726&auto=0&height=66"></iframe><br>&emsp;&emsp;来杭州还不到一年的时间，马上就要搬进第三个小窝了，其实挺喜欢现在住的这个的，小区环境很好，夜晚再晚下班回家都能看到保安，晚上楼下夜跑也很方便，侧门出去过一条马路就到了浙大，偶尔一个人去晃荡一下，假装自己还在大学。尤其是喜欢这几天，满小区的桂花树都开了，格外的好闻~但是再喜欢也无奈要搬走了，就像你再喜欢的人不喜欢你一样~</p><p>&emsp;&emsp;前晚签了新住单间的合同，房东人很好，这次终于不再是二房东了，应该也不会遇到像现在这样被赶走的情景吧~。还没开始打包，打算找个搬家公司吧，一个人搬家应该是孤独等级的第九级了，哈哈~，上一个住的哥哥，人很好，把我最喜欢的吧台桌免费送给我了，所以在遇到坏人的同时是不是也是会遇到好人的~等搬完家再来更新！<br><a id="more"></a><br>搬完家，已经全部收拾好了，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=36496726&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;&amp;emsp;&amp;emsp;来杭州还不到一年的时间，马上就要搬进第三个小窝了，其实挺喜欢现在住的这个的，小区环境很好，夜晚再晚下班回家都能看到保安，晚上楼下夜跑也很方便，侧门出去过一条马路就到了浙大，偶尔一个人去晃荡一下，假装自己还在大学。尤其是喜欢这几天，满小区的桂花树都开了，格外的好闻~但是再喜欢也无奈要搬走了，就像你再喜欢的人不喜欢你一样~&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前晚签了新住单间的合同，房东人很好，这次终于不再是二房东了，应该也不会遇到像现在这样被赶走的情景吧~。还没开始打包，打算找个搬家公司吧，一个人搬家应该是孤独等级的第九级了，哈哈~，上一个住的哥哥，人很好，把我最喜欢的吧台桌免费送给我了，所以在遇到坏人的同时是不是也是会遇到好人的~等搬完家再来更新！&lt;br&gt;
    
    </summary>
    
      <category term="生活杂记" scheme="http://yaoyue.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="生活杂记" scheme="http://yaoyue.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>opacity应用~</title>
    <link href="http://yaoyue.com/2017/09/28/opacity%E5%BA%94%E7%94%A8/"/>
    <id>http://yaoyue.com/2017/09/28/opacity应用/</id>
    <published>2017-09-28T07:41:35.000Z</published>
    <updated>2017-10-13T03:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>首先讲一个悲伤的话题，手机摔坏了… 是的，我又把屏幕给摔坏了（都想揍我自己了），上下班钉钉打卡都打不了了，然后因为屏幕已经没法点击了，所以存在一起手机屏幕里的手机联系人都取不出来了，所以到现在我只记得我爸妈手机号码了~~，昨天摔坏后，就纠结的要死，到底该买哪款手机，本来还是想买个安卓机的，但看来看去不知道买哪款，最后想着又想快点到，所以就决定了在京东上买了苹果6splus.好了，这个话题收~要总结了。<br><a id="more"></a><br>今天刚写完一个项目，<a href="http://h5.in66.com/inpromo/2017/mid-autumn/loading.html" target="_blank" rel="external">地址</a>：<a href="http://h5.in66.com/inpromo/2017/mid-autumn/loading.html，之前拿到这个项目的时候，还以为是需要用到canvas合成的，结果到最后发现根本不需要，是的根本不需要，白高兴了。好像也没有啥难点，唯一，让我有点有必要说说的地方就是opacity的应用。" target="_blank" rel="external">http://h5.in66.com/inpromo/2017/mid-autumn/loading.html，之前拿到这个项目的时候，还以为是需要用到canvas合成的，结果到最后发现根本不需要，是的根本不需要，白高兴了。好像也没有啥难点，唯一，让我有点有必要说说的地方就是opacity的应用。</a></p><p>这个项目是在in内和微信端都要可以玩，所以结果页保存的图片是和展示的结果不一样的，结果页长按保存图片，在in内有走in的协议，但是在微信端却不行，手机能够保存图片，一般是保存的img标签的图片，但是由于结果展示的图片不能和你保存到手机里的一样，所以就必须在微信端做处理，是的，用一个img标签叠在展示的img标签上面，可以看到图中有2个，上面的那个给个opac为0，然后你长按保存的其实就是opacity为0的那张图片了，之前一直没想到要这样做，后面发现这样做是不是超级赞。完了~就这些了。</p><p><img src="https://i.imgur.com/8qGol5o.jpg" alt=""></p><p>写在最后：<br>决定把这个博客不仅仅是当做分享技术的博客了，以后会慢慢分享一些生活上的事情，感触或者是心情吧，就把它当做一个记录的秘密基地吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//yaoyue1.github.io/guang.m4a"></iframe><p>最近超级超级喜欢这首歌，跑步5.7公里单曲循环了这首歌，已经完全被洗脑了，天天上班听。带着耳机，听着这首歌，晚上下班，骑个摩拜，一路上的桂花香味，心情很好。<br>这个季节最喜欢的就是桂花了~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先讲一个悲伤的话题，手机摔坏了… 是的，我又把屏幕给摔坏了（都想揍我自己了），上下班钉钉打卡都打不了了，然后因为屏幕已经没法点击了，所以存在一起手机屏幕里的手机联系人都取不出来了，所以到现在我只记得我爸妈手机号码了~~，昨天摔坏后，就纠结的要死，到底该买哪款手机，本来还是想买个安卓机的，但看来看去不知道买哪款，最后想着又想快点到，所以就决定了在京东上买了苹果6splus.好了，这个话题收~要总结了。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>项目遇坑总结（二）——nextTick及事件循环理解</title>
    <link href="http://yaoyue.com/2017/09/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%9D%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8BnextTick/"/>
    <id>http://yaoyue.com/2017/09/13/项目遇坑总结（一）——初始nextTick/</id>
    <published>2017-09-13T03:13:12.000Z</published>
    <updated>2017-09-15T10:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  此次是在做公司福利社项目的时候遇到的问题，<a href="https://fuli.in66.com" target="_blank" rel="external">链接</a>,可能你点开的时候并没有看到banner，那是因为有时候后台是没有数据的。上线的第一版，swiper是没有问题，因为整个页面的显示是通过后端一个接口传过来的数据，在created中请求接口，在mouted中实例化swiper，并没有出现问题。页面上线后工作的很好，后面后端跟我说他们需要分离接口，因为banner的代码需要要监测什么的，然后我就被忽悠去改了，因为在我觉得，就在created中多加一个 fetch请求嘛，连数据结构都一样，很简单的，所以我连上webtest测试都没有测试就直接上线了，结果到了线上就出现了今天要讲的问题，swiper他罢工了，滑不动了。<br><a id="more"></a></p><h4 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h4><p>swiper之所以会罢工，是因为mouted实例化swiper的时候，swiper的数据并没有加载好，swiper实例化的时候是需要去扫描swiper-wraper中的slide的个数的，也就是说数据没有返回你就去实例化了。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用Vue.nextTick方法，在数据返回成功后，等待dom更新完毕后再调用swiper的实例化方法。</p><pre><code>&lt;script&gt;   mouted () {        fetch(location.protocol + `//www.in66.com/webview/user/incoinbanner?` + location.search.split(&apos;?&apos;)[1], {           method: &apos;GET&apos;,           credentials: &apos;include&apos;,        }).then(response =&gt; {            response.json().then(res =&gt; {               if (res.succ) {                   this.banners = res.data                   Vue.nextTick(()=&gt;{ //dom更新完毕调用swiper实例化方法                      this.initSwiper()                   })                }            })        })   }&lt;/script&gt;</code></pre><h4 id="关于nextTick"><a href="#关于nextTick" class="headerlink" title="关于nextTick()"></a>关于nextTick()</h4><p>vue官方文档上写的用法是：在下次dom更循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的dom<br>由于vue的数据驱动视图更新是异步的，所以修改数据的当下，视图是不会立马更新的，而是要等到同一事件循环中的所有数据发生变化完成后，再统一的进行视图更新。所谓事件循环，就是指Javascript的事件执行机制，主线程执行完了执行栈中的所有同步任务之后，才会去读取任务队列，任务队列是一个先进先出的队列，所有主线程会提取队手的任务放入主线程中去执行，执行完毕后，再去读取任务队列的首个任务。主线程不断重复这个过程，所有称为事件循环。<br>   所以这里nextTick的触发是，同一事件循环的代码执行完毕 =&gt; dom更新 =&gt; nextTick callback触发</p><p>备注：<br>阮一峰老师的这篇事件循环的文字讲的甚好推荐：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  此次是在做公司福利社项目的时候遇到的问题，&lt;a href=&quot;https://fuli.in66.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;,可能你点开的时候并没有看到banner，那是因为有时候后台是没有数据的。上线的第一版，swiper是没有问题，因为整个页面的显示是通过后端一个接口传过来的数据，在created中请求接口，在mouted中实例化swiper，并没有出现问题。页面上线后工作的很好，后面后端跟我说他们需要分离接口，因为banner的代码需要要监测什么的，然后我就被忽悠去改了，因为在我觉得，就在created中多加一个 fetch请求嘛，连数据结构都一样，很简单的，所以我连上webtest测试都没有测试就直接上线了，结果到了线上就出现了今天要讲的问题，swiper他罢工了，滑不动了。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信</title>
    <link href="http://yaoyue.com/2017/08/01/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yaoyue.com/2017/08/01/vue组件通信/</id>
    <published>2017-08-01T03:49:40.000Z</published>
    <updated>2017-09-13T07:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>学习Vue算是有一段时间了，期间公司的项目开发流程也全换成了Vue了，自己也是接了几个Vue的项目了，不过总感觉，知道的不是特别多，每次做起项目也总会遇到这样或者是那样的问题，这次总结一下项目中用到的比较频繁的组件之间的通信。</p><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>props方式：<br><a id="more"></a><br>父组件当中的nearbyData传递给子组件</p><pre><code>&lt;nearby :nearbyDate=&quot;nearbyDate&quot; :key=&quot;idx&quot; v-for=&quot;(nearbyDate,idx) in nearbyItems&quot;&gt;&lt;/nearby&gt;</code></pre><p>子组件中通过声明props后使用父组件传递过来的nearbyData来进行页面的渲染</p><pre><code> &lt;div class=&quot;left-box&quot; @click=&quot;openinji(nearbyDate.user_id)&quot;&gt;    &lt;img :src=&quot;nearbyDate.self_url&quot;/&gt;    &lt;div class=&quot;name&quot; :class=&quot;{name_xia:nearbyDate.label.length &gt; 0 ? false:true}&quot;&gt;{{nearbyDate.name}}&lt;/div&gt;    &lt;div class=&quot;label-box&quot;&gt;        &lt;p class=&quot;label&quot; :key=&quot;idx&quot; v-for=&quot;(labelintro,idx) in nearbyDate.label&quot;&gt;{{labelintro}}&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>$emit方式</p><p>子组件通过$emit像父组件传递一个自定义事件和一个参数</p><pre><code>&lt;template&gt;   &lt;div class=&quot;box&quot; @click=&quot;sendMessage&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {   methods: {      sendMessage () {        this.$emit(&apos;listen&apos;, &apos;data&apos;)      }   }}&lt;/script&gt;</code></pre><p>在父组件的子组件标签中监听该自定义事件，并且用一个对应的方法来处理事件</p><pre><code> &lt;template&gt;   &lt;div class=&quot;wrap&quot;&gt;    &lt;child :sendMessage=&quot;handleMessage&quot;&gt;&lt;/child&gt;    &lt;/div&gt; &lt;template&gt;&lt;script&gt;export default {  methods: {    handleMessage (data) {        console.log(data)    }  }}&lt;/script&gt;</code></pre><p>总结上述，即可以得出，父传子是通过props属性来传值，子传父则是通过自定义事件。</p><h3 id="子传子"><a href="#子传子" class="headerlink" title="子传子"></a>子传子</h3><p>中央事件总线，也称为事件巴士，听名字就知道是一个担任组件与组件之间通信介质的东西。</p><h4 id="创建eventBus"><a href="#创建eventBus" class="headerlink" title="创建eventBus"></a>创建eventBus</h4><p>创建一个名为eventBus.js的文件，新建一个Vue实例<br>      import Vue from ‘Vue’<br>      export default new Vue</p><h4 id="子组件中引入eventBus，传入自定义事件和参数"><a href="#子组件中引入eventBus，传入自定义事件和参数" class="headerlink" title="子组件中引入eventBus，传入自定义事件和参数"></a>子组件中引入eventBus，传入自定义事件和参数</h4><p>子组件中引入eventBus,并像其传入自定义事件和参数，$emit实例方法触发的是当前实例上的事件，附加参数都会传给监听器回调。</p><pre><code>&lt;template&gt;  &lt;div class=&quot;box&quot; @click=&quot;sendMessage&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import bus  from &quot;../assets/eventBus&quot;;export default {   methods: {       sendMessage () {          bus.$emit(&apos;sendmsg&apos;, &apos;data&apos;)       }   }}&lt;/script&gt;</code></pre><h4 id="子组件中引入eventBus-监听事件获取传入参数"><a href="#子组件中引入eventBus-监听事件获取传入参数" class="headerlink" title="子组件中引入eventBus,监听事件获取传入参数"></a>子组件中引入eventBus,监听事件获取传入参数</h4><p>$on监听当前实例上的自定义事件，事件可以是由$emit触发的，回调函数会接受所有传入事件触发函数（$emit）的额外参数。</p><pre><code> mounted () {  bus.$on(&apos;sendmsg&apos;, (data) =&gt; {    console.log(data)  })}</code></pre><h3 id="父调用子"><a href="#父调用子" class="headerlink" title="父调用子"></a>父调用子</h3><p>通过$refs，父组件能够调用子组件里的属性与方法</p><pre><code>&lt;template&gt; &lt;iAudio id=&quot;audio&quot; ref=&quot;auido&quot; loop autoplay src=&quot;//inimg05.jiuyan.info/in/2017/07/26/FC889FF2-55B1-1C3B-146A-F3E966EC6803.mp3&quot;&gt;&lt;/iAudio&gt; &lt;div @click=&quot;paly&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  methods: {      play () {          this.$refs.auido.pause()      }  }}&lt;/script&gt;</code></pre><p>注意：当 ref 和 v-for 一起使用时，ref 是一个数组，包含相应的子组件。$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs。</p><p>组件之间的通信大概就是这几种方式了，一般中小型的项目，以上的通信方式以及足够用了，但如果是比较大型的项目可能就会需要用到vuex来集中管理状态了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Vue算是有一段时间了，期间公司的项目开发流程也全换成了Vue了，自己也是接了几个Vue的项目了，不过总感觉，知道的不是特别多，每次做起项目也总会遇到这样或者是那样的问题，这次总结一下项目中用到的比较频繁的组件之间的通信。&lt;/p&gt;
&lt;h3 id=&quot;父传子&quot;&gt;&lt;a href=&quot;#父传子&quot; class=&quot;headerlink&quot; title=&quot;父传子&quot;&gt;&lt;/a&gt;父传子&lt;/h3&gt;&lt;p&gt;props方式：&lt;br&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack初识（一）</title>
    <link href="http://yaoyue.com/2017/07/26/webpack%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/07/26/webpack初识（一）/</id>
    <published>2017-07-26T02:54:55.000Z</published>
    <updated>2017-07-26T03:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  虽然在公司用webpack好多次了，但是对其一直不是很了解，此次为了弄清楚目录结构，必须要学一下webpack。</p><h3 id="webpack是做什么的"><a href="#webpack是做什么的" class="headerlink" title="webpack是做什么的"></a>webpack是做什么的</h3><p>  官方的文档上是这样描述webpack的，说它是前端资源模块化管理和打包的工具，它能把任何形式的资源都看做是模块，根据其依赖关系，打包成为静态文件资源。</p><p><img src="http://www.css88.com/doc/webpack2/img/webpack.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;  虽然在公司用webpack好多次了，但是对其一直不是很了解，此次为了弄清楚目录结构，必须要学一下webpack。&lt;/p&gt;
&lt;h3 id=&quot;webpack是做什么的&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yaoyue.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（四）--仿知乎登录页</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BB%BF%E7%9F%A5%E4%B9%8E%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（四）-仿知乎登录页/</id>
    <published>2017-04-05T07:28:04.000Z</published>
    <updated>2017-04-05T08:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:<a href="https://yaoyue1.github.io/dot.html" target="_blank" rel="external">传送门</a>,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。<br>看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码<br><a id="more"></a></p><p><pre><br><code><br>    $(function(){<br>      var cvs = document.getElementById(“mycanvas”);<br>      var ctx = cvs.getContext(‘2d’);<br>      var docWidth = document.documentElement.clientWidth;<br>      var docHeight = document.documentElement.clientHeight;<br>      cvs.width = docWidth;<br>      cvs.height = docHeight;//初始化准备，让canvas的宽高等于可视区的宽高<br>      var dotNum = 100;//整个区域粒子的数量<br>      var dots = [];//用来存放粒子对象的数组<br>      var mouse = new Object();//声明的对象用来存放鼠标的初始X、Y值<br>      mouse.x = 800;<br>      mouse.y = 350;<br>      for(var i=0;i<dotnum;i++){ 循环dotnum数量的粒子为每个粒子对象添加属性="" var="" dotobj="new" object();="" dotobj.x="Math.random()*docWidth;//初始的x坐标位置" dotobj.y="Math.random()*docHeight;//初始的y坐标位置" dotobj.r="Math.ceil(Math.random()*4);//粒子半径" dotobj.color="white" ;="" 粒子颜色="" dotobj.speedx="Math.floor(Math.random()*2)?1:-1//粒子X轴的运动方向" dotobj.speedy="Math.floor(Math.random()*2)?1:-1//粒子Y轴的运动方向" dots[i]="dotObj;//把粒子对象装进数组" }="" function="" drawball(x,y,r,color){="" 画每个粒子圆="" ctx.beginpath();="" ctx.arc(x,y,r,0,math.pi*2,false);="" ctx.fillstyle="color;" ctx.fill()="" move(obj){="" 粒子的移动函数="" obj.x="" +="obj.speedX*0.2;//粒子x轴方向每次移动的距离" obj.y="" if(obj.y<="obj.r){//上边界小球反弹处理" obj.speedy*="-1;" if(obj.y="">= docHeight-obj.r){//下边界小球反弹处理<br>          obj.y = docHeight-obj.r;<br>          obj.speedY<em>=-1;<br>        }<br>        if(obj.x&lt;=obj.r){//左边界的小球反弹处理<br>          obj.x = obj.x;<br>          obj.speedX</em>=-1;<br>        }<br>        if(obj.x &gt;= docWidth-obj.r){//右边界的小球反弹处理<br>          obj.x = docWidth-obj.r;<br>          obj.speedX<em>=-1;<br>        }<br>      }<br>      function ballAndball(obj1,obj2){//封装函数用来求两个球或者是球和鼠标直接的直线距离<br>        var disX = Math.abs(obj1.x-obj2.x);//相距的X绝对值<br>        var disY = Math.abs(obj1.y-obj2.y);//相距的Y绝对值<br>        return Math.sqrt(disX</em>disX+disY*disY)//平方根求直线距离<br>      }<br>      function mouseball(mouse,obj){//鼠标移动，把鼠标和距离其130内的小球连成线<br>        if(ballAndball(mouse,obj)&lt;130){<br>          ctx.lineWidth = 0.2;<br>          ctx.beginPath();<br>          ctx.moveTo(obj.x,obj.y);<br>          ctx.lineTo(mouse.x,mouse.y);<br>          ctx.strokeStyle = obj.color;<br>          ctx.stroke();</dotnum;i++){></code></pre></p><pre><code>    }  }  render();  function render(){    ctx.clearRect(0, 0, docWidth, docHeight);//清除画布    for(var j= 0;j &lt; dots.length;j++){//两层for循环，第一层是先画小球然后让每个小球移动，鼠标移动连线      little = dots[j]      move(little)      drawball(little.x,little.y,little.r,little.color)      mouseball(mouse,little)      for(var k = 0;k &lt; dots.length;k++){//第二层循环是用来找出两个球如果相距100就把他们用线连接起来        if(ballAndball(dots[j],dots[k])&lt;100){          ctx.lineWidth = 0.2;          ctx.globalAlpha = (130 - ballAndball(dots[j], dots[k])) * 1 / 100;//这句代码是用来控制线的消失和出现的效果          ctx.beginPath();          ctx.moveTo(dots[j].x, dots[j].y);          ctx.lineTo(dots[k].x, dots[k].y);          ctx.strokeStyle = dots[j].color;          ctx.stroke();        }      }      ctx.globalAlpha = 1.0    }    requestAnimationFrame(render);//浏览器自动刷新时间来循环调用render  }  cvs.onmousemove = function(event){//鼠标移动是的X、Y坐标    e = event || window.event;    mouse = new Object();    mouse.x = e.offsetX;    mouse.y = e.offsetY;  }})</code></pre><p><br>代码的核心部分可能就是求两个小球的距离来再次循环连线了。因为注释写的比较清楚，所以我就不多说了，下次的canvas学习一点点（五）还不知道些什么？？？纠结啊，你有啥想法可以告诉我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:&lt;a href=&quot;https://yaoyue1.github.io/dot.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。&lt;br&gt;看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（三）--黑客帝国</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（三）-黑客帝国/</id>
    <published>2017-04-05T07:27:28.000Z</published>
    <updated>2017-04-05T07:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间戳</title>
    <link href="http://yaoyue.com/2017/03/31/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <id>http://yaoyue.com/2017/03/31/时间戳/</id>
    <published>2017-03-31T09:31:09.000Z</published>
    <updated>2017-09-14T02:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>再次更新：</p><p>最近再回看自己写的文章的时候，才发现写的地方没讲清楚，哈哈哈，也许是当时并没有理解清楚，重新更新一下。</p><p>关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。稍微吐槽一下自己写的代码，不过有点扯远了，今天主要讲时间戳。<br>我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳过来：1505232000，这样一串数字就是时间戳。<br><a id="more"></a><br>你会想知道明明js可以获取到时间啊，为啥还需要这样传，那是因为js是获取到你系统本地的时间，你想如果你自己调快了时间那岂不是不准确了。所以时间戳的用处就是这样。<br>拿到一串时间戳你要怎样把它转化成为XX年xx月xx日这样的呢？<br>这里必须要提到PHP的时间戳和js的时间戳是不一样的，你通过new Data().getTime()或者是通过Date.parse(new Date())方法获取到的js时间戳是13位，而你会发现php传过来的时间戳是10位，是的，js获取的时间戳和PHP获取的时间戳是有区别的：</p><ul><li>单位区别：PHP获取的时间戳是以秒为单位的，而js获取的时间戳是以毫秒为单位的，所以你必须要转换单位，1秒=1000毫秒</li><li>时区区别：PHP通过time()获取的时间戳，通常会跟服务器所在的时区有关，js获取的时间戳则是依据你的系统时间确定的，如果你把你的手机或者电脑的时间设置比正常快或慢，js获取的时间会以你的设置时间为准，这也是为什么我们用实际不能通过js本地获取。<br><img src="http://i.imgur.com/ljI4ovd.png" alt=""></li></ul><p>封装一个方法format（）；这样你只有把时间戳传进去就可以给你返回xx年xx月xx日xx:xx</p><pre><code> function add0(m) {    return m &lt; 10 ? &apos;0&apos; + m : m;}function format(t) {    var time = new Date(parseInt(t) * 1000);//这里为什么乘以1000，也就是因为PHP和js的时间戳的单位不一致    var y = time.getFullYear();    var m = time.getMonth() + 1;    var d = time.getDate();    var h = time.getHours();    var mm = time.getMinutes();    var s = time.getSeconds();    return y+&apos;年&apos;+add0(m) + &apos;月&apos; + add0(d) + &apos;日 &apos; + add0(h) + &apos;:&apos; + add0(mm);}</code></pre><p>截图放一张我这次做的活动的签到日历：<br>！<a href=""></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再次更新：&lt;/p&gt;
&lt;p&gt;最近再回看自己写的文章的时候，才发现写的地方没讲清楚，哈哈哈，也许是当时并没有理解清楚，重新更新一下。&lt;/p&gt;
&lt;p&gt;关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。稍微吐槽一下自己写的代码，不过有点扯远了，今天主要讲时间戳。&lt;br&gt;我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳过来：1505232000，这样一串数字就是时间戳。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（二）--</title>
    <link href="http://yaoyue.com/2017/03/31/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/31/canvas学习一点点（二）/</id>
    <published>2017-03-31T05:49:34.000Z</published>
    <updated>2017-04-01T07:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。<br>最终的效果：<a href="https://yaoyue1.github.io/bar.html" target="_blank" rel="external">传送门</a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;canvas id= &quot;mycanvas&quot; width=&apos;500&apos; height=&apos;500&apos;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure><pre><code>//js$(function(){      var cvs = document.getElementById(&apos;mycanvas&apos;);      var ctx = cvs.getContext(&apos;2d&apos;);      var centerX = cvs.width/2;//圆心的x坐标      var centerY = cvs.height/2;//圆心的y坐标      var rad = Math.PI*2/100;//把2π弧度分成100份，每一份的弧度值      var initNum = 0.1;//初始化的基础百分比      var speed = 0.2;//加载速度      function blueCircle(n){画进度的展示蓝圈          ctx.save();//保存画布状态          ctx.strokeStyle = &quot;#49f&quot;;          ctx.lineWidth = 5;          ctx.beginPath();          ctx.arc(centerX, centerY, 200,-Math.PI/2, -Math.PI/2+n*rad,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function  initCircle(){//画最开始的初始化圆圈          ctx.save();          ctx.beginPath();          ctx.strokeStyle = &quot;white&quot;;          ctx.arc(centerX, centerY, 200, 0,Math.PI*2,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function text(n){//画中间的文字          ctx.save();          ctx.strokeStyle = &quot;#49f&quot;;          ctx.font = &apos;40px Arial&apos;          ctx.strokeText(n.toFixed(0)+&apos;%&apos;,centerX-25, centerY+10);          ctx.stroke();          ctx.restore();      }      draw()      function draw(){          window.requestAnimationFrame(draw);//浏览器的刷新频率自动调整动画的时间间隔          ctx.clearRect(0, 0, cvs.width, cvs.height);//清除上一次画布的内容          initCircle()//调用方法          text(initNum);          blueCircle(initNum);          initNum+=speed;          if(initNum&gt;100){//当进度达到100的时候就让他一直为100，不然你的进度条要破100的~~~~              initNum = 100          }      }  })</code></pre><p>是不是觉得很简单~~代码不多确实jq很难做到的，之前用jq写一般都只能写长条形状的进度条。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。&lt;br&gt;最终的效果：&lt;a href=&quot;https://yaoyue1.github.io/bar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>ios touch事件导致的CSS3动画问题</title>
    <link href="http://yaoyue.com/2017/03/30/ios-touch%E4%BA%8B%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84CSS3%E5%8A%A8%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yaoyue.com/2017/03/30/ios-touch事件导致的CSS3动动画问题/</id>
    <published>2017-03-30T05:57:06.000Z</published>
    <updated>2017-03-31T02:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>刚刚做完一个腾讯动漫的项目：<a href="https://www.in66.com/html/tonglingfei/index.html" target="_blank" rel="external">传送门</a>,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当你到达这个页面的时候，你会看到5个不同的美男子，你点击其中任何一个都会去一个相对应的故事，假如你点击第二个你会看到第二张图。第二张图中我用红色框框出来的这些对话框都是需要一个一个的接着出现，所以我当时的第一反应是采用CSS3的animation-delay属性来解决，只需要给每个对话框设置一个延迟的属性，让她依次出来不就行了，我也确实是这样做了。然而因为我穷，只买得起安卓手机，所以只测了安卓一点问题都木有，在chrome模拟器上也啥事没有，我就真信了这样做简直不能太好，等全部做完了，来测试上线的时候才发现ios尼玛的又出现问题了。因为这些故事的页面都超过了一屏，所以必须要滑动屏幕才能看下面的，ios出问题就出现在这：ios当你触摸屏幕或者滑动屏幕时它会暂停掉你屏幕上CSS的渲染，所以只要你的手还在屏幕上，对话框的出现就会被截断，你放开手后才能继续加载。但是蛋疼的是后来加载的对话框它的延迟时间会重头开始算起而不是从你松开手的那一刻算，这就真是坑了，等半天都出不来。</p><p><img src="http://i.imgur.com/YVK0j59.png" alt=""><br><img src="http://i.imgur.com/Ch5vXwA.png" alt=""></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>赶紧去google一下才发现这事前端真的很无辜，是ios事件的处理机制有关。<br>ios和安卓不同，他们处理事情的机制顺序不一样。</p><ul><li>ios的处理机制是：它的响应顺序依次为：Touch——Media——Service——Core架构，你可以看到它最先响应的是屏幕的反应，所以只要用户触摸屏幕，系统最先去处理的就是touch了，此时会暂停屏幕上包括js、css的渲染，这个时候不光是css动画不动了，哪怕页面没有加载完如果你手指头还停留在屏幕上那么页面也不会继续加载，直到你的手松开</li><li>Android的处理机制是：它的响应顺序依次为：Application——Framework——Library——Kernal架构，和屏幕显示相关的处于library这一层，所以当你对屏幕操作之后，Android首先会激活应用、框架，然后才是屏幕最后是核心架构。</li></ul><p>以上就是为啥安卓手机很流畅，ios却出现了CSS3动画的滚动停止了。<br>那到底该咋解决呢？？到底该咋解决呢？？<br>其实到现在我的解决方式都不算太好，我把原先用CSS3控制顺序的方式改成了用js的setTimeout()的方式，你也看到了，这真的很不好，写了一堆的setTimeout函数，但是这样做虽不能解决滚动时停止加载，但是最起码时间的计算方式不是从头开始算的了。找不到更好的方法了，如果你知道，请不要害羞的多多指教~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚做完一个腾讯动漫的项目：&lt;a href=&quot;https://www.in66.com/html/tonglingfei/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（一）</title>
    <link href="http://yaoyue.com/2017/03/30/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/30/canvas学习一点点（一）/</id>
    <published>2017-03-30T05:47:18.000Z</published>
    <updated>2017-03-31T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~</p><p>今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。<br>最终效果链接：<a href="https://yaoyue1.github.io/snow.html" target="_blank" rel="external">传送门</a><br>快和你的妹纸一起来看雪吧~~~<br><a id="more"></a></p><pre><code>//html&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;//js$(function(){ snow()function snow(){    var docWidth = document.documentElement.clientWidth //可见区域宽度    var docHeight = document.documentElement.clientHeight //可见区域高度    // initPage()    function initPage(){        containerWidth = $(&quot;.container&quot;).width();//获取外层容器container宽度        containerHeight = $(&quot;.container&quot;).height();//获取外层容器container高度        initFloatAnimation()    }    function initFloatAnimation(){        var canvas = document.createElement(&apos;canvas&apos;);//创建canvas元素        var ctx = canvas.getContext(&apos;2d&apos;);            canvas.id = &apos;floatCanvas&apos;;//给canvas一个id            canvas.width = containerWidth;//让canvas的宽度等于container的宽度            canvas.height = containerHeight;//让canvas的高度等于container的高度        $(&quot;.container&quot;).append(canvas);//把canvas追加进html的container        var particleNum = 100;//粒子的数量        var particles = [];//定义空数组用来存储每个粒子对象        for (var i=0;i&lt;particleNum;i++){            var particleObj = new Object();//创建一个对象            particleObj.x = Math.random()*docWidth;//在可视区域宽度的范围内随机生成粒子的初始x坐标            particleObj.y = Math.random()*docHeight;//在可视区域g的范围内随机生成粒子的初始y坐标            particleObj.vx = Math.random() * 2-1;//生成粒子横向移动的距离            particleObj.vy = (Math.random() * 0.8 + 0.2);//生成粒子纵向移动的距离：[0.2-1]            particleObj.dw = particleObj.vy*20;//随机生成粒子的宽度            particleObj.dh = particleObj.dw;//粒子的宽度等于高度            particleObj.ag = (Math.random()*2-1)*10;//粒子的初始角度            particles[i] = particleObj;//把这些对象装进事先定义的数组        }        console.log(particles)        // 以上把需要的元素都准备好了，接下来就是渲染让粒子动起来        render()        function render(){            ctx.clearRect(0, 0, containerWidth, containerHeight);//清除画布            var little;            for(var j=0;j&lt;particles.length;j++){                little = particles[j];                if(little.x &lt; 0 || little.x &gt; containerWidth || little.y &gt; containerHeight){//if判断如果粒子已经超出了可视的边界就再重新产生它的x,y值                    little.x = Math.random() * containerWidth;                    little.y = Math.random() * -200;                }                little.x += little.vx;                little.y += little.vy;                drawImage(ctx,img,little.x,little.y,little.dw,little.dh,1,little.ag);            }            requestAnimationFrame(render);//循环调用自身，requestAnimationFrame是一个新的API,作用与setTimeInterval一样，不同的是它会根据浏览器的刷新频率自动调整动画的时间间隔。        }    }    function drawImage (ctx,img,dx,dy,dw,dh,scale,angle) {        ctx.save();        ctx.translate(dx + dw / 2, dy + dh / 2);//移动画布        ctx.scale(scale, scale);        ctx.rotate(angle);        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -1 * dw / 2, -1 * dh / 2, dw, dh);//重新绘制新的粒子        ctx.restore();    }var _base = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAlCAMAAADyQNAxAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALnRSTlMArr2Dd6phklkuBYhdNo0yOmpFFZd/exkOCW4/VkqecqdlJh4Ro04jtVG5KpuwTP8QawAAArlJREFUOMuVlNmSsjAQhXUIIYGEhM0g+6Igou//ev9hsZwZay7+ruLuq3O6T7o5/H+5Z/cQRZfzOT3/DZ2jyHRc8Xmcxz76g7n0nHOpda5zqTg3509BNzWz0mVZDkMxFVMZytlcUve32chlODEmmKCUClaEuebd+BMyXOYDEy0NsqCuSZZRUbCcj5fvVNrLsBBtRjKSnBIrOZEsoGLQSkbfpEaVFzQghCQWyvMsK6kDysJcjm8lrmBHM3KyPN/3HccHCrlWwNS8KKN0yFqYeb4TV3FVxbHjexYhgRjkvLfmrk1lEAJztRvbbppr7HgJIS0LVb931elBBMSynMf1uJZt2wsGU1poHm1SvCxonVh+3NhAXlzlL54s3AZIOzmIzIJUtVK3++22YjE8M6FVdwYVcc0g5fmxDeh5/0Ldnke7iSEWiFKOKaieY0ACwweg29dWd6hVjnWqKZNm0yqhhQErUKvSqnZsFoq0g+wuC6VKaFm+c7WPz51BHe3HEgZluYowouGhCJCo0+yOe2MNKKteori4mBGOATktWvbz3Ra0kP+Wq7vOONH65DkPiN12qYWKHQxJi9XxYDo1tASNVfba/v2G77ik72NGMW1JuEZOYnnqRwOx5yJzB7U+EYIY0NZCjSpk6wshi+a4F3JA8xkddAdqe6JSoH9g2BobZnZzvWJ3EkiVsl8M1yzyYt1By4mxO9fq+oAdIg1oKHnk7rs6qm0LLQ+L6sTOtq01bilUJn3dYjTrSWDv1533EZOXnBYlkSPS93X0Ki9xHjXBAaFgRgCxKefRfuD7AFh9RmlN1sraIKBFoRXme5d7McAG2LYBBbFcd5nnyryR3XTmWheTEAxVsAnTjbD7XVHfzVLn5YRfShhikU0Ku49y3bSbuVKSK87n/tXSJ5deTGd6E6XpT7NPQffwKfIPFOtCNONyh58AAAAASUVORK5CYII=&quot;    //图片我直接用的base64来写的    var img = new Image();    img.src = _base;    img.onload = function() {        initPage()    }}})</code></pre><p>   个人感觉注释已经写的比较详细了，就不再多说了哈~~，来和你的妹纸一起来看雪吧！！！</p><p>   什么？？？你没有没有啊？？</p><p><img src="https://a-ssl.duitang.com/uploads/item/201609/04/20160904102522_Fadn4.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~&lt;/p&gt;
&lt;p&gt;今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。&lt;br&gt;最终效果链接：&lt;a href=&quot;https://yaoyue1.github.io/snow.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;快和你的妹纸一起来看雪吧~~~&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>下拉加载你这个坑货~</title>
    <link href="http://yaoyue.com/2017/03/15/%E4%B8%8B%E6%8B%89%E5%8A%A0%E8%BD%BD%E4%BD%A0%E8%BF%99%E4%B8%AA%E5%9D%91%E8%B4%A7-1/"/>
    <id>http://yaoyue.com/2017/03/15/下拉加载你这个坑货-1/</id>
    <published>2017-03-15T04:00:53.000Z</published>
    <updated>2017-03-15T09:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>   前两天刚做的一个<a href="https://www.in66.com/html/photoShare2017/index.html" target="_blank" rel="external">项目</a>,需要用下拉加载的方式去请求数据。我原以为这会是很简单的，肯定分分钟写完（不过确实也挺简单的），只不过还是坑了我一些的。</p><h3 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h3><p><pre><br>$(window).scroll(function(){<br>　　var scrollTop = $(this).scrollTop();<br>　　var scrollHeight = $(document).height();<br>　　var windowHeight = $(this).height();<br>　　if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“you are in the bottom”);<br>　　}<br>});<br></pre><br><a id="more"></a><br>看完上面的代码是不是觉得完全没有毛病，嗯呐~，当初我也是这样觉得的，很对呀。而且我在安卓手机和chrome模拟器上完全没有问题。scrollTop获取的是滚动条滚动的距离，scrollHeight获取到的是整个文档的高度，windowHeight是获取当前也就是你浏览器所能看到的页面的那部分的高度，你已经滚过的高度+你目前看到的剩下的可视高度等于你整个文档高度的时候，确实表示了滚动条就在文档的最下面了。嗯，灰常好。然后你就灰常开心的去请求数据去了，也就是这样：<br><img src="http://i.imgur.com/OExNWyP.png" alt=""><br>是不是你现在也觉得木有毛病。我当时测的时候也很开心。但是当我去借了个苹果的测试机来测的时候尼玛问题来了。也就是我要讲到的第一个坑。这段js对苹果木有反应。我就想着是咋回事嘛~，搞了半天才发现，原来自己傻了</p><p><pre><br>if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“you are in the bottom”);<br>　　}<br></pre><br>其实坑就在这句话中，因为是写的等于，所以只有一个点能判断到达底部了，如果你不断的触动屏幕，很有可能的你滚动条就已经达不到这个点了，而且加上苹果手机到达底部的时候，你再滑动的时候页面会被拖出一个区域，所以这个点对于苹果手机来说有问题。所以不能改成一个点。而且还有一个重要的原因就是，你的数据是请求得来的，你还需要拿数据去渲染页面，为了用户不等待，你需要预留一段时间来请求，而不是等到已经最底部了再去请求。所以我立马高兴的改成了这样：</p><p><pre><br>if(scrollTop + windowHeight &gt; scrollHeight -100){<br>　　　　alert(“you are in the bottom”);<br>　　}<br></pre><br>这样就是代表你在距离底部100px的时候都会给你触发到达底部了。这样果然苹果没问题了。但是我立马发现了另外一个问题，也就是坑二。</p><h3 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h3><p>数据重复了，啥意思呢？就是说你的滚动条如果一直在距离底部100px的范围内得到话，它就会给你去执行你的render()方法，然后去渲染页面。你想如果你一直在100px的范围的话，那他就会给你不断的去发请求，上一个请求还没执行完，你又去了，请求的数据肯定会被重复。所以解决的办法呢就是你设置一个标志，如果上一次请求成功了之后，页面渲染完成了之后，你再去请求，这样就好了。代码如下：<br><img src="http://i.imgur.com/nCJqq2h.png" alt=""><br>相比于刚刚的代码，我加上了一个isSucc的变量来判断，第一次请求这个变量是true，你可以去请求，一进入后立马把这个变量设置为false，代表我这次的请求还没完全走完，你下一波等等，等到页面完全渲染好了，请求已经done了后你再把这个变量设置为true，然后下一波就可以去请求了。</p><p>你以为写到现在完了，其实还有一个问题，就是当数据库中已经没有数据了，你就不能再狂发请求了，所以你还需要干一件事，就是再设置一个标志来判断数据库中是否还有数据，有，就去请求，没有就不要再去请求了。<br>所以最终的代码应该是这样：<br><img src="http://i.imgur.com/REdmMFd.png" alt=""><br>好啦~到现在为止一个下拉加载才写好了，啦啦啦啦啦~写的不对的地方望大神指教好改正！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   前两天刚做的一个&lt;a href=&quot;https://www.in66.com/html/photoShare2017/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目&lt;/a&gt;,需要用下拉加载的方式去请求数据。我原以为这会是很简单的，肯定分分钟写完（不过确实也挺简单的），只不过还是坑了我一些的。&lt;/p&gt;
&lt;h3 id=&quot;坑一&quot;&gt;&lt;a href=&quot;#坑一&quot; class=&quot;headerlink&quot; title=&quot;坑一&quot;&gt;&lt;/a&gt;坑一&lt;/h3&gt;&lt;p&gt;&lt;pre&gt;&lt;br&gt;$(window).scroll(function(){&lt;br&gt;　　var scrollTop = $(this).scrollTop();&lt;br&gt;　　var scrollHeight = $(document).height();&lt;br&gt;　　var windowHeight = $(this).height();&lt;br&gt;　　if(scrollTop + windowHeight == scrollHeight){&lt;br&gt;　　　　alert(“you are in the bottom”);&lt;br&gt;　　}&lt;br&gt;});&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>和clip-path来场美丽的初识</title>
    <link href="http://yaoyue.com/2017/03/08/%E5%92%8Cclip-path%E6%9D%A5%E5%9C%BA%E7%BE%8E%E4%B8%BD%E7%9A%84%E5%88%9D%E8%AF%86/"/>
    <id>http://yaoyue.com/2017/03/08/和clip-path来场美丽的初识/</id>
    <published>2017-03-08T02:30:01.000Z</published>
    <updated>2017-03-21T08:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  公司前端的技术分享轮到我了，有点小迷茫，不知道该讲什么，纠结来纠结去，偶然看到了腾讯全端 AlloyTeam团队的一篇博文分享，是关于clip-path的，虽然写的比较简单（也可能是我的level还没有达到辣么个水平,完全不能理解）但是真的被那个炫酷的动画给迷倒了。就想一探究竟，然后讲讲这个。（其实最主要我还是觉得这个属性大家平时用到的不多，可能很多人也不是特别了解，作为一个实习生去讲给一堆大牛听这种偏冷门的属性是最合适不过了，哈哈哈，小心机一下）正式开始写啦啦~</p><h3 id="clip-path基本属性"><a href="#clip-path基本属性" class="headerlink" title="clip-path基本属性"></a>clip-path基本属性</h3><p>clip-path一共有四个基本的属性裁剪再加上一个可以直接引用SVG的属性算是五个吧。前面四个基本的是polygon（多边形），circle（圆形），ellipse（椭圆）、inset（圆弧）。下面先开始说这四个属性：</p><h4 id="裁剪多边形"><a href="#裁剪多边形" class="headerlink" title="裁剪多边形"></a>裁剪多边形</h4><p><pre><br>-webkit-clip-path: polygon(0 25%,25% 0,75% 0,100% 25%,100% 75%,75% 100%,25% 100%,0 75%);<br></pre><br><a id="more"></a><br>一步一步分析：以上一共是8组坐标，每组坐标之间用逗号隔开，前面的一个表示x坐标，后面一个表示y坐标，所有的坐标连接起来就构成你所需要裁剪的形状。（原谅本人较懒随便用qq截图画的这个坐标(^o^)/~，之后的坐标都是这样的，我就更懒得画了）</p><p><img src="http://i.imgur.com/sz4Ch4N.png" alt=""></p><h4 id="裁剪圆形"><a href="#裁剪圆形" class="headerlink" title="裁剪圆形"></a>裁剪圆形</h4><p><pre><br>-webkit-clip-path: circle(300px at 50% 50%);<br></pre><br>画圆是circle:接受三个参数，第一个参数为圆的半径，第二个参数为圆的圆心x坐标，第三个参数为圆的圆心y坐标，用at隔开</p><p><img src="http://i.imgur.com/Nbzb5t7.png" alt=""></p><h4 id="裁剪椭圆"><a href="#裁剪椭圆" class="headerlink" title="裁剪椭圆"></a>裁剪椭圆</h4><p><pre><br>-webkit-clip-path: ellipse(50% 40% at 50% 50%);<br></pre><br>裁剪椭圆为ellipse：at前面的一对值表示椭圆的半径值（a,b），at后面的一对值表示椭圆的圆心值<br><img src="http://i.imgur.com/2ult15m.png" alt=""></p><h4 id="裁剪圆弧"><a href="#裁剪圆弧" class="headerlink" title="裁剪圆弧"></a>裁剪圆弧</h4><p><pre><br>-webkit-clip-path:  inset(30px 90px 50px 90px round 0 25% 0 25%);<br></pre><br>inset属性老版本的chrome浏览器可能不支持。它有8个参数，round前面的四个值表示上、右、下、左的四个坐标值，round后面的四个值表示top-radius right-radius bottom-radius left-radius等弧度。</p><p><img src="http://i.imgur.com/xTdSXJT.png" alt=""></p><h3 id="实际用例"><a href="#实际用例" class="headerlink" title="实际用例"></a>实际用例</h3><p>就这么个普通的clip-path属性你可能会想它在实际的应用中一般都有啥用途呢？我将列举一下它比较常见的通途，如果你有遇到比较好玩的，也可以告诉我哦~~对啦在讲应用前还是先贴一张clip-path属性的浏览器支持情况：<br><img src="http://i.imgur.com/Tuf1SKm.png" alt=""></p><h4 id="小三角形的实现"><a href="#小三角形的实现" class="headerlink" title="小三角形的实现"></a>小三角形的实现</h4><p><img src="http://i.imgur.com/LuuZY9k.png" alt=""></p><p>如图的对话框下面的小三角形就可以使用clip-path的方法实现。当然这个小三角形的实现方法也不是只有这一种，而且此种方法也是有一些弊病的，就是ie浏览器是不会支持你的哈哈哈哈~~<br>关于这个小三角形实现的其他几种方法我也提一下吧，都是自己之前做项目的时候使用过的，顺便写一下，自己再熟悉一下。</p><ul><li>第一种：clip-path    </li></ul><p>也就是把一个小的div裁剪成一个三角形在定位到指定位置</p><pre><code>//html&lt;div class=&quot;tangle1&quot;&gt;  &lt;span&gt;hello world!&lt;/span&gt;  &lt;div class=&quot;icon1&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle1{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon1{        position: absolute;        left:70%;        top:100%;        width: 50px;        height: 30px;        background: #f5a0bd;        -webkit-clip-path: polygon(0 0,100% 0,50% 100%)    }</code></pre><ul><li><p>第二种：transparent</p><pre><code>//html&lt;div class=&quot;tangle2&quot;&gt;    &lt;span&gt;hello world!&lt;/span&gt;    &lt;div class=&quot;icon2&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle2{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon2{        position: absolute;        left:70%;        top:99%;        width: 0px;        height: 0px;        font-size: 0;        border: 20px solid transparent;        border-top-color: #f5a0bd;    }</code></pre></li><li>第三种：transfrom 的旋转功能</li><li><pre><code>//html&lt;div class=&quot;tangle3&quot;&gt;  &lt;span&gt;hello world!&lt;/span&gt;  &lt;div class=&quot;icon3&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle3{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon3{        position: absolute;        left:70%;        top:93%;        width: 30px;        height: 30px;        background-color: #f5a0bd;        transform: rotate(45deg);    }</code></pre><h4 id="species-in-pieces"><a href="#species-in-pieces" class="headerlink" title="species-in-pieces"></a>species-in-pieces</h4><p>先给你看个网站：<a href="http://species-in-pieces.com/#" target="_blank" rel="external">传送门</a>，你会不会和我第一次看到的那样一样惊叹。怎么可以实现这么炫酷的效果。<br>今天我就来讲讲这是咋实现的。<br><img src="http://i.imgur.com/99XETlr.png" alt=""><br>拿这个动物来说，你会发现这些图形都是由30个如下的代码组成。每个shard的宽高都是100%，他们都是position：absolute。</p><p>  <div class="shard-wrap"></div></p><pre><code>&lt;div class=&quot;shard&quot;&gt;&lt;/div&gt;</code></pre><p>  <br>也就是说其实这些图形都是堆叠在一起的他们的宽高都是100%是为了响应式~他们的样式是同个nth-child(n)来实现的，例如：</p><p>   //child one<br>  .shard-wrap:nth-child(1) .shard {</p><pre><code>-webkit-clip-path: polygon(11.1% 81.286%, 13.9% 80.286%, 13.9% 74.429%);        clip-path: polygon(11.1% 81.286%, 13.9% 80.286%, 13.9% 74.429%);background-color: #262327;-webkit-transition-delay: 0.02s;        transition-delay: 0.02s;</code></pre><p>  }<br>   //child two<br>  .shard-wrap:nth-child(2) .shard {</p><pre><code>-webkit-clip-path: polygon(9.6% 71.3%, 11.2% 81.2%, 13.95% 74.571%);        clip-path: polygon(9.6% 71.3%, 11.2% 81.2%, 13.95% 74.571%);background-color: #3C3642;-webkit-transition-delay: 0.04s;        transition-delay: 0.04s;</code></pre><p>  }<br>这样就可以控制每个三角形的样式和颜色。最后组合成为这个图形。你会发现这真没啥难得，想要hover这个图片的时候变化成另外一个动物比方说这个<br><img src="http://i.imgur.com/Pf8WLgN.png" alt=""><br>只需要给每个shard命名的class再加上一个hover的新样式就可：<br><img src="http://i.imgur.com/TENe2KI.png" alt=""><br>这样的直接变化可能会太突然，所以你可以给所有的shard加上一个transition</p><pre><code>-webkit-transition: all 1s;transition: all 1s;</code></pre><p>然后给每个shard加上不同时间的延迟动画，这样就好变的很好了。我写的<a href="https://yaoyue1.github.io/clip_path/last.html" target="_blank" rel="external">demo</a>点击一下第一个动物出现，点击两下第二个动物出现。</p></li></ul><p>也许你也会觉得这确实很简单，但是这些shard的polygon后的裁剪数据是怎样得来的，那我就要告诉你算的的！！就是算出来的。我也觉得真是复杂~所以我觉得真的需要一个强大的设计师~这是一个灵感满满的设计和动效。这些数据是需要事先提取出来的~</p><h4 id="写几个小动画"><a href="#写几个小动画" class="headerlink" title="写几个小动画"></a>写几个小动画</h4><p><a href="https://yaoyue1.github.io/clip_path/littleicon.html" target="_blank" rel="external">demo</a><br>是不是觉得你小瞧了clip-path这个属性了。当初我也是以为他只能裁剪一下图片而已的。</p><p><img src="http://i.imgur.com/ws4s1hb.png" alt=""></p><p>这个动画有一个点需要注意的是：这些字母都是通过一个div裁剪的例如第二个字母K，它是由12个顶点所组成的，所以你的div从刚开始就必须由12个点组成，不然浏览器咋知道你要重一个长方形的div变成是一个字母K，所以这里就存在一条件：动画在一定条件下可以对clip-path生效 . 这里的一定条件即裁剪的多边形必须具有相同的顶点数。</p><p>这里就算是讲完clip-path的前四个基本属性了，把最后一个与SVG相引用的属性方最后讲是因为我最喜欢这个属性了，可好玩了~</p><h3 id="clip-path与SVG配合"><a href="#clip-path与SVG配合" class="headerlink" title="clip-path与SVG配合"></a>clip-path与SVG配合</h3><p>先上张图：</p><p><img src="http://i.imgur.com/lzqH2O7.png" alt=""></p><p>是不是超级美，我可是用代码写不出来这路径的，但是SVG可以。<br>clip-path的最后一个属性是-webkit-clip-path: url(#svgTextPath);url中间引用的是一段SVG的路径。当然我还不会写，但是我知道咋弄，，哈哈哈，来推荐一个<a href="http://www.yyyweb.com/ctools/demo.php?t=http%3A%2F%2Feditor.method.ac%2F&amp;h=2000&amp;c=&amp;n=" target="_blank" rel="external">网站</a>这是一个SVG的在线编辑器</p><p><img src="http://i.imgur.com/SRgETH7.png" alt=""></p><p>我框的这个是用来画路径的</p><ol><li><p>我先画两个<br><img src="http://i.imgur.com/QnUqTGh.png" alt=""></p></li><li><p>然后把这个文件保存为SVG，把这个svg用你的编辑器打开，你会发现他记录了一长串的路径~我们需要的就是这段路径，把它copy下来。像这样放到你的html的body中</p><pre><code>&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;    &lt;svg height=&quot;0&quot; width=&quot;0&quot;&gt;   &lt;defs&gt;       &lt;clipPath id=&quot;svgTextPath&quot;&gt;           //你copy的路径        &lt;/clipPath&gt;   &lt;/defs&gt;&lt;/svg&gt;    </code></pre><p>img的图片换成你自己喜欢的,然后给这个图片加上-webkit-clip-path: url(#svgTextPath)的属性，你想要的效果就出现啦啦啦~</p></li></ol><p><img src="http://i.imgur.com/3ffWx4p.png" alt=""></p><p>是不是很好看~</p><p>最后的最后我要对你说，你真的好厉害~居然看到这里了。我自己都不忍心写到这里的，哈哈哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  公司前端的技术分享轮到我了，有点小迷茫，不知道该讲什么，纠结来纠结去，偶然看到了腾讯全端 AlloyTeam团队的一篇博文分享，是关于clip-path的，虽然写的比较简单（也可能是我的level还没有达到辣么个水平,完全不能理解）但是真的被那个炫酷的动画给迷倒了。就想一探究竟，然后讲讲这个。（其实最主要我还是觉得这个属性大家平时用到的不多，可能很多人也不是特别了解，作为一个实习生去讲给一堆大牛听这种偏冷门的属性是最合适不过了，哈哈哈，小心机一下）正式开始写啦啦~&lt;/p&gt;
&lt;h3 id=&quot;clip-path基本属性&quot;&gt;&lt;a href=&quot;#clip-path基本属性&quot; class=&quot;headerlink&quot; title=&quot;clip-path基本属性&quot;&gt;&lt;/a&gt;clip-path基本属性&lt;/h3&gt;&lt;p&gt;clip-path一共有四个基本的属性裁剪再加上一个可以直接引用SVG的属性算是五个吧。前面四个基本的是polygon（多边形），circle（圆形），ellipse（椭圆）、inset（圆弧）。下面先开始说这四个属性：&lt;/p&gt;
&lt;h4 id=&quot;裁剪多边形&quot;&gt;&lt;a href=&quot;#裁剪多边形&quot; class=&quot;headerlink&quot; title=&quot;裁剪多边形&quot;&gt;&lt;/a&gt;裁剪多边形&lt;/h4&gt;&lt;p&gt;&lt;pre&gt;&lt;br&gt;-webkit-clip-path: polygon(0 25%,25% 0,75% 0,100% 25%,100% 75%,75% 100%,25% 100%,0 75%);&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CSS3" scheme="http://yaoyue.com/categories/CSS3/"/>
    
    
      <category term="CSS3" scheme="http://yaoyue.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃（三）</title>
    <link href="http://yaoyue.com/2017/02/20/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/02/20/vue入门到放弃（三）/</id>
    <published>2017-02-20T03:12:42.000Z</published>
    <updated>2017-02-21T07:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p> 上两篇关于Vue的博文，一篇是环境的搭建和运行，另一篇是自己回顾之前所学的基本指令。这些准备完毕之后，也是时候来写demo练手了，不然好像一直看文档看API也没啥作用，开始啦，自己一边写demo一边把重要的部分记录下来吧。<br> <a id="more"></a></p><h3 id="新建项目文件夹"><a href="#新建项目文件夹" class="headerlink" title="新建项目文件夹"></a>新建项目文件夹</h3><p>通过Vue init webpack searchdemo新建一个项目。<br><img src="http://i.imgur.com/6352VQQ.png" alt=""><br>进入项目文件：cd searchdemo</p><p>安装项目依赖：cnpm install</p><p>运行项目：npm run dev</p><h3 id="划分目录结构"><a href="#划分目录结构" class="headerlink" title="划分目录结构"></a>划分目录结构</h3><p>这个demo是一个切换搜索浏览器的页面，所以可以划分成一个logo选择的组件和一个搜索面板的组件。目录结构如下：static用于存放静态资源</p><p><img src="http://i.imgur.com/INUMDFO.png" alt=""></p><p>目录结构划分好后App.Vue就可以把连个组件引进来了，但是考虑到logo选择的组件是需要和下面的搜索面板的组件通信的，所以我没有把这个两个组件同时进入到app.vue中而是把logo组件引入到搜索面板组件中，最后再把搜索面板组件引入到APP.Vue中。</p><h3 id="组件logoSelect编写"><a href="#组件logoSelect编写" class="headerlink" title="组件logoSelect编写"></a>组件logoSelect编写</h3><p>在logo组件编写的时候需要注意的点：</p><h4 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h4><p>v-cloak：在使用vuejs、angularjs开发时，经常会遇见在如Chrome这类能够快速解析的浏览器上出现表达式( ),或者是模块(div)的闪烁。对于这个问题由于JavaScript去操作DOM，都会等待DOM加载完成（DOM ready）。对于vuejs、angularjs这些会在DOM ready完会才回去解析html view Template，所以对于Chrome这类快速的浏览器你会看见有闪烁的情况出现。而对于IE7，8这类解析稍慢的浏览器大部分情况下是不会出现这个问题的。</p><h3 id="向父组件传递参数"><a href="#向父组件传递参数" class="headerlink" title="向父组件传递参数"></a>向父组件传递参数</h3><p><img src="http://i.imgur.com/qMDTjFc.png" alt=""><br>使用$emit()像父组件即搜索面板传递参数。触发父组件的自定义事件，向父组件传参数,selectNow是选择了哪个搜索引擎的索引，父组件得到了之后就可以指定搜索时跳转到哪个搜索引擎。父子组件通信可以看vue文档 组件那一章</p><h3 id="组件searchPanel的编写"><a href="#组件searchPanel的编写" class="headerlink" title="组件searchPanel的编写"></a>组件searchPanel的编写</h3><p><img src="http://i.imgur.com/hcx4oWQ.png" alt=""><br>组件搜索面板需要利用jsonp进行跨域请求，所以必须按照网络请求模块 vue-resource</p><p><pre><br>cnpm install  vue-resource –save<br></pre><br>并在main.js中使用</p><p><pre><br>var vueResource = require(‘vue-resource’);<br>Vue.use(vueResource);<br></pre><br>否则会报不认识jsonp属性的错误。</p><p>最后放上GitHub源码地址：<a href="https://github.com/yaoyue1/Vue-" target="_blank" rel="external">https://github.com/yaoyue1/Vue-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 上两篇关于Vue的博文，一篇是环境的搭建和运行，另一篇是自己回顾之前所学的基本指令。这些准备完毕之后，也是时候来写demo练手了，不然好像一直看文档看API也没啥作用，开始啦，自己一边写demo一边把重要的部分记录下来吧。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router(上)</title>
    <link href="http://yaoyue.com/2017/02/17/vue-router-%E4%B8%8A/"/>
    <id>http://yaoyue.com/2017/02/17/vue-router-上/</id>
    <published>2017-02-17T08:59:58.000Z</published>
    <updated>2017-02-17T09:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>接触了点Vue后，自己屁颠屁颠去搜索一些实例的来看，结果各种出现Vue-router，尼玛这又是干嘛的？？？（黑人问号脸），于是去Vue-router的官方文档上瞅瞅，遂写了这篇笔记式的博文。</p><h3 id="vue-router是干嘛的？"><a href="#vue-router是干嘛的？" class="headerlink" title="vue-router是干嘛的？"></a>vue-router是干嘛的？</h3><p>Vue-router是Vue.js的官方路由插件，Vue的单页面应用是基于路由和组件的，路由用于设定访问的路径，并将路径和组件映射起来。之前我们写项目的时候，页面之前的切换时和跳转是通过超链接等来实现的，在Vue-router单页面应用中，则是通过路径的切换。<br><a id="more"></a></p><h3 id="使用基本步骤"><a href="#使用基本步骤" class="headerlink" title="使用基本步骤"></a>使用基本步骤</h3><ol><li>导入文件<br><pre><br>// 导入Vue，这个是必需的，在使用Vue之前，必须先导入<br>import Vue from ‘vue’<br>// 导入 vue-router，并使用<br>import VueRouter from ‘vue-router’<br>Vue.use(VueRouter) </pre></li></ol><hr><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><ol><li><p>定义路由组件。可以从其他文件import进来</p><pre>const Foo = { template: '<div>foo</div>' }const Bar = { template: '<div>bar</div>' }</pre></li><li><p>配置路由</p><pre>const routes = [   {       path: '/foo',       component: Foo   },   {       path: '/bar',       component: Bar   }  ] </pre></li><li>创建router实例<pre>const router = new VueRouter({   routes  // （缩写）相当于 routes: routes})</pre></li><li>创建和挂载根实例<br><pre><br>// 记得要通过 router 配置参数注入路由，<br>// 从而让整个应用都有路由功能<br>const app = new Vue({<br>router<br>}).$mount(‘#app’)//$mount是在Vue实例在实例化的时候没有收到el选项处于“未挂载”状态时手动挂载。<br></pre><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3>定义：使用 <strong>动态路径参数</strong> 把某种模式下匹配到的所有的路由，全部都映射到同一个组件。<h4 id="example-one"><a href="#example-one" class="headerlink" title="example one"></a>example one</h4><pre><br>const User = {<br>template: ‘<div>User</div>‘<br>}</pre></li></ol><p>const router = new VueRouter({<br>  routes: [<br>    // 动态路径参数 以冒号开头<br>    { path: ‘/user/:id’, component: User }<br>  ]<br>})<br></p><h4 id="example-two"><a href="#example-two" class="headerlink" title="example two"></a>example two</h4><p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用,例如我们可以在user模板中输出当前的用户id.同时可以在一个路由中设置多段【路由参数】，对应的值都会在￥route。params中。</p><pre>const User={   template: '<div>User </div>'}</pre><pre>const User = {  template: '<div>User +</div>'}const router = new VueRouter({  routes: [    // 动态路径参数 以冒号开头    { path: '/user/:id/post/:usename', component: User }  ]})</pre><h4 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h4><p>有时，同一个路径可以匹配对个路由，这时，匹配的优先级就会按照路由的定义顺序来：谁先定义的，谁的优先级就最高。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p><router-link> 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的a标签，可以通过配置 tag 属性生成别的标签。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</router-link></p><p><em>router-link比a链接好的原因在于：</em></p><ol><li>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动 关于history 模式、hash 模式讲解，点击<a href="http://blog.csdn.net/hyy1115/article/details/53021807" target="_blank" rel="external">这里</a></li><li>在h5 history模式下，router-link会拦截点击事件，让浏览器不在重新加载页面</li><li>在h5 history模式下使用base选项后，所有的to属性都不需要写基路径了。</li></ol><p>router-link的属性</p><h4 id="to属性"><a href="#to属性" class="headerlink" title="to属性"></a>to属性</h4><p>表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，这个值可以是一个字符串或者是描述目标位置的对象。<br><img src="http://i.imgur.com/s8Z3lij.png" alt=""></p><h4 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h4><p>如果设置了replace属性的话会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;/abc&apos;&#125;&quot; replace&gt; &lt;/router-link&gt;</div></pre></td></tr></table></figure><h4 id="append属性"><a href="#append属性" class="headerlink" title="append属性"></a>append属性</h4><p>设置 append 属性后，则在当前（相对）路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;relative/path&apos;&#125;&quot; append&gt;&lt;/router-link&gt;</div></pre></td></tr></table></figure></p><h4 id="tag属性"><a href="#tag属性" class="headerlink" title="tag属性"></a>tag属性</h4><p>有时候想要 <router-link> 渲染成某种标签，例如li于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;</div><div class="line">&lt;li&gt;foo&lt;/li&gt;</div></pre></td></tr></table></figure></router-link></p><h4 id="active-class属性"><a href="#active-class属性" class="headerlink" title="active-class属性"></a>active-class属性</h4><p>设置 链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。</p><h4 id="exact属性"><a href="#exact属性" class="headerlink" title="exact属性"></a>exact属性</h4><p>“是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 <router-link to="/a"> 也会被设置 CSS 类名。</router-link></p><h4 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h4><p>声明可以用来触发导航的事件，可以是一个字符串或者是一个包含字符串的数组</p><h4 id="激活时的CSS类名应用在外层元素"><a href="#激活时的CSS类名应用在外层元素" class="headerlink" title="激活时的CSS类名应用在外层元素"></a>激活时的CSS类名应用在外层元素</h4><p>有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 \<a> 标签本身，那么可以用 <router-link> 渲染外层元素，包裹着内层的原生 \<a> 标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt;</div><div class="line">  &lt;a&gt;/foo&lt;/a&gt;</div><div class="line">&lt;/router-link&gt;</div></pre></td></tr></table></figure></a></router-link></a></p><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p>router-view组件是用来渲染路径匹配到的视图组件的，router-view渲染的组件还可以内嵌到自己的router-view，根据嵌套路径，渲染嵌套组件。</p><p>包含的属性:name属性，string类，默认值为default<br>如果router-view设置了名称，则会渲染对应的路由配置中的components下的相应组件<br><img src="http://i.imgur.com/E5J3a4Y.png" alt=""></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>在模板中再嵌套router-view，在配置路由时必须使用children来配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const User = &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div class=&quot;user&quot;&gt;</div><div class="line">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</div><div class="line">      &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre>const routes: [    { path: '/user/:id', component: User,      children: [        {          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 <router-view> 中          path: 'profile',          component: UserProfile        },        {          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 <router-view> 中          path: 'posts',          component: UserPosts        }      ]    }  ]const router = new VueRouter({  routes})</router-view></router-view></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><h4 id="router-push-location"><a href="#router-push-location" class="headerlink" title="router.push(location)"></a>router.push(location)</h4><p>router.push(location)方法等同于<router-link :to="...">这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL</router-link></p><h4 id="router-replace-location"><a href="#router-replace-location" class="headerlink" title="router.replace(location)"></a>router.replace(location)</h4><p>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><pre>声明式：<router-link :to="..." replace="">编程式：router.replace(...)</router-link></pre>#### router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)<pre>// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)</pre><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><pre><router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link></pre>### 命名视图![](http://i.imgur.com/E5J3a4Y.png)### 重定向和别名『重定向』的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b通过routes的配置来完成。* 重定向到页面<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: '/b' }  ]})</pre>* 重定向到命名路由<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: { name: 'foo' }}  ]})</pre>* 可以是一个方法，动态的重定向到目标<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: to => {      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    }}  ]})</pre><p>『别名』的意思是：/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p><p>看到这的时候，公司网速出问题了，已经打不开外网了，正好基础的部分算是已经学习完了，那么后面的进阶就下次来写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触了点Vue后，自己屁颠屁颠去搜索一些实例的来看，结果各种出现Vue-router，尼玛这又是干嘛的？？？（黑人问号脸），于是去Vue-router的官方文档上瞅瞅，遂写了这篇笔记式的博文。&lt;/p&gt;
&lt;h3 id=&quot;vue-router是干嘛的？&quot;&gt;&lt;a href=&quot;#vue-router是干嘛的？&quot; class=&quot;headerlink&quot; title=&quot;vue-router是干嘛的？&quot;&gt;&lt;/a&gt;vue-router是干嘛的？&lt;/h3&gt;&lt;p&gt;Vue-router是Vue.js的官方路由插件，Vue的单页面应用是基于路由和组件的，路由用于设定访问的路径，并将路径和组件映射起来。之前我们写项目的时候，页面之前的切换时和跳转是通过超链接等来实现的，在Vue-router单页面应用中，则是通过路径的切换。&lt;br&gt;
    
    </summary>
    
      <category term="Vue-router" scheme="http://yaoyue.com/categories/Vue-router/"/>
    
    
      <category term="vue-router" scheme="http://yaoyue.com/tags/vue-router/"/>
    
  </entry>
  
</feed>
