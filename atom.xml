<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiemo blog</title>
  
  <subtitle>前端开发/学生/菜鸟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaoyue.com/"/>
  <updated>2017-10-27T06:30:59.000Z</updated>
  <id>http://yaoyue.com/</id>
  
  <author>
    <name>芥末</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>怂过了丧过了就好好努力活～</title>
    <link href="http://yaoyue.com/2017/10/27/%E6%80%82%E8%BF%87%E4%BA%86%E4%B8%A7%E8%BF%87%E4%BA%86%E5%B0%B1%E5%A5%BD%E5%A5%BD%E5%8A%AA%E5%8A%9B%E6%B4%BB%EF%BD%9E/"/>
    <id>http://yaoyue.com/2017/10/27/怂过了丧过了就好好努力活～/</id>
    <published>2017-10-27T06:17:47.000Z</published>
    <updated>2017-10-27T06:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28283305&auto=1&height=66"></iframe><br>&emsp;&emsp;不知道什么时候开始活的小心翼翼，一个人在一座城市的人可能大都和我一样吧，习惯于把自己最好的展现出来，把沮丧落寞这些负面的情绪埋在自己内心，不敢轻易对人说起。其实也是无从说起，或者说根本就没有倾诉的对象，对父母讲，太多的负面情绪可能更会引起他们的担心，对姐姐讲，但是她没有经历我所经历的，很多时候也无法明白我的内心，对闺蜜讲，我又觉得把负能量传递别人是一种不好的行为，我也不希望我是这种人。所以很多的时候，当我有想倾诉的那种想法时我都会把它压制下来，现在更习惯于用键盘把它敲出来，慢慢的写，慢慢的敲，也算讲给自己听吧。有时想想觉得很好笑，初中高中的时候被老师逼迫天天写日记都没有养成一个写日记的习惯，反倒是在离开学校后，主动的想去把内心的一些东西写出来了。<br><a id="more"></a><br>&emsp;&emsp;最近发生在身上最大的两件事一个是搬家，一个是最近接的项目。搬家总算也是尘埃落定了，回头想想的时候好像也没觉得有什么不容易的。连续三天看房，买打包袋打包到凌晨，联系搬家公司，搬进新住处，开始一件件的整理到傍晚，最好还在傍晚的时候和闺蜜出去吃了川炉的火锅。一切都很顺其自然，井井有条，其实也没有很艰难嘛～但是内心最不舍的算是原来小区的环境，到处的桂花香味，过条马路就到的浙大。深夜再晚夜跑也能随处可见的保安，只是就像你喜欢的人不喜欢你一样，单方面的情愿是没有用的。索性搬进来的地方，房间我很喜欢，有我最爱的吧台桌。虽然经常加班到深夜，它看起来也没有什么用处。<br>&emsp;&emsp;再说说另外一件事情，就是最近手上的项目。比较复杂，算是我来公司接的最复杂的一个项目了吧，刚开始没有想清楚逻辑结构就开始写了页面了，导致后面写逻辑的时候无从下手，有只得重新整理页面结构，后面的逻辑也费了很大的功夫。后台对接既需要和php对接也需要和java对接，调接口的时候我又不是很熟悉，所以浪费了很多的时间，很感激点滴，这么帮我，有时候写的真的想哭，周末加班，连续一周每天加班到11点，所以以后一定要努力一点好不好，这样没错遇到问题就不需要寻求他人的帮助了，也不会坑到别人了，我真的不是一个很喜欢麻烦别人的人，也很怕麻烦别人，所以也是一个别人对我好一点我就能感激到不行的人。<br>&emsp;&emsp;最近负能量满满的，周末打算去骑行，断了一段时间的画画也会捡起来。我只是想证明自己可以一个人过的很好！ 夜深了，晚安～～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=28283305&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;&amp;emsp;&amp;emsp;不知道什么时候开始活的小心翼翼，一个人在一座城市的人可能大都和我一样吧，习惯于把自己最好的展现出来，把沮丧落寞这些负面的情绪埋在自己内心，不敢轻易对人说起。其实也是无从说起，或者说根本就没有倾诉的对象，对父母讲，太多的负面情绪可能更会引起他们的担心，对姐姐讲，但是她没有经历我所经历的，很多时候也无法明白我的内心，对闺蜜讲，我又觉得把负能量传递别人是一种不好的行为，我也不希望我是这种人。所以很多的时候，当我有想倾诉的那种想法时我都会把它压制下来，现在更习惯于用键盘把它敲出来，慢慢的写，慢慢的敲，也算讲给自己听吧。有时想想觉得很好笑，初中高中的时候被老师逼迫天天写日记都没有养成一个写日记的习惯，反倒是在离开学校后，主动的想去把内心的一些东西写出来了。&lt;br&gt;
    
    </summary>
    
      <category term="生活杂记" scheme="http://yaoyue.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="生活杂记" scheme="http://yaoyue.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>three.js初始（一）</title>
    <link href="http://yaoyue.com/2017/10/13/three-js%E5%88%9D%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/10/13/three-js初始（一）/</id>
    <published>2017-10-13T06:02:15.000Z</published>
    <updated>2017-10-16T06:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="三大组建"><a href="#三大组建" class="headerlink" title="三大组建"></a>三大组建</h3><pre><code>渲染物体到网页所需的三大组建：场景（scene）、相机（camera）和渲染器（renderer）场景：var scene = new THREE.Scene();相机： var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);渲染器：var renderer = new THREE.WebGLRenderer();        renderer.setSize(window.innerWidth, window.innerHeight);        document.body.appendChild(renderer.domElement);</code></pre><p>场景=》相机=》渲染器=》添加物体到场景中=》渲染=》渲染循环<br><a id="more"></a><br>芥末</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三大组建&quot;&gt;&lt;a href=&quot;#三大组建&quot; class=&quot;headerlink&quot; title=&quot;三大组建&quot;&gt;&lt;/a&gt;三大组建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;渲染物体到网页所需的三大组建：场景（scene）、相机（camera）和渲染器（renderer）
场景：var scene = new THREE.Scene();
相机： var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
渲染器：var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;场景=》相机=》渲染器=》添加物体到场景中=》渲染=》渲染循环&lt;br&gt;
    
    </summary>
    
      <category term="three.js" scheme="http://yaoyue.com/categories/three-js/"/>
    
    
      <category term="three.js" scheme="http://yaoyue.com/tags/three-js/"/>
    
  </entry>
  
  <entry>
    <title>所以等我好不好</title>
    <link href="http://yaoyue.com/2017/10/13/10%E6%9C%88%E6%9C%88%E5%88%9D/"/>
    <id>http://yaoyue.com/2017/10/13/10月月初/</id>
    <published>2017-10-13T03:17:49.000Z</published>
    <updated>2017-10-27T06:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36496726&auto=0&height=66"></iframe><br>&emsp;&emsp;来杭州还不到一年的时间，马上就要搬进第三个小窝了，其实挺喜欢现在住的这个的，小区环境很好，夜晚再晚下班回家都能看到保安，晚上楼下夜跑也很方便，侧门出去过一条马路就到了浙大，偶尔一个人去晃荡一下，假装自己还在大学。尤其是喜欢这几天，满小区的桂花树都开了，格外的好闻~但是再喜欢也无奈要搬走了，就像你再喜欢的人不喜欢你一样~</p><p>&emsp;&emsp;前晚签了新住单间的合同，房东人很好，这次终于不再是二房东了，应该也不会遇到像现在这样被赶走的情景吧~。还没开始打包，打算找个搬家公司吧，一个人搬家应该是孤独等级的第九级了，哈哈~，上一个住的哥哥，人很好，把我最喜欢的吧台桌免费送给我了，所以在遇到坏人的同时是不是也是会遇到好人的~等搬完家再来更新！<br><a id="more"></a><br>搬完家，已经全部收拾好了，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=36496726&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;&amp;emsp;&amp;emsp;来杭州还不到一年的时间，马上就要搬进第三个小窝了，其实挺喜欢现在住的这个的，小区环境很好，夜晚再晚下班回家都能看到保安，晚上楼下夜跑也很方便，侧门出去过一条马路就到了浙大，偶尔一个人去晃荡一下，假装自己还在大学。尤其是喜欢这几天，满小区的桂花树都开了，格外的好闻~但是再喜欢也无奈要搬走了，就像你再喜欢的人不喜欢你一样~&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前晚签了新住单间的合同，房东人很好，这次终于不再是二房东了，应该也不会遇到像现在这样被赶走的情景吧~。还没开始打包，打算找个搬家公司吧，一个人搬家应该是孤独等级的第九级了，哈哈~，上一个住的哥哥，人很好，把我最喜欢的吧台桌免费送给我了，所以在遇到坏人的同时是不是也是会遇到好人的~等搬完家再来更新！&lt;br&gt;
    
    </summary>
    
      <category term="生活杂记" scheme="http://yaoyue.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="生活杂记" scheme="http://yaoyue.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>opacity应用~</title>
    <link href="http://yaoyue.com/2017/09/28/opacity%E5%BA%94%E7%94%A8/"/>
    <id>http://yaoyue.com/2017/09/28/opacity应用/</id>
    <published>2017-09-28T07:41:35.000Z</published>
    <updated>2017-10-13T03:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>首先讲一个悲伤的话题，手机摔坏了… 是的，我又把屏幕给摔坏了（都想揍我自己了），上下班钉钉打卡都打不了了，然后因为屏幕已经没法点击了，所以存在一起手机屏幕里的手机联系人都取不出来了，所以到现在我只记得我爸妈手机号码了~~，昨天摔坏后，就纠结的要死，到底该买哪款手机，本来还是想买个安卓机的，但看来看去不知道买哪款，最后想着又想快点到，所以就决定了在京东上买了苹果6splus.好了，这个话题收~要总结了。<br><a id="more"></a><br>今天刚写完一个项目，<a href="http://h5.in66.com/inpromo/2017/mid-autumn/loading.html" target="_blank" rel="external">地址</a>：<a href="http://h5.in66.com/inpromo/2017/mid-autumn/loading.html，之前拿到这个项目的时候，还以为是需要用到canvas合成的，结果到最后发现根本不需要，是的根本不需要，白高兴了。好像也没有啥难点，唯一，让我有点有必要说说的地方就是opacity的应用。" target="_blank" rel="external">http://h5.in66.com/inpromo/2017/mid-autumn/loading.html，之前拿到这个项目的时候，还以为是需要用到canvas合成的，结果到最后发现根本不需要，是的根本不需要，白高兴了。好像也没有啥难点，唯一，让我有点有必要说说的地方就是opacity的应用。</a></p><p>这个项目是在in内和微信端都要可以玩，所以结果页保存的图片是和展示的结果不一样的，结果页长按保存图片，在in内有走in的协议，但是在微信端却不行，手机能够保存图片，一般是保存的img标签的图片，但是由于结果展示的图片不能和你保存到手机里的一样，所以就必须在微信端做处理，是的，用一个img标签叠在展示的img标签上面，可以看到图中有2个，上面的那个给个opac为0，然后你长按保存的其实就是opacity为0的那张图片了，之前一直没想到要这样做，后面发现这样做是不是超级赞。完了~就这些了。</p><p><img src="https://i.imgur.com/8qGol5o.jpg" alt=""></p><p>写在最后：<br>决定把这个博客不仅仅是当做分享技术的博客了，以后会慢慢分享一些生活上的事情，感触或者是心情吧，就把它当做一个记录的秘密基地吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//yaoyue1.github.io/guang.m4a"></iframe><p>最近超级超级喜欢这首歌，跑步5.7公里单曲循环了这首歌，已经完全被洗脑了，天天上班听。带着耳机，听着这首歌，晚上下班，骑个摩拜，一路上的桂花香味，心情很好。<br>这个季节最喜欢的就是桂花了~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先讲一个悲伤的话题，手机摔坏了… 是的，我又把屏幕给摔坏了（都想揍我自己了），上下班钉钉打卡都打不了了，然后因为屏幕已经没法点击了，所以存在一起手机屏幕里的手机联系人都取不出来了，所以到现在我只记得我爸妈手机号码了~~，昨天摔坏后，就纠结的要死，到底该买哪款手机，本来还是想买个安卓机的，但看来看去不知道买哪款，最后想着又想快点到，所以就决定了在京东上买了苹果6splus.好了，这个话题收~要总结了。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>项目遇坑总结（二）——nextTick及事件循环理解</title>
    <link href="http://yaoyue.com/2017/09/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%9D%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8BnextTick/"/>
    <id>http://yaoyue.com/2017/09/13/项目遇坑总结（一）——初始nextTick/</id>
    <published>2017-09-13T03:13:12.000Z</published>
    <updated>2017-09-15T10:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  此次是在做公司福利社项目的时候遇到的问题，<a href="https://fuli.in66.com" target="_blank" rel="external">链接</a>,可能你点开的时候并没有看到banner，那是因为有时候后台是没有数据的。上线的第一版，swiper是没有问题，因为整个页面的显示是通过后端一个接口传过来的数据，在created中请求接口，在mouted中实例化swiper，并没有出现问题。页面上线后工作的很好，后面后端跟我说他们需要分离接口，因为banner的代码需要要监测什么的，然后我就被忽悠去改了，因为在我觉得，就在created中多加一个 fetch请求嘛，连数据结构都一样，很简单的，所以我连上webtest测试都没有测试就直接上线了，结果到了线上就出现了今天要讲的问题，swiper他罢工了，滑不动了。<br><a id="more"></a></p><h4 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h4><p>swiper之所以会罢工，是因为mouted实例化swiper的时候，swiper的数据并没有加载好，swiper实例化的时候是需要去扫描swiper-wraper中的slide的个数的，也就是说数据没有返回你就去实例化了。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用Vue.nextTick方法，在数据返回成功后，等待dom更新完毕后再调用swiper的实例化方法。</p><pre><code>&lt;script&gt;   mouted () {        fetch(location.protocol + `//www.in66.com/webview/user/incoinbanner?` + location.search.split(&apos;?&apos;)[1], {           method: &apos;GET&apos;,           credentials: &apos;include&apos;,        }).then(response =&gt; {            response.json().then(res =&gt; {               if (res.succ) {                   this.banners = res.data                   Vue.nextTick(()=&gt;{ //dom更新完毕调用swiper实例化方法                      this.initSwiper()                   })                }            })        })   }&lt;/script&gt;</code></pre><h4 id="关于nextTick"><a href="#关于nextTick" class="headerlink" title="关于nextTick()"></a>关于nextTick()</h4><p>vue官方文档上写的用法是：在下次dom更循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的dom<br>由于vue的数据驱动视图更新是异步的，所以修改数据的当下，视图是不会立马更新的，而是要等到同一事件循环中的所有数据发生变化完成后，再统一的进行视图更新。所谓事件循环，就是指Javascript的事件执行机制，主线程执行完了执行栈中的所有同步任务之后，才会去读取任务队列，任务队列是一个先进先出的队列，所有主线程会提取队手的任务放入主线程中去执行，执行完毕后，再去读取任务队列的首个任务。主线程不断重复这个过程，所有称为事件循环。<br>   所以这里nextTick的触发是，同一事件循环的代码执行完毕 =&gt; dom更新 =&gt; nextTick callback触发</p><p>备注：<br>阮一峰老师的这篇事件循环的文字讲的甚好推荐：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  此次是在做公司福利社项目的时候遇到的问题，&lt;a href=&quot;https://fuli.in66.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;,可能你点开的时候并没有看到banner，那是因为有时候后台是没有数据的。上线的第一版，swiper是没有问题，因为整个页面的显示是通过后端一个接口传过来的数据，在created中请求接口，在mouted中实例化swiper，并没有出现问题。页面上线后工作的很好，后面后端跟我说他们需要分离接口，因为banner的代码需要要监测什么的，然后我就被忽悠去改了，因为在我觉得，就在created中多加一个 fetch请求嘛，连数据结构都一样，很简单的，所以我连上webtest测试都没有测试就直接上线了，结果到了线上就出现了今天要讲的问题，swiper他罢工了，滑不动了。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信</title>
    <link href="http://yaoyue.com/2017/08/01/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yaoyue.com/2017/08/01/vue组件通信/</id>
    <published>2017-08-01T03:49:40.000Z</published>
    <updated>2017-09-13T07:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>学习Vue算是有一段时间了，期间公司的项目开发流程也全换成了Vue了，自己也是接了几个Vue的项目了，不过总感觉，知道的不是特别多，每次做起项目也总会遇到这样或者是那样的问题，这次总结一下项目中用到的比较频繁的组件之间的通信。</p><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>props方式：<br><a id="more"></a><br>父组件当中的nearbyData传递给子组件</p><pre><code>&lt;nearby :nearbyDate=&quot;nearbyDate&quot; :key=&quot;idx&quot; v-for=&quot;(nearbyDate,idx) in nearbyItems&quot;&gt;&lt;/nearby&gt;</code></pre><p>子组件中通过声明props后使用父组件传递过来的nearbyData来进行页面的渲染</p><pre><code> &lt;div class=&quot;left-box&quot; @click=&quot;openinji(nearbyDate.user_id)&quot;&gt;    &lt;img :src=&quot;nearbyDate.self_url&quot;/&gt;    &lt;div class=&quot;name&quot; :class=&quot;{name_xia:nearbyDate.label.length &gt; 0 ? false:true}&quot;&gt;{{nearbyDate.name}}&lt;/div&gt;    &lt;div class=&quot;label-box&quot;&gt;        &lt;p class=&quot;label&quot; :key=&quot;idx&quot; v-for=&quot;(labelintro,idx) in nearbyDate.label&quot;&gt;{{labelintro}}&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>$emit方式</p><p>子组件通过$emit像父组件传递一个自定义事件和一个参数</p><pre><code>&lt;template&gt;   &lt;div class=&quot;box&quot; @click=&quot;sendMessage&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {   methods: {      sendMessage () {        this.$emit(&apos;listen&apos;, &apos;data&apos;)      }   }}&lt;/script&gt;</code></pre><p>在父组件的子组件标签中监听该自定义事件，并且用一个对应的方法来处理事件</p><pre><code> &lt;template&gt;   &lt;div class=&quot;wrap&quot;&gt;    &lt;child :sendMessage=&quot;handleMessage&quot;&gt;&lt;/child&gt;    &lt;/div&gt; &lt;template&gt;&lt;script&gt;export default {  methods: {    handleMessage (data) {        console.log(data)    }  }}&lt;/script&gt;</code></pre><p>总结上述，即可以得出，父传子是通过props属性来传值，子传父则是通过自定义事件。</p><h3 id="子传子"><a href="#子传子" class="headerlink" title="子传子"></a>子传子</h3><p>中央事件总线，也称为事件巴士，听名字就知道是一个担任组件与组件之间通信介质的东西。</p><h4 id="创建eventBus"><a href="#创建eventBus" class="headerlink" title="创建eventBus"></a>创建eventBus</h4><p>创建一个名为eventBus.js的文件，新建一个Vue实例<br>      import Vue from ‘Vue’<br>      export default new Vue</p><h4 id="子组件中引入eventBus，传入自定义事件和参数"><a href="#子组件中引入eventBus，传入自定义事件和参数" class="headerlink" title="子组件中引入eventBus，传入自定义事件和参数"></a>子组件中引入eventBus，传入自定义事件和参数</h4><p>子组件中引入eventBus,并像其传入自定义事件和参数，$emit实例方法触发的是当前实例上的事件，附加参数都会传给监听器回调。</p><pre><code>&lt;template&gt;  &lt;div class=&quot;box&quot; @click=&quot;sendMessage&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import bus  from &quot;../assets/eventBus&quot;;export default {   methods: {       sendMessage () {          bus.$emit(&apos;sendmsg&apos;, &apos;data&apos;)       }   }}&lt;/script&gt;</code></pre><h4 id="子组件中引入eventBus-监听事件获取传入参数"><a href="#子组件中引入eventBus-监听事件获取传入参数" class="headerlink" title="子组件中引入eventBus,监听事件获取传入参数"></a>子组件中引入eventBus,监听事件获取传入参数</h4><p>$on监听当前实例上的自定义事件，事件可以是由$emit触发的，回调函数会接受所有传入事件触发函数（$emit）的额外参数。</p><pre><code> mounted () {  bus.$on(&apos;sendmsg&apos;, (data) =&gt; {    console.log(data)  })}</code></pre><h3 id="父调用子"><a href="#父调用子" class="headerlink" title="父调用子"></a>父调用子</h3><p>通过$refs，父组件能够调用子组件里的属性与方法</p><pre><code>&lt;template&gt; &lt;iAudio id=&quot;audio&quot; ref=&quot;auido&quot; loop autoplay src=&quot;//inimg05.jiuyan.info/in/2017/07/26/FC889FF2-55B1-1C3B-146A-F3E966EC6803.mp3&quot;&gt;&lt;/iAudio&gt; &lt;div @click=&quot;paly&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  methods: {      play () {          this.$refs.auido.pause()      }  }}&lt;/script&gt;</code></pre><p>注意：当 ref 和 v-for 一起使用时，ref 是一个数组，包含相应的子组件。$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs。</p><p>组件之间的通信大概就是这几种方式了，一般中小型的项目，以上的通信方式以及足够用了，但如果是比较大型的项目可能就会需要用到vuex来集中管理状态了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Vue算是有一段时间了，期间公司的项目开发流程也全换成了Vue了，自己也是接了几个Vue的项目了，不过总感觉，知道的不是特别多，每次做起项目也总会遇到这样或者是那样的问题，这次总结一下项目中用到的比较频繁的组件之间的通信。&lt;/p&gt;
&lt;h3 id=&quot;父传子&quot;&gt;&lt;a href=&quot;#父传子&quot; class=&quot;headerlink&quot; title=&quot;父传子&quot;&gt;&lt;/a&gt;父传子&lt;/h3&gt;&lt;p&gt;props方式：&lt;br&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack初识（一）</title>
    <link href="http://yaoyue.com/2017/07/26/webpack%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/07/26/webpack初识（一）/</id>
    <published>2017-07-26T02:54:55.000Z</published>
    <updated>2017-07-26T03:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  虽然在公司用webpack好多次了，但是对其一直不是很了解，此次为了弄清楚目录结构，必须要学一下webpack。</p><h3 id="webpack是做什么的"><a href="#webpack是做什么的" class="headerlink" title="webpack是做什么的"></a>webpack是做什么的</h3><p>  官方的文档上是这样描述webpack的，说它是前端资源模块化管理和打包的工具，它能把任何形式的资源都看做是模块，根据其依赖关系，打包成为静态文件资源。</p><p><img src="http://www.css88.com/doc/webpack2/img/webpack.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;  虽然在公司用webpack好多次了，但是对其一直不是很了解，此次为了弄清楚目录结构，必须要学一下webpack。&lt;/p&gt;
&lt;h3 id=&quot;webpack是做什么的&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yaoyue.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>rem适配</title>
    <link href="http://yaoyue.com/2017/07/24/rem%E9%80%82%E9%85%8D/"/>
    <id>http://yaoyue.com/2017/07/24/rem适配/</id>
    <published>2017-07-24T07:21:38.000Z</published>
    <updated>2017-07-26T02:57:02.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>   实在是惭愧，做h5这么久了，居然连适配的问题一直没有搞明白。在公司写项目的时候总是用的模板，一行命令就生成了，直接就上手用了，适配也是模板中直接弄好的。又由于之前的自己一直是做pc端的，h5基础很是不牢靠，忽略了好的基本的知识。直到今天才把这个问题彻底的弄明白。基础真的很重要，很重要。</p><h3 id="为什么要是适配"><a href="#为什么要是适配" class="headerlink" title="为什么要是适配"></a>为什么要是适配</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;   实在是惭愧，做h5这么久了，居然连适配的问题一直没有搞明白。在公司写项目的时候总是用的模板，一行命令就生成了，直接就上手用了，适配也是模板中直接弄好的。又由于之前的自己
      
    
    </summary>
    
    
      <category term="css" scheme="http://yaoyue.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（四）--仿知乎登录页</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BB%BF%E7%9F%A5%E4%B9%8E%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（四）-仿知乎登录页/</id>
    <published>2017-04-05T07:28:04.000Z</published>
    <updated>2017-04-05T08:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:<a href="https://yaoyue1.github.io/dot.html" target="_blank" rel="external">传送门</a>,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。<br>看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码<br><a id="more"></a></p><p><pre><br><code><br>    $(function(){<br>      var cvs = document.getElementById(“mycanvas”);<br>      var ctx = cvs.getContext(‘2d’);<br>      var docWidth = document.documentElement.clientWidth;<br>      var docHeight = document.documentElement.clientHeight;<br>      cvs.width = docWidth;<br>      cvs.height = docHeight;//初始化准备，让canvas的宽高等于可视区的宽高<br>      var dotNum = 100;//整个区域粒子的数量<br>      var dots = [];//用来存放粒子对象的数组<br>      var mouse = new Object();//声明的对象用来存放鼠标的初始X、Y值<br>      mouse.x = 800;<br>      mouse.y = 350;<br>      for(var i=0;i<dotnum;i++){ 循环dotnum数量的粒子为每个粒子对象添加属性="" var="" dotobj="new" object();="" dotobj.x="Math.random()*docWidth;//初始的x坐标位置" dotobj.y="Math.random()*docHeight;//初始的y坐标位置" dotobj.r="Math.ceil(Math.random()*4);//粒子半径" dotobj.color="white" ;="" 粒子颜色="" dotobj.speedx="Math.floor(Math.random()*2)?1:-1//粒子X轴的运动方向" dotobj.speedy="Math.floor(Math.random()*2)?1:-1//粒子Y轴的运动方向" dots[i]="dotObj;//把粒子对象装进数组" }="" function="" drawball(x,y,r,color){="" 画每个粒子圆="" ctx.beginpath();="" ctx.arc(x,y,r,0,math.pi*2,false);="" ctx.fillstyle="color;" ctx.fill()="" move(obj){="" 粒子的移动函数="" obj.x="" +="obj.speedX*0.2;//粒子x轴方向每次移动的距离" obj.y="" if(obj.y<="obj.r){//上边界小球反弹处理" obj.speedy*="-1;" if(obj.y="">= docHeight-obj.r){//下边界小球反弹处理<br>          obj.y = docHeight-obj.r;<br>          obj.speedY<em>=-1;<br>        }<br>        if(obj.x&lt;=obj.r){//左边界的小球反弹处理<br>          obj.x = obj.x;<br>          obj.speedX</em>=-1;<br>        }<br>        if(obj.x &gt;= docWidth-obj.r){//右边界的小球反弹处理<br>          obj.x = docWidth-obj.r;<br>          obj.speedX<em>=-1;<br>        }<br>      }<br>      function ballAndball(obj1,obj2){//封装函数用来求两个球或者是球和鼠标直接的直线距离<br>        var disX = Math.abs(obj1.x-obj2.x);//相距的X绝对值<br>        var disY = Math.abs(obj1.y-obj2.y);//相距的Y绝对值<br>        return Math.sqrt(disX</em>disX+disY*disY)//平方根求直线距离<br>      }<br>      function mouseball(mouse,obj){//鼠标移动，把鼠标和距离其130内的小球连成线<br>        if(ballAndball(mouse,obj)&lt;130){<br>          ctx.lineWidth = 0.2;<br>          ctx.beginPath();<br>          ctx.moveTo(obj.x,obj.y);<br>          ctx.lineTo(mouse.x,mouse.y);<br>          ctx.strokeStyle = obj.color;<br>          ctx.stroke();</dotnum;i++){></code></pre></p><pre><code>    }  }  render();  function render(){    ctx.clearRect(0, 0, docWidth, docHeight);//清除画布    for(var j= 0;j &lt; dots.length;j++){//两层for循环，第一层是先画小球然后让每个小球移动，鼠标移动连线      little = dots[j]      move(little)      drawball(little.x,little.y,little.r,little.color)      mouseball(mouse,little)      for(var k = 0;k &lt; dots.length;k++){//第二层循环是用来找出两个球如果相距100就把他们用线连接起来        if(ballAndball(dots[j],dots[k])&lt;100){          ctx.lineWidth = 0.2;          ctx.globalAlpha = (130 - ballAndball(dots[j], dots[k])) * 1 / 100;//这句代码是用来控制线的消失和出现的效果          ctx.beginPath();          ctx.moveTo(dots[j].x, dots[j].y);          ctx.lineTo(dots[k].x, dots[k].y);          ctx.strokeStyle = dots[j].color;          ctx.stroke();        }      }      ctx.globalAlpha = 1.0    }    requestAnimationFrame(render);//浏览器自动刷新时间来循环调用render  }  cvs.onmousemove = function(event){//鼠标移动是的X、Y坐标    e = event || window.event;    mouse = new Object();    mouse.x = e.offsetX;    mouse.y = e.offsetY;  }})</code></pre><p><br>代码的核心部分可能就是求两个小球的距离来再次循环连线了。因为注释写的比较清楚，所以我就不多说了，下次的canvas学习一点点（五）还不知道些什么？？？纠结啊，你有啥想法可以告诉我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:&lt;a href=&quot;https://yaoyue1.github.io/dot.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。&lt;br&gt;看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（三）--黑客帝国</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（三）-黑客帝国/</id>
    <published>2017-04-05T07:27:28.000Z</published>
    <updated>2017-04-05T07:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间戳</title>
    <link href="http://yaoyue.com/2017/03/31/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <id>http://yaoyue.com/2017/03/31/时间戳/</id>
    <published>2017-03-31T09:31:09.000Z</published>
    <updated>2017-09-14T02:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>再次更新：</p><p>最近再回看自己写的文章的时候，才发现写的地方没讲清楚，哈哈哈，也许是当时并没有理解清楚，重新更新一下。</p><p>关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。稍微吐槽一下自己写的代码，不过有点扯远了，今天主要讲时间戳。<br>我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳过来：1505232000，这样一串数字就是时间戳。<br><a id="more"></a><br>你会想知道明明js可以获取到时间啊，为啥还需要这样传，那是因为js是获取到你系统本地的时间，你想如果你自己调快了时间那岂不是不准确了。所以时间戳的用处就是这样。<br>拿到一串时间戳你要怎样把它转化成为XX年xx月xx日这样的呢？<br>这里必须要提到PHP的时间戳和js的时间戳是不一样的，你通过new Data().getTime()或者是通过Date.parse(new Date())方法获取到的js时间戳是13位，而你会发现php传过来的时间戳是10位，是的，js获取的时间戳和PHP获取的时间戳是有区别的：</p><ul><li>单位区别：PHP获取的时间戳是以秒为单位的，而js获取的时间戳是以毫秒为单位的，所以你必须要转换单位，1秒=1000毫秒</li><li>时区区别：PHP通过time()获取的时间戳，通常会跟服务器所在的时区有关，js获取的时间戳则是依据你的系统时间确定的，如果你把你的手机或者电脑的时间设置比正常快或慢，js获取的时间会以你的设置时间为准，这也是为什么我们用实际不能通过js本地获取。<br><img src="http://i.imgur.com/ljI4ovd.png" alt=""></li></ul><p>封装一个方法format（）；这样你只有把时间戳传进去就可以给你返回xx年xx月xx日xx:xx</p><pre><code> function add0(m) {    return m &lt; 10 ? &apos;0&apos; + m : m;}function format(t) {    var time = new Date(parseInt(t) * 1000);//这里为什么乘以1000，也就是因为PHP和js的时间戳的单位不一致    var y = time.getFullYear();    var m = time.getMonth() + 1;    var d = time.getDate();    var h = time.getHours();    var mm = time.getMinutes();    var s = time.getSeconds();    return y+&apos;年&apos;+add0(m) + &apos;月&apos; + add0(d) + &apos;日 &apos; + add0(h) + &apos;:&apos; + add0(mm);}</code></pre><p>截图放一张我这次做的活动的签到日历：<br>！<a href=""></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再次更新：&lt;/p&gt;
&lt;p&gt;最近再回看自己写的文章的时候，才发现写的地方没讲清楚，哈哈哈，也许是当时并没有理解清楚，重新更新一下。&lt;/p&gt;
&lt;p&gt;关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。稍微吐槽一下自己写的代码，不过有点扯远了，今天主要讲时间戳。&lt;br&gt;我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳过来：1505232000，这样一串数字就是时间戳。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（二）--</title>
    <link href="http://yaoyue.com/2017/03/31/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/31/canvas学习一点点（二）/</id>
    <published>2017-03-31T05:49:34.000Z</published>
    <updated>2017-04-01T07:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。<br>最终的效果：<a href="https://yaoyue1.github.io/bar.html" target="_blank" rel="external">传送门</a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;canvas id= &quot;mycanvas&quot; width=&apos;500&apos; height=&apos;500&apos;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure><pre><code>//js$(function(){      var cvs = document.getElementById(&apos;mycanvas&apos;);      var ctx = cvs.getContext(&apos;2d&apos;);      var centerX = cvs.width/2;//圆心的x坐标      var centerY = cvs.height/2;//圆心的y坐标      var rad = Math.PI*2/100;//把2π弧度分成100份，每一份的弧度值      var initNum = 0.1;//初始化的基础百分比      var speed = 0.2;//加载速度      function blueCircle(n){画进度的展示蓝圈          ctx.save();//保存画布状态          ctx.strokeStyle = &quot;#49f&quot;;          ctx.lineWidth = 5;          ctx.beginPath();          ctx.arc(centerX, centerY, 200,-Math.PI/2, -Math.PI/2+n*rad,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function  initCircle(){//画最开始的初始化圆圈          ctx.save();          ctx.beginPath();          ctx.strokeStyle = &quot;white&quot;;          ctx.arc(centerX, centerY, 200, 0,Math.PI*2,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function text(n){//画中间的文字          ctx.save();          ctx.strokeStyle = &quot;#49f&quot;;          ctx.font = &apos;40px Arial&apos;          ctx.strokeText(n.toFixed(0)+&apos;%&apos;,centerX-25, centerY+10);          ctx.stroke();          ctx.restore();      }      draw()      function draw(){          window.requestAnimationFrame(draw);//浏览器的刷新频率自动调整动画的时间间隔          ctx.clearRect(0, 0, cvs.width, cvs.height);//清除上一次画布的内容          initCircle()//调用方法          text(initNum);          blueCircle(initNum);          initNum+=speed;          if(initNum&gt;100){//当进度达到100的时候就让他一直为100，不然你的进度条要破100的~~~~              initNum = 100          }      }  })</code></pre><p>是不是觉得很简单~~代码不多确实jq很难做到的，之前用jq写一般都只能写长条形状的进度条。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。&lt;br&gt;最终的效果：&lt;a href=&quot;https://yaoyue1.github.io/bar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>ios touch事件导致的CSS3动画问题</title>
    <link href="http://yaoyue.com/2017/03/30/ios-touch%E4%BA%8B%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84CSS3%E5%8A%A8%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yaoyue.com/2017/03/30/ios-touch事件导致的CSS3动动画问题/</id>
    <published>2017-03-30T05:57:06.000Z</published>
    <updated>2017-03-31T02:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>刚刚做完一个腾讯动漫的项目：<a href="https://www.in66.com/html/tonglingfei/index.html" target="_blank" rel="external">传送门</a>,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当你到达这个页面的时候，你会看到5个不同的美男子，你点击其中任何一个都会去一个相对应的故事，假如你点击第二个你会看到第二张图。第二张图中我用红色框框出来的这些对话框都是需要一个一个的接着出现，所以我当时的第一反应是采用CSS3的animation-delay属性来解决，只需要给每个对话框设置一个延迟的属性，让她依次出来不就行了，我也确实是这样做了。然而因为我穷，只买得起安卓手机，所以只测了安卓一点问题都木有，在chrome模拟器上也啥事没有，我就真信了这样做简直不能太好，等全部做完了，来测试上线的时候才发现ios尼玛的又出现问题了。因为这些故事的页面都超过了一屏，所以必须要滑动屏幕才能看下面的，ios出问题就出现在这：ios当你触摸屏幕或者滑动屏幕时它会暂停掉你屏幕上CSS的渲染，所以只要你的手还在屏幕上，对话框的出现就会被截断，你放开手后才能继续加载。但是蛋疼的是后来加载的对话框它的延迟时间会重头开始算起而不是从你松开手的那一刻算，这就真是坑了，等半天都出不来。</p><p><img src="http://i.imgur.com/YVK0j59.png" alt=""><br><img src="http://i.imgur.com/Ch5vXwA.png" alt=""></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>赶紧去google一下才发现这事前端真的很无辜，是ios事件的处理机制有关。<br>ios和安卓不同，他们处理事情的机制顺序不一样。</p><ul><li>ios的处理机制是：它的响应顺序依次为：Touch——Media——Service——Core架构，你可以看到它最先响应的是屏幕的反应，所以只要用户触摸屏幕，系统最先去处理的就是touch了，此时会暂停屏幕上包括js、css的渲染，这个时候不光是css动画不动了，哪怕页面没有加载完如果你手指头还停留在屏幕上那么页面也不会继续加载，直到你的手松开</li><li>Android的处理机制是：它的响应顺序依次为：Application——Framework——Library——Kernal架构，和屏幕显示相关的处于library这一层，所以当你对屏幕操作之后，Android首先会激活应用、框架，然后才是屏幕最后是核心架构。</li></ul><p>以上就是为啥安卓手机很流畅，ios却出现了CSS3动画的滚动停止了。<br>那到底该咋解决呢？？到底该咋解决呢？？<br>其实到现在我的解决方式都不算太好，我把原先用CSS3控制顺序的方式改成了用js的setTimeout()的方式，你也看到了，这真的很不好，写了一堆的setTimeout函数，但是这样做虽不能解决滚动时停止加载，但是最起码时间的计算方式不是从头开始算的了。找不到更好的方法了，如果你知道，请不要害羞的多多指教~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚做完一个腾讯动漫的项目：&lt;a href=&quot;https://www.in66.com/html/tonglingfei/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（一）</title>
    <link href="http://yaoyue.com/2017/03/30/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/30/canvas学习一点点（一）/</id>
    <published>2017-03-30T05:47:18.000Z</published>
    <updated>2017-03-31T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~</p><p>今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。<br>最终效果链接：<a href="https://yaoyue1.github.io/snow.html" target="_blank" rel="external">传送门</a><br>快和你的妹纸一起来看雪吧~~~<br><a id="more"></a></p><pre><code>//html&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;//js$(function(){ snow()function snow(){    var docWidth = document.documentElement.clientWidth //可见区域宽度    var docHeight = document.documentElement.clientHeight //可见区域高度    // initPage()    function initPage(){        containerWidth = $(&quot;.container&quot;).width();//获取外层容器container宽度        containerHeight = $(&quot;.container&quot;).height();//获取外层容器container高度        initFloatAnimation()    }    function initFloatAnimation(){        var canvas = document.createElement(&apos;canvas&apos;);//创建canvas元素        var ctx = canvas.getContext(&apos;2d&apos;);            canvas.id = &apos;floatCanvas&apos;;//给canvas一个id            canvas.width = containerWidth;//让canvas的宽度等于container的宽度            canvas.height = containerHeight;//让canvas的高度等于container的高度        $(&quot;.container&quot;).append(canvas);//把canvas追加进html的container        var particleNum = 100;//粒子的数量        var particles = [];//定义空数组用来存储每个粒子对象        for (var i=0;i&lt;particleNum;i++){            var particleObj = new Object();//创建一个对象            particleObj.x = Math.random()*docWidth;//在可视区域宽度的范围内随机生成粒子的初始x坐标            particleObj.y = Math.random()*docHeight;//在可视区域g的范围内随机生成粒子的初始y坐标            particleObj.vx = Math.random() * 2-1;//生成粒子横向移动的距离            particleObj.vy = (Math.random() * 0.8 + 0.2);//生成粒子纵向移动的距离：[0.2-1]            particleObj.dw = particleObj.vy*20;//随机生成粒子的宽度            particleObj.dh = particleObj.dw;//粒子的宽度等于高度            particleObj.ag = (Math.random()*2-1)*10;//粒子的初始角度            particles[i] = particleObj;//把这些对象装进事先定义的数组        }        console.log(particles)        // 以上把需要的元素都准备好了，接下来就是渲染让粒子动起来        render()        function render(){            ctx.clearRect(0, 0, containerWidth, containerHeight);//清除画布            var little;            for(var j=0;j&lt;particles.length;j++){                little = particles[j];                if(little.x &lt; 0 || little.x &gt; containerWidth || little.y &gt; containerHeight){//if判断如果粒子已经超出了可视的边界就再重新产生它的x,y值                    little.x = Math.random() * containerWidth;                    little.y = Math.random() * -200;                }                little.x += little.vx;                little.y += little.vy;                drawImage(ctx,img,little.x,little.y,little.dw,little.dh,1,little.ag);            }            requestAnimationFrame(render);//循环调用自身，requestAnimationFrame是一个新的API,作用与setTimeInterval一样，不同的是它会根据浏览器的刷新频率自动调整动画的时间间隔。        }    }    function drawImage (ctx,img,dx,dy,dw,dh,scale,angle) {        ctx.save();        ctx.translate(dx + dw / 2, dy + dh / 2);//移动画布        ctx.scale(scale, scale);        ctx.rotate(angle);        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -1 * dw / 2, -1 * dh / 2, dw, dh);//重新绘制新的粒子        ctx.restore();    }var _base = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAlCAMAAADyQNAxAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALnRSTlMArr2Dd6phklkuBYhdNo0yOmpFFZd/exkOCW4/VkqecqdlJh4Ro04jtVG5KpuwTP8QawAAArlJREFUOMuVlNmSsjAQhXUIIYGEhM0g+6Igou//ev9hsZwZay7+ruLuq3O6T7o5/H+5Z/cQRZfzOT3/DZ2jyHRc8Xmcxz76g7n0nHOpda5zqTg3509BNzWz0mVZDkMxFVMZytlcUve32chlODEmmKCUClaEuebd+BMyXOYDEy0NsqCuSZZRUbCcj5fvVNrLsBBtRjKSnBIrOZEsoGLQSkbfpEaVFzQghCQWyvMsK6kDysJcjm8lrmBHM3KyPN/3HccHCrlWwNS8KKN0yFqYeb4TV3FVxbHjexYhgRjkvLfmrk1lEAJztRvbbppr7HgJIS0LVb931elBBMSynMf1uJZt2wsGU1poHm1SvCxonVh+3NhAXlzlL54s3AZIOzmIzIJUtVK3++22YjE8M6FVdwYVcc0g5fmxDeh5/0Ldnke7iSEWiFKOKaieY0ACwweg29dWd6hVjnWqKZNm0yqhhQErUKvSqnZsFoq0g+wuC6VKaFm+c7WPz51BHe3HEgZluYowouGhCJCo0+yOe2MNKKteori4mBGOATktWvbz3Ra0kP+Wq7vOONH65DkPiN12qYWKHQxJi9XxYDo1tASNVfba/v2G77ik72NGMW1JuEZOYnnqRwOx5yJzB7U+EYIY0NZCjSpk6wshi+a4F3JA8xkddAdqe6JSoH9g2BobZnZzvWJ3EkiVsl8M1yzyYt1By4mxO9fq+oAdIg1oKHnk7rs6qm0LLQ+L6sTOtq01bilUJn3dYjTrSWDv1533EZOXnBYlkSPS93X0Ki9xHjXBAaFgRgCxKefRfuD7AFh9RmlN1sraIKBFoRXme5d7McAG2LYBBbFcd5nnyryR3XTmWheTEAxVsAnTjbD7XVHfzVLn5YRfShhikU0Ku49y3bSbuVKSK87n/tXSJ5deTGd6E6XpT7NPQffwKfIPFOtCNONyh58AAAAASUVORK5CYII=&quot;    //图片我直接用的base64来写的    var img = new Image();    img.src = _base;    img.onload = function() {        initPage()    }}})</code></pre><p>   个人感觉注释已经写的比较详细了，就不再多说了哈~~，来和你的妹纸一起来看雪吧！！！</p><p>   什么？？？你没有没有啊？？</p><p><img src="https://a-ssl.duitang.com/uploads/item/201609/04/20160904102522_Fadn4.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~&lt;/p&gt;
&lt;p&gt;今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。&lt;br&gt;最终效果链接：&lt;a href=&quot;https://yaoyue1.github.io/snow.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;快和你的妹纸一起来看雪吧~~~&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>下拉加载你这个坑货~</title>
    <link href="http://yaoyue.com/2017/03/15/%E4%B8%8B%E6%8B%89%E5%8A%A0%E8%BD%BD%E4%BD%A0%E8%BF%99%E4%B8%AA%E5%9D%91%E8%B4%A7-1/"/>
    <id>http://yaoyue.com/2017/03/15/下拉加载你这个坑货-1/</id>
    <published>2017-03-15T04:00:53.000Z</published>
    <updated>2017-03-15T09:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>   前两天刚做的一个<a href="https://www.in66.com/html/photoShare2017/index.html" target="_blank" rel="external">项目</a>,需要用下拉加载的方式去请求数据。我原以为这会是很简单的，肯定分分钟写完（不过确实也挺简单的），只不过还是坑了我一些的。</p><h3 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h3><p><pre><br>$(window).scroll(function(){<br>　　var scrollTop = $(this).scrollTop();<br>　　var scrollHeight = $(document).height();<br>　　var windowHeight = $(this).height();<br>　　if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“you are in the bottom”);<br>　　}<br>});<br></pre><br><a id="more"></a><br>看完上面的代码是不是觉得完全没有毛病，嗯呐~，当初我也是这样觉得的，很对呀。而且我在安卓手机和chrome模拟器上完全没有问题。scrollTop获取的是滚动条滚动的距离，scrollHeight获取到的是整个文档的高度，windowHeight是获取当前也就是你浏览器所能看到的页面的那部分的高度，你已经滚过的高度+你目前看到的剩下的可视高度等于你整个文档高度的时候，确实表示了滚动条就在文档的最下面了。嗯，灰常好。然后你就灰常开心的去请求数据去了，也就是这样：<br><img src="http://i.imgur.com/OExNWyP.png" alt=""><br>是不是你现在也觉得木有毛病。我当时测的时候也很开心。但是当我去借了个苹果的测试机来测的时候尼玛问题来了。也就是我要讲到的第一个坑。这段js对苹果木有反应。我就想着是咋回事嘛~，搞了半天才发现，原来自己傻了</p><p><pre><br>if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“you are in the bottom”);<br>　　}<br></pre><br>其实坑就在这句话中，因为是写的等于，所以只有一个点能判断到达底部了，如果你不断的触动屏幕，很有可能的你滚动条就已经达不到这个点了，而且加上苹果手机到达底部的时候，你再滑动的时候页面会被拖出一个区域，所以这个点对于苹果手机来说有问题。所以不能改成一个点。而且还有一个重要的原因就是，你的数据是请求得来的，你还需要拿数据去渲染页面，为了用户不等待，你需要预留一段时间来请求，而不是等到已经最底部了再去请求。所以我立马高兴的改成了这样：</p><p><pre><br>if(scrollTop + windowHeight &gt; scrollHeight -100){<br>　　　　alert(“you are in the bottom”);<br>　　}<br></pre><br>这样就是代表你在距离底部100px的时候都会给你触发到达底部了。这样果然苹果没问题了。但是我立马发现了另外一个问题，也就是坑二。</p><h3 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h3><p>数据重复了，啥意思呢？就是说你的滚动条如果一直在距离底部100px的范围内得到话，它就会给你去执行你的render()方法，然后去渲染页面。你想如果你一直在100px的范围的话，那他就会给你不断的去发请求，上一个请求还没执行完，你又去了，请求的数据肯定会被重复。所以解决的办法呢就是你设置一个标志，如果上一次请求成功了之后，页面渲染完成了之后，你再去请求，这样就好了。代码如下：<br><img src="http://i.imgur.com/nCJqq2h.png" alt=""><br>相比于刚刚的代码，我加上了一个isSucc的变量来判断，第一次请求这个变量是true，你可以去请求，一进入后立马把这个变量设置为false，代表我这次的请求还没完全走完，你下一波等等，等到页面完全渲染好了，请求已经done了后你再把这个变量设置为true，然后下一波就可以去请求了。</p><p>你以为写到现在完了，其实还有一个问题，就是当数据库中已经没有数据了，你就不能再狂发请求了，所以你还需要干一件事，就是再设置一个标志来判断数据库中是否还有数据，有，就去请求，没有就不要再去请求了。<br>所以最终的代码应该是这样：<br><img src="http://i.imgur.com/REdmMFd.png" alt=""><br>好啦~到现在为止一个下拉加载才写好了，啦啦啦啦啦~写的不对的地方望大神指教好改正！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   前两天刚做的一个&lt;a href=&quot;https://www.in66.com/html/photoShare2017/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目&lt;/a&gt;,需要用下拉加载的方式去请求数据。我原以为这会是很简单的，肯定分分钟写完（不过确实也挺简单的），只不过还是坑了我一些的。&lt;/p&gt;
&lt;h3 id=&quot;坑一&quot;&gt;&lt;a href=&quot;#坑一&quot; class=&quot;headerlink&quot; title=&quot;坑一&quot;&gt;&lt;/a&gt;坑一&lt;/h3&gt;&lt;p&gt;&lt;pre&gt;&lt;br&gt;$(window).scroll(function(){&lt;br&gt;　　var scrollTop = $(this).scrollTop();&lt;br&gt;　　var scrollHeight = $(document).height();&lt;br&gt;　　var windowHeight = $(this).height();&lt;br&gt;　　if(scrollTop + windowHeight == scrollHeight){&lt;br&gt;　　　　alert(“you are in the bottom”);&lt;br&gt;　　}&lt;br&gt;});&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>和clip-path来场美丽的初识</title>
    <link href="http://yaoyue.com/2017/03/08/%E5%92%8Cclip-path%E6%9D%A5%E5%9C%BA%E7%BE%8E%E4%B8%BD%E7%9A%84%E5%88%9D%E8%AF%86/"/>
    <id>http://yaoyue.com/2017/03/08/和clip-path来场美丽的初识/</id>
    <published>2017-03-08T02:30:01.000Z</published>
    <updated>2017-03-21T08:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  公司前端的技术分享轮到我了，有点小迷茫，不知道该讲什么，纠结来纠结去，偶然看到了腾讯全端 AlloyTeam团队的一篇博文分享，是关于clip-path的，虽然写的比较简单（也可能是我的level还没有达到辣么个水平,完全不能理解）但是真的被那个炫酷的动画给迷倒了。就想一探究竟，然后讲讲这个。（其实最主要我还是觉得这个属性大家平时用到的不多，可能很多人也不是特别了解，作为一个实习生去讲给一堆大牛听这种偏冷门的属性是最合适不过了，哈哈哈，小心机一下）正式开始写啦啦~</p><h3 id="clip-path基本属性"><a href="#clip-path基本属性" class="headerlink" title="clip-path基本属性"></a>clip-path基本属性</h3><p>clip-path一共有四个基本的属性裁剪再加上一个可以直接引用SVG的属性算是五个吧。前面四个基本的是polygon（多边形），circle（圆形），ellipse（椭圆）、inset（圆弧）。下面先开始说这四个属性：</p><h4 id="裁剪多边形"><a href="#裁剪多边形" class="headerlink" title="裁剪多边形"></a>裁剪多边形</h4><p><pre><br>-webkit-clip-path: polygon(0 25%,25% 0,75% 0,100% 25%,100% 75%,75% 100%,25% 100%,0 75%);<br></pre><br><a id="more"></a><br>一步一步分析：以上一共是8组坐标，每组坐标之间用逗号隔开，前面的一个表示x坐标，后面一个表示y坐标，所有的坐标连接起来就构成你所需要裁剪的形状。（原谅本人较懒随便用qq截图画的这个坐标(^o^)/~，之后的坐标都是这样的，我就更懒得画了）</p><p><img src="http://i.imgur.com/sz4Ch4N.png" alt=""></p><h4 id="裁剪圆形"><a href="#裁剪圆形" class="headerlink" title="裁剪圆形"></a>裁剪圆形</h4><p><pre><br>-webkit-clip-path: circle(300px at 50% 50%);<br></pre><br>画圆是circle:接受三个参数，第一个参数为圆的半径，第二个参数为圆的圆心x坐标，第三个参数为圆的圆心y坐标，用at隔开</p><p><img src="http://i.imgur.com/Nbzb5t7.png" alt=""></p><h4 id="裁剪椭圆"><a href="#裁剪椭圆" class="headerlink" title="裁剪椭圆"></a>裁剪椭圆</h4><p><pre><br>-webkit-clip-path: ellipse(50% 40% at 50% 50%);<br></pre><br>裁剪椭圆为ellipse：at前面的一对值表示椭圆的半径值（a,b），at后面的一对值表示椭圆的圆心值<br><img src="http://i.imgur.com/2ult15m.png" alt=""></p><h4 id="裁剪圆弧"><a href="#裁剪圆弧" class="headerlink" title="裁剪圆弧"></a>裁剪圆弧</h4><p><pre><br>-webkit-clip-path:  inset(30px 90px 50px 90px round 0 25% 0 25%);<br></pre><br>inset属性老版本的chrome浏览器可能不支持。它有8个参数，round前面的四个值表示上、右、下、左的四个坐标值，round后面的四个值表示top-radius right-radius bottom-radius left-radius等弧度。</p><p><img src="http://i.imgur.com/xTdSXJT.png" alt=""></p><h3 id="实际用例"><a href="#实际用例" class="headerlink" title="实际用例"></a>实际用例</h3><p>就这么个普通的clip-path属性你可能会想它在实际的应用中一般都有啥用途呢？我将列举一下它比较常见的通途，如果你有遇到比较好玩的，也可以告诉我哦~~对啦在讲应用前还是先贴一张clip-path属性的浏览器支持情况：<br><img src="http://i.imgur.com/Tuf1SKm.png" alt=""></p><h4 id="小三角形的实现"><a href="#小三角形的实现" class="headerlink" title="小三角形的实现"></a>小三角形的实现</h4><p><img src="http://i.imgur.com/LuuZY9k.png" alt=""></p><p>如图的对话框下面的小三角形就可以使用clip-path的方法实现。当然这个小三角形的实现方法也不是只有这一种，而且此种方法也是有一些弊病的，就是ie浏览器是不会支持你的哈哈哈哈~~<br>关于这个小三角形实现的其他几种方法我也提一下吧，都是自己之前做项目的时候使用过的，顺便写一下，自己再熟悉一下。</p><ul><li>第一种：clip-path    </li></ul><p>也就是把一个小的div裁剪成一个三角形在定位到指定位置</p><pre><code>//html&lt;div class=&quot;tangle1&quot;&gt;  &lt;span&gt;hello world!&lt;/span&gt;  &lt;div class=&quot;icon1&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle1{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon1{        position: absolute;        left:70%;        top:100%;        width: 50px;        height: 30px;        background: #f5a0bd;        -webkit-clip-path: polygon(0 0,100% 0,50% 100%)    }</code></pre><ul><li><p>第二种：transparent</p><pre><code>//html&lt;div class=&quot;tangle2&quot;&gt;    &lt;span&gt;hello world!&lt;/span&gt;    &lt;div class=&quot;icon2&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle2{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon2{        position: absolute;        left:70%;        top:99%;        width: 0px;        height: 0px;        font-size: 0;        border: 20px solid transparent;        border-top-color: #f5a0bd;    }</code></pre></li><li>第三种：transfrom 的旋转功能</li><li><pre><code>//html&lt;div class=&quot;tangle3&quot;&gt;  &lt;span&gt;hello world!&lt;/span&gt;  &lt;div class=&quot;icon3&quot;&gt;&lt;/div&gt;&lt;/div&gt;//css.tangle3{        position: relative;        margin:100px auto;        width: 400px;        height: 200px;        border-radius: 8%;        background: #f5a0bd;        color: #fff;        text-align: center;        line-height: 200px;        font-size: 40px;    }    .icon3{        position: absolute;        left:70%;        top:93%;        width: 30px;        height: 30px;        background-color: #f5a0bd;        transform: rotate(45deg);    }</code></pre><h4 id="species-in-pieces"><a href="#species-in-pieces" class="headerlink" title="species-in-pieces"></a>species-in-pieces</h4><p>先给你看个网站：<a href="http://species-in-pieces.com/#" target="_blank" rel="external">传送门</a>，你会不会和我第一次看到的那样一样惊叹。怎么可以实现这么炫酷的效果。<br>今天我就来讲讲这是咋实现的。<br><img src="http://i.imgur.com/99XETlr.png" alt=""><br>拿这个动物来说，你会发现这些图形都是由30个如下的代码组成。每个shard的宽高都是100%，他们都是position：absolute。</p><p>  <div class="shard-wrap"></div></p><pre><code>&lt;div class=&quot;shard&quot;&gt;&lt;/div&gt;</code></pre><p>  <br>也就是说其实这些图形都是堆叠在一起的他们的宽高都是100%是为了响应式~他们的样式是同个nth-child(n)来实现的，例如：</p><p>   //child one<br>  .shard-wrap:nth-child(1) .shard {</p><pre><code>-webkit-clip-path: polygon(11.1% 81.286%, 13.9% 80.286%, 13.9% 74.429%);        clip-path: polygon(11.1% 81.286%, 13.9% 80.286%, 13.9% 74.429%);background-color: #262327;-webkit-transition-delay: 0.02s;        transition-delay: 0.02s;</code></pre><p>  }<br>   //child two<br>  .shard-wrap:nth-child(2) .shard {</p><pre><code>-webkit-clip-path: polygon(9.6% 71.3%, 11.2% 81.2%, 13.95% 74.571%);        clip-path: polygon(9.6% 71.3%, 11.2% 81.2%, 13.95% 74.571%);background-color: #3C3642;-webkit-transition-delay: 0.04s;        transition-delay: 0.04s;</code></pre><p>  }<br>这样就可以控制每个三角形的样式和颜色。最后组合成为这个图形。你会发现这真没啥难得，想要hover这个图片的时候变化成另外一个动物比方说这个<br><img src="http://i.imgur.com/Pf8WLgN.png" alt=""><br>只需要给每个shard命名的class再加上一个hover的新样式就可：<br><img src="http://i.imgur.com/TENe2KI.png" alt=""><br>这样的直接变化可能会太突然，所以你可以给所有的shard加上一个transition</p><pre><code>-webkit-transition: all 1s;transition: all 1s;</code></pre><p>然后给每个shard加上不同时间的延迟动画，这样就好变的很好了。我写的<a href="https://yaoyue1.github.io/clip_path/last.html" target="_blank" rel="external">demo</a>点击一下第一个动物出现，点击两下第二个动物出现。</p></li></ul><p>也许你也会觉得这确实很简单，但是这些shard的polygon后的裁剪数据是怎样得来的，那我就要告诉你算的的！！就是算出来的。我也觉得真是复杂~所以我觉得真的需要一个强大的设计师~这是一个灵感满满的设计和动效。这些数据是需要事先提取出来的~</p><h4 id="写几个小动画"><a href="#写几个小动画" class="headerlink" title="写几个小动画"></a>写几个小动画</h4><p><a href="https://yaoyue1.github.io/clip_path/littleicon.html" target="_blank" rel="external">demo</a><br>是不是觉得你小瞧了clip-path这个属性了。当初我也是以为他只能裁剪一下图片而已的。</p><p><img src="http://i.imgur.com/ws4s1hb.png" alt=""></p><p>这个动画有一个点需要注意的是：这些字母都是通过一个div裁剪的例如第二个字母K，它是由12个顶点所组成的，所以你的div从刚开始就必须由12个点组成，不然浏览器咋知道你要重一个长方形的div变成是一个字母K，所以这里就存在一条件：动画在一定条件下可以对clip-path生效 . 这里的一定条件即裁剪的多边形必须具有相同的顶点数。</p><p>这里就算是讲完clip-path的前四个基本属性了，把最后一个与SVG相引用的属性方最后讲是因为我最喜欢这个属性了，可好玩了~</p><h3 id="clip-path与SVG配合"><a href="#clip-path与SVG配合" class="headerlink" title="clip-path与SVG配合"></a>clip-path与SVG配合</h3><p>先上张图：</p><p><img src="http://i.imgur.com/lzqH2O7.png" alt=""></p><p>是不是超级美，我可是用代码写不出来这路径的，但是SVG可以。<br>clip-path的最后一个属性是-webkit-clip-path: url(#svgTextPath);url中间引用的是一段SVG的路径。当然我还不会写，但是我知道咋弄，，哈哈哈，来推荐一个<a href="http://www.yyyweb.com/ctools/demo.php?t=http%3A%2F%2Feditor.method.ac%2F&amp;h=2000&amp;c=&amp;n=" target="_blank" rel="external">网站</a>这是一个SVG的在线编辑器</p><p><img src="http://i.imgur.com/SRgETH7.png" alt=""></p><p>我框的这个是用来画路径的</p><ol><li><p>我先画两个<br><img src="http://i.imgur.com/QnUqTGh.png" alt=""></p></li><li><p>然后把这个文件保存为SVG，把这个svg用你的编辑器打开，你会发现他记录了一长串的路径~我们需要的就是这段路径，把它copy下来。像这样放到你的html的body中</p><pre><code>&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;    &lt;svg height=&quot;0&quot; width=&quot;0&quot;&gt;   &lt;defs&gt;       &lt;clipPath id=&quot;svgTextPath&quot;&gt;           //你copy的路径        &lt;/clipPath&gt;   &lt;/defs&gt;&lt;/svg&gt;    </code></pre><p>img的图片换成你自己喜欢的,然后给这个图片加上-webkit-clip-path: url(#svgTextPath)的属性，你想要的效果就出现啦啦啦~</p></li></ol><p><img src="http://i.imgur.com/3ffWx4p.png" alt=""></p><p>是不是很好看~</p><p>最后的最后我要对你说，你真的好厉害~居然看到这里了。我自己都不忍心写到这里的，哈哈哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  公司前端的技术分享轮到我了，有点小迷茫，不知道该讲什么，纠结来纠结去，偶然看到了腾讯全端 AlloyTeam团队的一篇博文分享，是关于clip-path的，虽然写的比较简单（也可能是我的level还没有达到辣么个水平,完全不能理解）但是真的被那个炫酷的动画给迷倒了。就想一探究竟，然后讲讲这个。（其实最主要我还是觉得这个属性大家平时用到的不多，可能很多人也不是特别了解，作为一个实习生去讲给一堆大牛听这种偏冷门的属性是最合适不过了，哈哈哈，小心机一下）正式开始写啦啦~&lt;/p&gt;
&lt;h3 id=&quot;clip-path基本属性&quot;&gt;&lt;a href=&quot;#clip-path基本属性&quot; class=&quot;headerlink&quot; title=&quot;clip-path基本属性&quot;&gt;&lt;/a&gt;clip-path基本属性&lt;/h3&gt;&lt;p&gt;clip-path一共有四个基本的属性裁剪再加上一个可以直接引用SVG的属性算是五个吧。前面四个基本的是polygon（多边形），circle（圆形），ellipse（椭圆）、inset（圆弧）。下面先开始说这四个属性：&lt;/p&gt;
&lt;h4 id=&quot;裁剪多边形&quot;&gt;&lt;a href=&quot;#裁剪多边形&quot; class=&quot;headerlink&quot; title=&quot;裁剪多边形&quot;&gt;&lt;/a&gt;裁剪多边形&lt;/h4&gt;&lt;p&gt;&lt;pre&gt;&lt;br&gt;-webkit-clip-path: polygon(0 25%,25% 0,75% 0,100% 25%,100% 75%,75% 100%,25% 100%,0 75%);&lt;br&gt;&lt;/pre&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CSS3" scheme="http://yaoyue.com/categories/CSS3/"/>
    
    
      <category term="CSS3" scheme="http://yaoyue.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃（三）</title>
    <link href="http://yaoyue.com/2017/02/20/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/02/20/vue入门到放弃（三）/</id>
    <published>2017-02-20T03:12:42.000Z</published>
    <updated>2017-02-21T07:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p> 上两篇关于Vue的博文，一篇是环境的搭建和运行，另一篇是自己回顾之前所学的基本指令。这些准备完毕之后，也是时候来写demo练手了，不然好像一直看文档看API也没啥作用，开始啦，自己一边写demo一边把重要的部分记录下来吧。<br> <a id="more"></a></p><h3 id="新建项目文件夹"><a href="#新建项目文件夹" class="headerlink" title="新建项目文件夹"></a>新建项目文件夹</h3><p>通过Vue init webpack searchdemo新建一个项目。<br><img src="http://i.imgur.com/6352VQQ.png" alt=""><br>进入项目文件：cd searchdemo</p><p>安装项目依赖：cnpm install</p><p>运行项目：npm run dev</p><h3 id="划分目录结构"><a href="#划分目录结构" class="headerlink" title="划分目录结构"></a>划分目录结构</h3><p>这个demo是一个切换搜索浏览器的页面，所以可以划分成一个logo选择的组件和一个搜索面板的组件。目录结构如下：static用于存放静态资源</p><p><img src="http://i.imgur.com/INUMDFO.png" alt=""></p><p>目录结构划分好后App.Vue就可以把连个组件引进来了，但是考虑到logo选择的组件是需要和下面的搜索面板的组件通信的，所以我没有把这个两个组件同时进入到app.vue中而是把logo组件引入到搜索面板组件中，最后再把搜索面板组件引入到APP.Vue中。</p><h3 id="组件logoSelect编写"><a href="#组件logoSelect编写" class="headerlink" title="组件logoSelect编写"></a>组件logoSelect编写</h3><p>在logo组件编写的时候需要注意的点：</p><h4 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h4><p>v-cloak：在使用vuejs、angularjs开发时，经常会遇见在如Chrome这类能够快速解析的浏览器上出现表达式( ),或者是模块(div)的闪烁。对于这个问题由于JavaScript去操作DOM，都会等待DOM加载完成（DOM ready）。对于vuejs、angularjs这些会在DOM ready完会才回去解析html view Template，所以对于Chrome这类快速的浏览器你会看见有闪烁的情况出现。而对于IE7，8这类解析稍慢的浏览器大部分情况下是不会出现这个问题的。</p><h3 id="向父组件传递参数"><a href="#向父组件传递参数" class="headerlink" title="向父组件传递参数"></a>向父组件传递参数</h3><p><img src="http://i.imgur.com/qMDTjFc.png" alt=""><br>使用$emit()像父组件即搜索面板传递参数。触发父组件的自定义事件，向父组件传参数,selectNow是选择了哪个搜索引擎的索引，父组件得到了之后就可以指定搜索时跳转到哪个搜索引擎。父子组件通信可以看vue文档 组件那一章</p><h3 id="组件searchPanel的编写"><a href="#组件searchPanel的编写" class="headerlink" title="组件searchPanel的编写"></a>组件searchPanel的编写</h3><p><img src="http://i.imgur.com/hcx4oWQ.png" alt=""><br>组件搜索面板需要利用jsonp进行跨域请求，所以必须按照网络请求模块 vue-resource</p><p><pre><br>cnpm install  vue-resource –save<br></pre><br>并在main.js中使用</p><p><pre><br>var vueResource = require(‘vue-resource’);<br>Vue.use(vueResource);<br></pre><br>否则会报不认识jsonp属性的错误。</p><p>最后放上GitHub源码地址：<a href="https://github.com/yaoyue1/Vue-" target="_blank" rel="external">https://github.com/yaoyue1/Vue-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 上两篇关于Vue的博文，一篇是环境的搭建和运行，另一篇是自己回顾之前所学的基本指令。这些准备完毕之后，也是时候来写demo练手了，不然好像一直看文档看API也没啥作用，开始啦，自己一边写demo一边把重要的部分记录下来吧。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router(上)</title>
    <link href="http://yaoyue.com/2017/02/17/vue-router-%E4%B8%8A/"/>
    <id>http://yaoyue.com/2017/02/17/vue-router-上/</id>
    <published>2017-02-17T08:59:58.000Z</published>
    <updated>2017-02-17T09:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>接触了点Vue后，自己屁颠屁颠去搜索一些实例的来看，结果各种出现Vue-router，尼玛这又是干嘛的？？？（黑人问号脸），于是去Vue-router的官方文档上瞅瞅，遂写了这篇笔记式的博文。</p><h3 id="vue-router是干嘛的？"><a href="#vue-router是干嘛的？" class="headerlink" title="vue-router是干嘛的？"></a>vue-router是干嘛的？</h3><p>Vue-router是Vue.js的官方路由插件，Vue的单页面应用是基于路由和组件的，路由用于设定访问的路径，并将路径和组件映射起来。之前我们写项目的时候，页面之前的切换时和跳转是通过超链接等来实现的，在Vue-router单页面应用中，则是通过路径的切换。<br><a id="more"></a></p><h3 id="使用基本步骤"><a href="#使用基本步骤" class="headerlink" title="使用基本步骤"></a>使用基本步骤</h3><ol><li>导入文件<br><pre><br>// 导入Vue，这个是必需的，在使用Vue之前，必须先导入<br>import Vue from ‘vue’<br>// 导入 vue-router，并使用<br>import VueRouter from ‘vue-router’<br>Vue.use(VueRouter) </pre></li></ol><hr><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><ol><li><p>定义路由组件。可以从其他文件import进来</p><pre>const Foo = { template: '<div>foo</div>' }const Bar = { template: '<div>bar</div>' }</pre></li><li><p>配置路由</p><pre>const routes = [   {       path: '/foo',       component: Foo   },   {       path: '/bar',       component: Bar   }  ] </pre></li><li>创建router实例<pre>const router = new VueRouter({   routes  // （缩写）相当于 routes: routes})</pre></li><li>创建和挂载根实例<br><pre><br>// 记得要通过 router 配置参数注入路由，<br>// 从而让整个应用都有路由功能<br>const app = new Vue({<br>router<br>}).$mount(‘#app’)//$mount是在Vue实例在实例化的时候没有收到el选项处于“未挂载”状态时手动挂载。<br></pre><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3>定义：使用 <strong>动态路径参数</strong> 把某种模式下匹配到的所有的路由，全部都映射到同一个组件。<h4 id="example-one"><a href="#example-one" class="headerlink" title="example one"></a>example one</h4><pre><br>const User = {<br>template: ‘<div>User</div>‘<br>}</pre></li></ol><p>const router = new VueRouter({<br>  routes: [<br>    // 动态路径参数 以冒号开头<br>    { path: ‘/user/:id’, component: User }<br>  ]<br>})<br></p><h4 id="example-two"><a href="#example-two" class="headerlink" title="example two"></a>example two</h4><p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用,例如我们可以在user模板中输出当前的用户id.同时可以在一个路由中设置多段【路由参数】，对应的值都会在￥route。params中。</p><pre>const User={   template: '<div>User </div>'}</pre><pre>const User = {  template: '<div>User +</div>'}const router = new VueRouter({  routes: [    // 动态路径参数 以冒号开头    { path: '/user/:id/post/:usename', component: User }  ]})</pre><h4 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h4><p>有时，同一个路径可以匹配对个路由，这时，匹配的优先级就会按照路由的定义顺序来：谁先定义的，谁的优先级就最高。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p><router-link> 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的a标签，可以通过配置 tag 属性生成别的标签。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</router-link></p><p><em>router-link比a链接好的原因在于：</em></p><ol><li>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动 关于history 模式、hash 模式讲解，点击<a href="http://blog.csdn.net/hyy1115/article/details/53021807" target="_blank" rel="external">这里</a></li><li>在h5 history模式下，router-link会拦截点击事件，让浏览器不在重新加载页面</li><li>在h5 history模式下使用base选项后，所有的to属性都不需要写基路径了。</li></ol><p>router-link的属性</p><h4 id="to属性"><a href="#to属性" class="headerlink" title="to属性"></a>to属性</h4><p>表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，这个值可以是一个字符串或者是描述目标位置的对象。<br><img src="http://i.imgur.com/s8Z3lij.png" alt=""></p><h4 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h4><p>如果设置了replace属性的话会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;/abc&apos;&#125;&quot; replace&gt; &lt;/router-link&gt;</div></pre></td></tr></table></figure><h4 id="append属性"><a href="#append属性" class="headerlink" title="append属性"></a>append属性</h4><p>设置 append 属性后，则在当前（相对）路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link :to=&quot;&#123; path: &apos;relative/path&apos;&#125;&quot; append&gt;&lt;/router-link&gt;</div></pre></td></tr></table></figure></p><h4 id="tag属性"><a href="#tag属性" class="headerlink" title="tag属性"></a>tag属性</h4><p>有时候想要 <router-link> 渲染成某种标签，例如li于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;</div><div class="line">&lt;li&gt;foo&lt;/li&gt;</div></pre></td></tr></table></figure></router-link></p><h4 id="active-class属性"><a href="#active-class属性" class="headerlink" title="active-class属性"></a>active-class属性</h4><p>设置 链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。</p><h4 id="exact属性"><a href="#exact属性" class="headerlink" title="exact属性"></a>exact属性</h4><p>“是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 <router-link to="/a"> 也会被设置 CSS 类名。</router-link></p><h4 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h4><p>声明可以用来触发导航的事件，可以是一个字符串或者是一个包含字符串的数组</p><h4 id="激活时的CSS类名应用在外层元素"><a href="#激活时的CSS类名应用在外层元素" class="headerlink" title="激活时的CSS类名应用在外层元素"></a>激活时的CSS类名应用在外层元素</h4><p>有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 \<a> 标签本身，那么可以用 <router-link> 渲染外层元素，包裹着内层的原生 \<a> 标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt;</div><div class="line">  &lt;a&gt;/foo&lt;/a&gt;</div><div class="line">&lt;/router-link&gt;</div></pre></td></tr></table></figure></a></router-link></a></p><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p>router-view组件是用来渲染路径匹配到的视图组件的，router-view渲染的组件还可以内嵌到自己的router-view，根据嵌套路径，渲染嵌套组件。</p><p>包含的属性:name属性，string类，默认值为default<br>如果router-view设置了名称，则会渲染对应的路由配置中的components下的相应组件<br><img src="http://i.imgur.com/E5J3a4Y.png" alt=""></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>在模板中再嵌套router-view，在配置路由时必须使用children来配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const User = &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div class=&quot;user&quot;&gt;</div><div class="line">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</div><div class="line">      &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre>const routes: [    { path: '/user/:id', component: User,      children: [        {          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 <router-view> 中          path: 'profile',          component: UserProfile        },        {          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 <router-view> 中          path: 'posts',          component: UserPosts        }      ]    }  ]const router = new VueRouter({  routes})</router-view></router-view></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><h4 id="router-push-location"><a href="#router-push-location" class="headerlink" title="router.push(location)"></a>router.push(location)</h4><p>router.push(location)方法等同于<router-link :to="...">这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL</router-link></p><h4 id="router-replace-location"><a href="#router-replace-location" class="headerlink" title="router.replace(location)"></a>router.replace(location)</h4><p>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><pre>声明式：<router-link :to="..." replace="">编程式：router.replace(...)</router-link></pre>#### router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)<pre>// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)</pre><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><pre><router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link></pre>### 命名视图![](http://i.imgur.com/E5J3a4Y.png)### 重定向和别名『重定向』的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b通过routes的配置来完成。* 重定向到页面<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: '/b' }  ]})</pre>* 重定向到命名路由<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: { name: 'foo' }}  ]})</pre>* 可以是一个方法，动态的重定向到目标<pre>const router = new VueRouter({  routes: [    { path: '/a', redirect: to => {      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    }}  ]})</pre><p>『别名』的意思是：/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</p><p>看到这的时候，公司网速出问题了，已经打不开外网了，正好基础的部分算是已经学习完了，那么后面的进阶就下次来写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触了点Vue后，自己屁颠屁颠去搜索一些实例的来看，结果各种出现Vue-router，尼玛这又是干嘛的？？？（黑人问号脸），于是去Vue-router的官方文档上瞅瞅，遂写了这篇笔记式的博文。&lt;/p&gt;
&lt;h3 id=&quot;vue-router是干嘛的？&quot;&gt;&lt;a href=&quot;#vue-router是干嘛的？&quot; class=&quot;headerlink&quot; title=&quot;vue-router是干嘛的？&quot;&gt;&lt;/a&gt;vue-router是干嘛的？&lt;/h3&gt;&lt;p&gt;Vue-router是Vue.js的官方路由插件，Vue的单页面应用是基于路由和组件的，路由用于设定访问的路径，并将路径和组件映射起来。之前我们写项目的时候，页面之前的切换时和跳转是通过超链接等来实现的，在Vue-router单页面应用中，则是通过路径的切换。&lt;br&gt;
    
    </summary>
    
      <category term="Vue-router" scheme="http://yaoyue.com/categories/Vue-router/"/>
    
    
      <category term="vue-router" scheme="http://yaoyue.com/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃(二)</title>
    <link href="http://yaoyue.com/2017/02/16/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83(%E4%BA%8C)/"/>
    <id>http://yaoyue.com/2017/02/16/vue入门到放弃(二)/</id>
    <published>2017-02-16T08:17:14.000Z</published>
    <updated>2017-08-01T03:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>上一篇记录的是Vue的环境搭建以及如何去运行它。此篇文章是回顾一下自己之前所学的Vue的指令，上次学了一些后，后面公司项目忙断了一段时间，现在都有点记得不是特别清楚了，所以趁着这次写博客，来把之前学习的指令回顾一遍。（所以说看的多不如实际操练几把，说多都是泪）</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="v-text-amp-amp-v-html"><a href="#v-text-amp-amp-v-html" class="headerlink" title="v-text &amp;&amp; v-html"></a>v-text &amp;&amp; v-html</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt;</div><div class="line">var app = new Vue(&#123;</div><div class="line">el: &apos;#app&apos;,   </div><div class="line">data: &#123;</div><div class="line">msg:&apos;&lt; h1 &gt; hi &lt; /h1 &gt;&apos;</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>v-text会把message中有html标签的部分都会显示出来，v-html则会把message中的信息根据html规则进行渲染。<br> <a id="more"></a></p><h4 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h4><ol><li>v-if v-else</li><li>v-show 元素始终渲染保存在DOM中，只是控制display属性。</li><li>v-else-if 类似于if，else if，else</li></ol><pre><code>&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;   A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;   B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;  C&lt;/div&gt;&lt;div v-else&gt;  Not A/B/C&lt;/div&gt;</code></pre><ol><li><p>key控制元素的可重用性：提供一种方式让你自己决定是否重用元素，key后必须带唯一的值，添加key属性的元素就不具有复用性了</p><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p>循环多次渲染元素</p>  <div v-for="(item, index) in items"></div><br>  <div v-for="(val, key) in object"></div><br>  <div v-for="(val, key, index) in object"></div></li></ol><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">绑定事件监听器</div><div class="line"> 方法处理器 </div><div class="line">&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line">内联语句 </div><div class="line">&lt;button v-on:click=&quot;doThat(&apos;hello&apos;, $event)&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line"> 缩写 </div><div class="line">&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line"> 停止冒泡</div><div class="line">&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line"> 阻止默认行为</div><div class="line">&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line">阻止默认行为，没有表达式</div><div class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</div><div class="line"></div><div class="line">串联修饰符</div><div class="line">&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;</div><div class="line"></div><div class="line">键修饰符，键别名</div><div class="line">&lt;input @keyup.enter=&quot;onEnter&quot;&gt;</div><div class="line"></div><div class="line">键修饰符，键代码</div><div class="line">&lt;input @keyup.13=&quot;onEnter&quot;&gt;</div><div class="line">#### v-bind</div><div class="line">绑定一个属性</div><div class="line">&lt;img v-bind:src=&quot;imageSrc&quot;&gt;</div><div class="line"></div><div class="line">缩写</div><div class="line">&lt;img :src=&quot;imageSrc&quot;&gt;</div><div class="line">with inline string concatenation</div><div class="line">&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;</div><div class="line"></div><div class="line"> class 绑定 </div><div class="line">&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</div><div class="line"></div><div class="line">style 绑定 </div><div class="line">&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line"> 绑定一个有属性的对象</div><div class="line">&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">通过 prop 修饰符绑定 DOM 属性</div><div class="line">&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;</div><div class="line">prop 绑定. “prop” 必须在 my-component 中声明。</div><div class="line">&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;</div><div class="line"></div><div class="line">XLink </div><div class="line">&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</div></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>表单输入和应用状态中做数据的双向绑定，能够实时的改变数据。</p><ol><li>v-model.lazy 懒加载，只有失去焦点时数据才更新</li><li>v-model.number 把文本框中的数组转化为数字类型</li><li>v-model.trim 前后删除空格</li><li><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4></li><li>v-pre 跳过这个元素和其子元素的编译过程</li><li>v-cloak 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</li><li>v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过</li></ol><h3 id="vue的keyCode事件"><a href="#vue的keyCode事件" class="headerlink" title="vue的keyCode事件"></a>vue的keyCode事件</h3><p>Vue在监听键盘事件的时候，常需要检测keyCode，Vue允许为v-on添加键盘修饰符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</div><div class="line">缩写</div><div class="line">&lt;input @keyup.enter=&quot;submit&quot;</div></pre></td></tr></table></figure></p><p>按键别名：enter、tab、delete、ese、space、up、down、left、right</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol><li>Error when rendering root instance：污染了原生数据</li><li>Unexpected identifier 当前行或者是前一行少了逗号</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇记录的是Vue的环境搭建以及如何去运行它。此篇文章是回顾一下自己之前所学的Vue的指令，上次学了一些后，后面公司项目忙断了一段时间，现在都有点记得不是特别清楚了，所以趁着这次写博客，来把之前学习的指令回顾一遍。（所以说看的多不如实际操练几把，说多都是泪）&lt;/p&gt;
&lt;h3 id=&quot;常用指令&quot;&gt;&lt;a href=&quot;#常用指令&quot; class=&quot;headerlink&quot; title=&quot;常用指令&quot;&gt;&lt;/a&gt;常用指令&lt;/h3&gt;&lt;h4 id=&quot;v-text-amp-amp-v-html&quot;&gt;&lt;a href=&quot;#v-text-amp-amp-v-html&quot; class=&quot;headerlink&quot; title=&quot;v-text &amp;amp;&amp;amp; v-html&quot;&gt;&lt;/a&gt;v-text &amp;amp;&amp;amp; v-html&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;span v-text=&amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;span v-html=&amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var app = new Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		el: &amp;apos;#app&amp;apos;,   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		data: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			msg:&amp;apos;&amp;lt; h1 &amp;gt; hi &amp;lt; /h1 &amp;gt;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;v-text会把message中有html标签的部分都会显示出来，v-html则会把message中的信息根据html规则进行渲染。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue入门到放弃(一)</title>
    <link href="http://yaoyue.com/2017/02/16/vue%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-%E4%B8%80/"/>
    <id>http://yaoyue.com/2017/02/16/vue入门到放弃-一/</id>
    <published>2017-02-16T03:02:54.000Z</published>
    <updated>2017-02-21T09:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>   校招期间每看一次前端招聘的jd就是一次打击，几乎大多数的公司都会要求你会一个框架Vue或者react.js，因为最近Vue特别火，当然也不是说react.js不火，只是听说Vue对于新手更加的友好，遂入了Vue的坑。在网上搜索了一些教程，可是坑的是很多教程都是1.0版本的，但是Vue的1.0版和2.0版的区别还是比较大的，所以就想把自己的学习过程写下来，一方面是锻炼自己，另一方面也是希望更多像我这样的小白入坑比较容易。<br><a id="more"></a><br>环境搭建+sass安装+项目运行</p><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p><a href="https://nodejs.org/en/http://" target="_blank" rel="external">node官网</a>自行安装，安装好后运行node -v查看node版本，node版本最好是不要过低</p><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p><pre><br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org//全局按照淘宝镜像" target="_blank" rel="external">https://registry.npm.taobao.org//全局按照淘宝镜像</a><br></pre></p><h3 id="安装vue-cli脚手架构建工具"><a href="#安装vue-cli脚手架构建工具" class="headerlink" title="安装vue-cli脚手架构建工具"></a>安装vue-cli脚手架构建工具</h3><p><pre><br>cnpm install -g vue-cli//全局安装 Vue-cli，现在开始Vue就会是一个command<br></pre></p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><pre><br>vue init webpack firstVue //其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称<br></pre><br><img src="http://i.imgur.com/jzsWVIS.png" alt=""></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>进入你的项目文件夹，然后安装依赖,安装完成后你的firstVue文件夹中会多出一个叫node_modules的文件，这里边就是我们项目需要的依赖包资源。</p><p><pre><br>cd firstVue<br>cnpm install//安装依赖<br></pre></p><h3 id="sass安装"><a href="#sass安装" class="headerlink" title="sass安装"></a>sass安装</h3><p>安装sass依赖包</p><p><pre><br>npm install –save-dev sass-loader<br>//sass-loader依赖于node-sass<br>npm install –save-dev node-sass<br></pre><br>安装成功后你的package.json文件会相应的多出几项：<br><img src="http://i.imgur.com/Mhg4BSo.png" alt=""></p><p>在.Vue文件中使用sass时还必须修改style标签如下：</p><pre><code>&lt;style lang=&quot;sass&quot;&gt;//如果的sass的写法是使用大括号的语法这需要改成lang=&quot;scss&quot;</code></pre><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p><pre><br>npm run dev<br></pre><br>运行成功的话，浏览器会自动的打开localhost:8080页面，如果8080端口被占用的话，会提示错误。<br><img src="http://i.imgur.com/eUU0Fsp.png" alt=""></p><p>到这里就算是环境和项目运行成功了，入坑（一）成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   校招期间每看一次前端招聘的jd就是一次打击，几乎大多数的公司都会要求你会一个框架Vue或者react.js，因为最近Vue特别火，当然也不是说react.js不火，只是听说Vue对于新手更加的友好，遂入了Vue的坑。在网上搜索了一些教程，可是坑的是很多教程都是1.0版本的，但是Vue的1.0版和2.0版的区别还是比较大的，所以就想把自己的学习过程写下来，一方面是锻炼自己，另一方面也是希望更多像我这样的小白入坑比较容易。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yaoyue.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
</feed>
