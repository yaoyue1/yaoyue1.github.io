<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiemo blog</title>
  
  <subtitle>前端开发/学生/菜鸟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaoyue.com/"/>
  <updated>2020-07-08T02:39:30.469Z</updated>
  <id>http://yaoyue.com/</id>
  
  <author>
    <name>芥末</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模拟实现Promise.allSettled</title>
    <link href="http://yaoyue.com/2020/07/08/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0Promise.allSettled/"/>
    <id>http://yaoyue.com/2020/07/08/模拟实现Promise.allSettled/</id>
    <published>2020-07-08T01:02:11.000Z</published>
    <updated>2020-07-08T02:39:30.469Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="模拟实现Promise-allSettled"><a href="#模拟实现Promise-allSettled" class="headerlink" title="模拟实现Promise.allSettled"></a>模拟实现Promise.allSettled</h3><pre><code>Promise.allSettled = (iterators) =&gt; {  const promises = Array.from(iterators);  const len = promises.length  const settledList = new Array(len);  let settledNum = 0;  return new Promise((resolve) =&gt; {    promises.map((promise,idx) =&gt; {      Promise.resolve(promise).then((value) =&gt; {        settledList[idx] = {          status:&apos;fulfilled&apos;,          value,        }        if(++settledNum === len){          resolve(settledList)        }      }).settledList(() =&gt; {        timer[idx] = {          status:&apos;rejected&apos;,          reson:value,        }        if(++settledNum === len){          resolve(settledList)        }      })    })  })}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;模拟实现Promise-allSettled&quot;&gt;&lt;a href=&quot;#模拟实现Promise-allSettled&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="每日一题" scheme="http://yaoyue.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="js" scheme="http://yaoyue.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>收集一些题</title>
    <link href="http://yaoyue.com/2020/07/03/css%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yaoyue.com/2020/07/03/css基础知识/</id>
    <published>2020-07-03T06:49:09.000Z</published>
    <updated>2020-07-07T03:37:39.455Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p>问题：了解 Flex 布局么？平常有使用 Flex 进行布局么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;Flex布局&quot;&gt;&lt;a href=&quot;#Flex布局&quot; class=&quot;headerlink&quot; title=&quot;Flex布局&quot;&gt;&lt;/a&gt;Flex布局&lt;/h3&gt;&lt;p&gt;问题：了
      
    
    </summary>
    
      <category term="css基础篇" scheme="http://yaoyue.com/categories/css%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
    
      <category term="css基础" scheme="http://yaoyue.com/tags/css%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>理解EventLoop</title>
    <link href="http://yaoyue.com/2019/06/03/%E7%90%86%E8%A7%A3EventLoop/"/>
    <id>http://yaoyue.com/2019/06/03/理解EventLoop/</id>
    <published>2019-06-03T03:55:43.000Z</published>
    <updated>2019-06-03T07:33:04.679Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>###js单线程？<br>js作为主要运行在浏览器的脚本语言，js主要用途之一是操作DOM。在js高程中举过一个栗子，如果js同时有两个线程，同时对同一个dom进行操作，这时浏览器应该听哪个线程的，如何判断优先级？</p><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>main script运行结束后，会有微任务队列和宏任务队列。微任务先执行，之后是宏任务。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise的executor是一个同步函数，即非异步，立即执行的一个函数，因此他应该是和当前的任务一起执行的。而Promise的链式调用then，每次都会在内部生成一个新的Promise，然后执行then，在执行的过程中不断向微任务(microtask)推入新的函数，因此直至微任务(microtask)的队列清空后才会执行下一波的macrotask。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;###js单线程？&lt;br&gt;js作为主要运行在浏览器的脚本语言，js主要用途之一是操作DOM。在js高程中举过一个栗子，如果js同时有两个线程，同时对同一个dom进行操作，这时
      
    
    </summary>
    
      <category term="学习积累" scheme="http://yaoyue.com/categories/%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="学习" scheme="http://yaoyue.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发尝试与总结</title>
    <link href="http://yaoyue.com/2018/11/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B0%9D%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yaoyue.com/2018/11/12/小程序开发尝试与总结/</id>
    <published>2018-11-12T06:08:30.000Z</published>
    <updated>2018-11-12T06:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="wepy"><a href="#wepy" class="headerlink" title="wepy"></a>wepy</h3><h3 id="taro"><a href="#taro" class="headerlink" title="taro"></a>taro</h3><h3 id="尝试把dva接入taro"><a href="#尝试把dva接入taro" class="headerlink" title="尝试把dva接入taro"></a>尝试把dva接入taro</h3><h3 id="写几个小工具加快开发速度"><a href="#写几个小工具加快开发速度" class="headerlink" title="写几个小工具加快开发速度"></a>写几个小工具加快开发速度</h3><h3 id="小程序开发常见问题总结"><a href="#小程序开发常见问题总结" class="headerlink" title="小程序开发常见问题总结"></a>小程序开发常见问题总结</h3><h3 id="wepy和taro框架比较"><a href="#wepy和taro框架比较" class="headerlink" title="wepy和taro框架比较"></a>wepy和taro框架比较</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;wepy&quot;&gt;&lt;a href=&quot;#wepy&quot; class=&quot;headerlink&quot; title=&quot;wepy&quot;&gt;&lt;/a&gt;wepy&lt;/h3&gt;&lt;h3 id=&quot;taro&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>收集一些题</title>
    <link href="http://yaoyue.com/2018/10/30/shelljs%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yaoyue.com/2018/10/30/shelljs指令学习/</id>
    <published>2018-10-30T09:49:09.000Z</published>
    <updated>2018-11-06T09:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>收集一些题</title>
    <link href="http://yaoyue.com/2018/10/30/%E6%94%B6%E9%9B%86%E4%B8%80%E4%BA%9B%E9%A2%98/"/>
    <id>http://yaoyue.com/2018/10/30/收集一些题/</id>
    <published>2018-10-30T09:49:09.000Z</published>
    <updated>2019-07-08T03:08:49.498Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="js基础部分"><a href="#js基础部分" class="headerlink" title="js基础部分"></a>js基础部分</h2><h2 id="vue相关部分"><a href="#vue相关部分" class="headerlink" title="vue相关部分"></a>vue相关部分</h2><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><ol><li>beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</li><li>created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。<br>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。<br>使用场景:ajax请求和页面初始化</li><li>beforeMount 和 created 拿到的数据相同 在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>mounted中el被创建dom已经更新，vue实例对象中有template参数选项，则将其作为模板编译成render函数，编译优先级render函数选项 &gt; template选项<br>使用场景:常用于获取VNode信息和操作，ajax请求<br>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</li><li>由于beforeUpdate和updated使用的比较少，一般用计算属性和watch代替所以在此不在说明</li><li>destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ol><h3 id="vue响应式原理-数据绑定原理？（get，set；proxy）"><a href="#vue响应式原理-数据绑定原理？（get，set；proxy）" class="headerlink" title="vue响应式原理||数据绑定原理？（get，set；proxy）"></a>vue响应式原理||数据绑定原理？（get，set；proxy）</h3><h3 id="nextTick的理解"><a href="#nextTick的理解" class="headerlink" title="nextTick的理解"></a>nextTick的理解</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>官方：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br>Vue 实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新，即Vue是异步执行DOM更新的<br>异步执行的步骤是：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。<br>所以Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>同步代码执行 -&gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]…<br>nextTick的作用就是修改数据后需要在视图更新之后，基于新的视图进行操作这是时候就要用到nextTick，它相当于一个回调函数<h4 id="nextTick的主要应该场景"><a href="#nextTick的主要应该场景" class="headerlink" title="nextTick的主要应该场景"></a>nextTick的主要应该场景</h4></li><li>created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法，mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</li><li>点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。获取焦点就需用到nextTick</li><li>点击获取元素宽度。原本隐藏的元素显示然后立即获取其宽度属性</li><li>使用 swiper 插件通过 ajax 请求图片后的滑动问题。</li></ol><h3 id="vue更新数组"><a href="#vue更新数组" class="headerlink" title="vue更新数组"></a>vue更新数组</h3><ol><li>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<ul><li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ul></li><li>不更新的原因：<br>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。<br>这是vue实现响应式的原理，也就是说改变data是会触发setter，但是setter和getter是有局限性的，当属性的值为一个数组时，通过索引修改数组某一项的值或使用数组的某些方法修改数组并不能触发set；当属性的值为一对象时，直接修改对象中属性的值时也无法触发set。</li><li>解决<br>解决第一类问题，你可以使用vm.items[indexOfItem] = newValue<br>解决第二类问题，你可以使用 splice：<br>手动触发</li></ol><h3 id="Vue-data为什么必须是函数"><a href="#Vue-data为什么必须是函数" class="headerlink" title="Vue data为什么必须是函数"></a>Vue data为什么必须是函数</h3><p>因为vue的组件是可以复用的，如果data是一个对象的话，那么复用的组件一个更改其中数据，另外的组件数据也会被更改，因此每个实例必须维护一份被返回对象的独立的拷贝才行</p><h3 id="父子组件created，mounted执行顺序？"><a href="#父子组件created，mounted执行顺序？" class="headerlink" title="父子组件created，mounted执行顺序？"></a>父子组件created，mounted执行顺序？</h3><p>父组件beforeCreate =&gt; 父组件created =&gt; 父组件beforeMount =&gt; 子组件beforeCreate =&gt; 子组件created =&gt; 子组件 beforeMount =&gt; 子组件mounted =&gt; 父组件mounted =&gt; 父组件beforeDestroy =&gt; 子组件 beforeDestroy。<br>从创建到挂载，是从外到内，再从内到外，且mixins的钩子函数总是在当前组件之前执行</p><h3 id="组件间如何通信？父子组件，兄弟组件，任意组件？"><a href="#组件间如何通信？父子组件，兄弟组件，任意组件？" class="headerlink" title="组件间如何通信？父子组件，兄弟组件，任意组件？"></a>组件间如何通信？父子组件，兄弟组件，任意组件？</h3><p>1.父子组件：props和$emit<br>2.eventBus:$emit/$on<br>    var Event=new Vue();<br>    Event.$emit(事件名,数据);<br>    Event.$on(事件名,data =&gt; {});<br>3.vuex:Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。<br>缺点：<br>4.</p><h3 id="vue-computed实现。"><a href="#vue-computed实现。" class="headerlink" title="vue computed实现。"></a>vue computed实现。</h3><h3 id="vue-diff算法实现。"><a href="#vue-diff算法实现。" class="headerlink" title="vue diff算法实现。"></a>vue diff算法实现。</h3><h3 id="vue-complier-实现"><a href="#vue-complier-实现" class="headerlink" title="vue complier 实现"></a>vue complier 实现</h3><h3 id="computer和watch用法区别？"><a href="#computer和watch用法区别？" class="headerlink" title="computer和watch用法区别？"></a>computer和watch用法区别？</h3><h2 id="vue-router相关部分"><a href="#vue-router相关部分" class="headerlink" title="vue-router相关部分"></a>vue-router相关部分</h2><h2 id="react相关部分"><a href="#react相关部分" class="headerlink" title="react相关部分"></a>react相关部分</h2><h3 id="虚拟dom实现？"><a href="#虚拟dom实现？" class="headerlink" title="虚拟dom实现？"></a>虚拟dom实现？</h3><ol><li>用JS对象模拟DOM（虚拟DOM）<br>createElement =&gt; {tag, props, children}<br>h函数接受三个参数：标签名、属性、子节点，最终返回一个虚拟 DOM 的对象</li><li>把此虚拟DOM转成真实DOM并插入页面中（render）<br>render方法可以将vNode转化成真实dom<ul><li>接收一个dom对象，通过dom对象的类型来亲自创建一个元素</li><li>for in遍历该dom对象上的props并且给该元素设置属性setAttr</li><li>遍历子节点，如果子节点也是Element的实例，那就给子节点递归调用render方法；反之就说明子节点是个文本节点，通过createTextNode来创建一个文本节点就可以了。</li><li>最后把子节点添加到创建出的元素中，返回该元素<br>setAttr方法是给元素设置属性的</li><li>switch去判断key的值<br>value 有两种标签带有这样的属性，input和textarea 如果是这两种那就直接将value值赋给它的value上 如果不是那就直接调用setAttribute来设置key和value<br>style style属性就可以直接通过cssText来赋值了<br>其他默认的就直接setAttribute设置即可了<br>renderDom将元素插入到页面内</li></ul></li><li><p>如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）<br>先序深度优先遍历<br> function diff (oldNode, newNode) {</p><pre><code>const patches = [] // 声明变量patches用来存放补丁的对象let index = 0; // 第一次比较应该是树的第0个索引 // 递归树 比较后的结果放到补丁里walk(oldNode, newNode, patches, index) // 进行深度优先遍历 // 返回收集到的大补丁return patches</code></pre><p> }<br>walk方法里面比较新旧dom，规则如下：<br>每个元素都有一个补丁，所以需要创建一个放当前补丁的数组</p><ul><li>旧节点不存在，插入新节点；新节点不存在，删除旧节点</li><li>新旧节点如果都是 VNode，且新旧节点 tag 相同</li><li>对比新旧节点的属性</li><li>对比新旧节点的子节点差异，通过 key 值进行重排序，key 值相同节点继续向下遍历</li><li>新旧节点如果都是 VText，判断两者文本是否发生变化</li><li>其他情况直接用新节点替代旧节点<br>当前补丁里确实有值的情况，就将对应的补丁放进大补丁包里</li></ul></li><li><p>把差异对象应用到真正的DOM树上（patch）</p></li></ol><ul><li>用一个变量来得到传递过来的所有补丁allPatches,patch方法接收两个参数(node, patches)</li><li>在方法内部调用walk方法，给某个元素打上补丁,walk方法里获取所有的子节点</li><li>给子节点也进行先序深度优先遍历，递归walk,如果当前的补丁是存在的，那么就对其打补丁(doPatch)</li><li>doPatch打补丁方法会根据传递的patches进行遍历,判断补丁的类型来进行不同的操作<ol><li>属性ATTR,for in去遍历attrs对象，当前的key值如果存在，就直接设置属性setAttr； 如果不存在对应的key值那就直接删除这个key键的属性</li><li>文字TEXT,直接将补丁的text赋值给node节点的textContent即可</li><li>替换REPLACE,新节点替换老节点，需要先判断新节点是不是Element的实例，是的话调用render方法渲染新节点；</li><li>不是的话就表明新节点是个文本节点，直接创建一个文本节点就OK了,之后再通过调用父级parentNode的replaceChild方法替换为新的节点</li><li>删除REMOVE,直接调用父级的removeChild方法删除该节点<br>虚拟dom总结：如果没有虚拟dom的话，对比dom是极其困难的，所以最好的方法是重新生成一棵新的树来替换，但这种做性能很差，特别是dom节点过多且改变极少的时候。为了解决这个问题，在dom上方放一层只含有部分必要信息的虚拟dom，当改变发生的时候，精确匹配需要更新的dom，attributes、event listener…然后再精确的更新到真实dom上，减少受影响的dom。但既然有了虚拟层，自然就有了跨平台的副产物，比如像RN，taro等多端统一的框架。事实上，虚拟dom并非那么高效。尤其是dom节点足够小的情况下、或者确实需要整个替换的情况下，直接生成一棵树比diff后再生成要明显高效很多。但虚拟dom的好处是提供了多数场景下的一种通用处理方法。<h2 id="http相关部分"><a href="#http相关部分" class="headerlink" title="http相关部分"></a>http相关部分</h2><h2 id="html布局渲染等相关部分"><a href="#html布局渲染等相关部分" class="headerlink" title="html布局渲染等相关部分"></a>html布局渲染等相关部分</h2><h2 id="git操作相关部分"><a href="#git操作相关部分" class="headerlink" title="git操作相关部分"></a>git操作相关部分</h2><h2 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h2></li></ol></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>5种基本类型：undefined,null,number,string,boolean</p><h3 id="理解原型和原型链"><a href="#理解原型和原型链" class="headerlink" title="理解原型和原型链"></a>理解原型和原型链</h3><p>Js对象在创建时就包含一个隐式的内部属性<em>proto</em>，这个属性是不可以被直接访问的（<em>proto</em>是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性<em>proto</em>)，这个内部属性指向的就是该对象的原型<br>a.<em>proto</em> = foo.prototype<br><a id="more"></a><br>Construct:<br>原型对象还包含一个construct属性，这个属性指向的是创建所有实例的指向该原型对象的构造函数，即指向的就是那个构造函数<br>Prototype<br>每个函数对象都有一个prototype属性，当这个函数被用来当作构造函数来创建实例的时候，prototype的属性值就会被用来赋值给实例的的<em>proto</em>属性<br>实际上在JavaScript中，所有对象的原型都将追溯到”Object {}”对象<br>所以：实例.<em>proto</em> = fun.prototype<br>fun.prototype.<em>proto</em> = object<br>fun.prototype.construct = fun 函数本身</p><p>函数对象和fun.prototype对象相互引用 ： fun.prototype.construct = fun,  fun.prototype 为该对象</p><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用继承的属性和方法</p><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>我理解的作用域就是你的代码在运行时，各个变量、函数和对象的可访问性或者说是一个作用范围。因为函数本身也是一个作用域，所以作用域分为全局作用域和局部作用域<br>在全局中声明的变量方法可以在任何地方调用，在函数内部申明的局部变量，只能在函数内部访问。<br>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问</p><p>函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量<br>闭包：闭包就是能够读取其他函数内部变量的函数，定义在一个函数内部的函数<br>闭包有两个作用：<br>第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）<br>第二个就是让这些外部变量始终保存在内存中 </p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol><li>减少延迟加快网页打开速度</li><li>重复利用资源减少网络带宽消耗</li><li>降低请求次数或者减少传输内容从而减轻服务器压力。<br>浏览器HTTP缓存可以分为强缓存和协商缓存：<br>#### </li><li>强缓存：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache）</li><li>协商缓存： 协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。</li><li>http1.0中的缓存控制：<br>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）<br>Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41<br>If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内</li><li>http1.1中的缓存控制：<br>Cache-Control：缓存控制头部，有no-cache、max-age等多种取值<br>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算<br>If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ol><h3 id="大公司前端资源部署的方案"><a href="#大公司前端资源部署的方案" class="headerlink" title="大公司前端资源部署的方案"></a>大公司前端资源部署的方案</h3><p><a href="https://www.zhihu.com/question/20790576" target="_blank" rel="external">https://www.zhihu.com/question/20790576</a></p><h3 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h3><h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><ol><li>客户端发送一个syn标志的报文，seq发送序号为x</li><li>服务端发送带ack标志和syn标志的报文，seq发送序号为y，表示对客户端syn报文的回应同时询问客户端是否准备好进行数据通讯</li><li>客户端必须再发送ack报文，seq发送序号为z，回应服务端<br>qa：为什么是三次不是两次？<br>主要是为了防止已失效的连接请求报文段突然又传送到服务端导致的出错。因为如果客户端发出的第一个连接请求报文段没有丢失而且是在某些网络结点长时间滞留了，以致延误到连接释放后的某个时间才到达服务端，如果是只有2次的话，服务端这个时候一旦确认，连接就已经建立了，但这个时候客户端并没有发出连接请求也就不会理睬服务端，这样服务端的许多资源就会白白浪费。<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4></li><li>客户端向tcp发出连接释放报文段fin=1，序号seq=u，并停止再发送数据，主动关闭tcp连接，进入fin-wait-1（终止等待1）状态，等待服务端的确认</li><li>服务端收到连接释放报文段后发出确认报文段，ACK=1，确认号ack=u+1，序号seq=u+1，服务端进入关闭等待状态，此时的tcp处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后，进入fin-wait-2（终止等待2）状态，等待服务端发出连接释放报文段</li><li>服务端没有要想客户端发送的数据，服务端发出连接释放报文段，fin=1，ACk=1，序号seq=w，确认号ack=u+1，服务端进入最后确认状态，等待客户端的确认</li><li>客户端收到服务端的连接释放报文段后，发出确认报文段，ACK=1,seq=u+1,ack=w+1,客户端进入时间等待状态，此时tcp未释放掉，需要经过时间等待计时器设置的2MSL后，客户端才进入到关闭状态</li></ol><p>qa：为什么time-wait状态必须等待2MSL（最长报文段寿命）？</p><ol><li>保证客户端发送的最后一个ack报文段能够到达服务端，因为这个报文段可能丢失，是的处于最后确认状态的服务端收不到确认信息，服务端超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态</li><li>防止已失效的连接请求报文段出现在本连接中，A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。<br>qa：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>因为服务端收到客户端发送来的fin报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，等服务端确定不会再发送数据后，在发送fin报文，来释放连接</li></ol><h3 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="dns域名解析过程"></a>dns域名解析过程</h3><ol><li>浏览器搜索自身dns缓存，看看缓存有没有过期，过期缓存的解析就结束，chrome缓存的时间只有一分钟</li><li>搜索操作系统自身的dns缓存，没有找到或失效解析结束</li><li>读取本地的hosts文件，hosts文件可以建立域名到ip的绑定</li><li>浏览器发起一个dns系统调用，调用解析器后，解析器会向运营商服务器发送查询信息，运营商服务会先查找自身缓存，若没有，则主控服务器会代替浏览器发起一个迭代的DNS解析的请求，先查找根域的，运营商服务器拿到域名的IP，返回给操作系统的内核，同时缓存在了自己的缓存区，操作系统内核从DNS服务商拿来的IP地址返回给浏览器。<br><a href="https://juejin.im/entry/599109d46fb9a03c4c270f82" target="_blank" rel="external">https://juejin.im/entry/599109d46fb9a03c4c270f82</a></li></ol><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><ol><li>应用层(dns,http) DNS解析成IP并发送http请求</li><li>传输层(tcp,udp) 建立tcp连接（三次握手）</li><li>网络层(IP,ARP) IP寻址</li><li>数据链路层(PPP) 封装成帧</li><li>物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</li></ol><h3 id="浏览器解析资源过程"><a href="#浏览器解析资源过程" class="headerlink" title="浏览器解析资源过程"></a>浏览器解析资源过程</h3><p>浏览器内核拿到内容后，渲染的步骤大致可分为以下几个步骤：</p><ol><li>解析html，构建dom tree<ul><li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li><li>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li><li>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li><li>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</li></ul></li><li>解析css，生成css规则树<br> Bytes → characters → tokens → nodes → CSSOM，和解析html类似，也是最终生成css的规则树结构</li><li>合并dom树和css规则树，生成render树（dom树和css规则树并不是严格意义上的一对一关系，head这种不可见的标签或者display：none等就会不显示）</li><li>布局render树（layout／reflow），负责各元素尺寸，位置的计算<br>计算css样式，构建渲染树，布局（主要定位坐标和大小，是否换行，各种position，overflow，z-index属性）</li><li><p>绘制render树（paint），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p></li></ol><h3 id="浏览器对于静态资源的处理方式"><a href="#浏览器对于静态资源的处理方式" class="headerlink" title="浏览器对于静态资源的处理方式"></a>浏览器对于静态资源的处理方式</h3><p>这里将遇到的静态资源分为一下几大类（未列举所有）：<br>CSS样式资源<br>JS脚本资源<br>img图片类资源</p><ol><li>遇到外链时的处理<br>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</li><li>遇到CSS样式资源<br>CSS资源的处理有几个特点：<ul><li>CSS下载时异步，不会阻塞浏览器构建DOM树</li><li>会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>media query声明的CSS是不会阻塞渲染的</li></ul></li><li>遇到JS脚本资源<br>JS脚本资源的处理有几个特点：<ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul></li><li>遇到img图片类资源<br>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</li></ol><h3 id="回流和重绘，哪些操作会引起回流，哪些会引起重绘"><a href="#回流和重绘，哪些操作会引起回流，哪些会引起重绘" class="headerlink" title="回流和重绘，哪些操作会引起回流，哪些会引起重绘"></a>回流和重绘，哪些操作会引起回流，哪些会引起重绘</h3><p>回流一定会引起重绘，重绘不一定会引起回流</p><ol><li>回流：元素的内容，结构，位置或者尺寸发生了变化，需要重新计算样式和渲染树</li><li>重绘： 元素的改变只影响元素的外观之类eg：背景色，边框颜色，文字颜色等</li></ol><p>引起回流：</p><ol><li>页面首次渲染</li><li>dom tree结构改变，添加或者删除可见的DOM元素</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法<br> （1）offset(Top/Left/Width/Height)<br>  (2) scroll(Top/Left/Width/Height)<br>  (3) cilent(Top/Left/Width/Height)<br>  (4) width,height<br>  (5) 调用了getComputedStyle()或者IE的currentStyle</li></ol><h3 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h3><p>浏览器渲染的图层一般分为普通图层和复合图层<br>普通文档流可以看作为一个默认复合层，absolute，fixed等虽然脱离了普通文档流但是仍然属于默认复合层</p><p>可以通过硬件加速的方式，声明一个新的复合层，它会单独分配资源，这样久不影响默认复合层里的回流重绘，这是由于浏览器的GPU中，各个复合图层是单独绘制的，互不影响</p><h4 id="如何变成复合层？"><a href="#如何变成复合层？" class="headerlink" title="如何变成复合层？"></a>如何变成复合层？</h4><ol><li>最常见的方式：translate3d，translateZ</li><li>opacity属性／过渡动画（执行的过程才会创建复合层）</li><li>video，iframe，canvas，webgl等元素</li><li>flash插件等</li></ol><p>复合图层的作用：可以使得元素独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，但是复合图层过多也会导致资源消耗过度，反而更卡<br>注意：硬件加速请使用index，因为如果加速的元素层级较低的话，后面的层级较高的元素会被隐式的转换为同一个复合图层，如此会影响性能</p><h3 id="script标签中的async和defer的区别"><a href="#script标签中的async和defer的区别" class="headerlink" title="script标签中的async和defer的区别"></a>script标签中的async和defer的区别</h3><p>浏览器在执行HTML的时候如果遇到script时会停止页面的渲染,去下载和执行js的文件直接遇见/scirpt会继续渲染页面。故浏览器在执行js文件的时候浏览器表现为一片空白,为了解决这个问题ECMAScript定义了defer和async两个属性用于控制JS的下载和执行</p><ol><li>defer: 对于defer，我们可以认为是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用</li><li>async的情况下，js一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果js前后有依赖性，用async，就很有可能出错。</li></ol><h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><ol><li><p>正向代理：是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。（翻墙）</p></li><li><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。（负载均衡）</p></li></ol><h3 id="get和post请求区别"><a href="#get和post请求区别" class="headerlink" title="get和post请求区别"></a>get和post请求区别</h3><ol><li>GET使用URL或Cookie传参，而POST将数据放在BODY中。</li><li>GET方式提交的数据有长度限制，则POST的数据则可以非常大。</li><li>POST比GET安全，因为数据在地址栏上不可见。</li><li>get会产生一个tcp数据包，post产生2个，get请求时，浏览器会把headers和data一起发送出去，服务器响应200返回数据，post请求时，浏览器会先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200返回数据</li><li>GET请求是幂等性的，POST请求不是。（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。）正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</li></ol><h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>SSL/TLS握手流程</p><ol><li>浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </li><li>服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器<br>（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li><li>浏览器收到服务端的证书后<ul><li>验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</li><li>用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<code>Premaster secret</code>，发送给服务器。</li><li>利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-<code>session key</code></li><li>使用约定好的HASH算法计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。 </li></ul></li><li>服务端收到浏览器的回复<ul><li>利用已知的加解密方式与自己的私钥进行解密，获取<code>Premaster secret</code></li><li>和浏览器相同规则生成<code>session key</code></li><li>使用<code>session key</code>解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</li><li>使用<code>session key</code>加密一段握手消息，发送给浏览器 </li></ul></li><li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</li></ol><h3 id="首页白屏优化方式"><a href="#首页白屏优化方式" class="headerlink" title="首页白屏优化方式"></a>首页白屏优化方式</h3><h4 id="为什么会存在白屏？"><a href="#为什么会存在白屏？" class="headerlink" title="为什么会存在白屏？"></a>为什么会存在白屏？</h4><p>因为要打开一个webview页面它做了很多的事情：<br>初始化webview =&gt; 域名解析 =&gt; 请求页面 =&gt; 下载数据 =&gt; 解析dom树 =&gt; 解析css规则树 =&gt; 解析js =&gt; js请求数据 =&gt; 解析渲染 =&gt; 下载渲染图片<br>大致上分为以上，页面在 dom 渲染后才能显示雏形，所以这个过程一长就会导致白屏</p><h4 id="优化的几种方式"><a href="#优化的几种方式" class="headerlink" title="优化的几种方式"></a>优化的几种方式</h4><ol><li>降低请求量：合并请求资源，减少http请求数量，minify / gzip 压缩，懒加载</li><li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li><li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。</li><li>渲染：JS/CSS优化（GUI渲染线程与JS引擎线程互斥，而且js引擎为单线程，js执行时间过长是会阻塞页面加载的），加载顺序，服务端渲染，pipeline</li><li>服务端渲染，客户端缓存<br><a href="https://juejin.im/entry/599646856fb9a02484490c13" target="_blank" rel="external">https://juejin.im/entry/599646856fb9a02484490c13</a></li></ol><h3 id="数组的slice和splice方法"><a href="#数组的slice和splice方法" class="headerlink" title="数组的slice和splice方法"></a>数组的slice和splice方法</h3><p>slice: 返回数组中的一项或者几项，slice(1) 从位置1到数组最后，slice(1,4)从数组位置1到位置3，位置是从0开始<br>splice: 删除，插入，替换数组中的元素。splice(0,2,’jiemo’,’jiemo1 ‘) 从位置0开始 删除2项，然后插入’jiemo’,’jiemo1’</p><h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明：解析器会率先读取函数声明，使其在执行任何代码之前都可访问<br>函数表达式：必须等解析器执行到它所在的代码行，才会真正被解释执行</p><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ol><li>工厂模式<br>缺点：没有解决对象的识别问题</li><li>构造函数模式</li></ol><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>字节按照一定规则在空间上排列就是字节对齐</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>大致分三步：<br>1、找基准（一般是以中间项为基准）<br>2、遍历数组，小于基准的放在left，大于基准的放在right<br>3、递归<br>function quickSort(arr){<br>    //如果数组&lt;=1,则直接返回<br>    if(arr.length&lt;=1){return arr;}<br>    var pivotIndex=Math.floor(arr.length/2);<br>    //找基准，并把基准从原数组删除<br>    var pivot=arr.splice(pivotIndex,1)[0];<br>    //定义左右数组<br>    var left=[];<br>    var right=[];</p><pre><code>//比基准小的放在left，比基准大的放在rightfor(var i=0;i&lt;arr.length;i++){    if(arr[i]&lt;=pivot){        left.push(arr[i]);    }    else{        right.push(arr[i]);    }}//递归return quickSort(left).concat([pivot],quickSort(right));</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js基础部分&quot;&gt;&lt;a href=&quot;#js基础部分&quot; class=&quot;headerlink&quot; title=&quot;js基础部分&quot;&gt;&lt;/a&gt;js基础部分&lt;/h2&gt;&lt;h2 id=&quot;vue相关部分&quot;&gt;&lt;a href=&quot;#vue相关部分&quot; class=&quot;headerlink&quot; title=&quot;vue相关部分&quot;&gt;&lt;/a&gt;vue相关部分&lt;/h2&gt;&lt;h3 id=&quot;vue生命周期&quot;&gt;&lt;a href=&quot;#vue生命周期&quot; class=&quot;headerlink&quot; title=&quot;vue生命周期&quot;&gt;&lt;/a&gt;vue生命周期&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。&lt;/li&gt;
&lt;li&gt;created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。&lt;br&gt;在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。&lt;br&gt;使用场景:ajax请求和页面初始化&lt;/li&gt;
&lt;li&gt;beforeMount 和 created 拿到的数据相同 在挂载开始之前被调用：相关的 render 函数首次被调用。&lt;/li&gt;
&lt;li&gt;mounted中el被创建dom已经更新，vue实例对象中有template参数选项，则将其作为模板编译成render函数，编译优先级render函数选项 &amp;gt; template选项&lt;br&gt;使用场景:常用于获取VNode信息和操作，ajax请求&lt;br&gt;注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted&lt;/li&gt;
&lt;li&gt;由于beforeUpdate和updated使用的比较少，一般用计算属性和watch代替所以在此不在说明&lt;/li&gt;
&lt;li&gt;destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;vue响应式原理-数据绑定原理？（get，set；proxy）&quot;&gt;&lt;a href=&quot;#vue响应式原理-数据绑定原理？（get，set；proxy）&quot; class=&quot;headerlink&quot; title=&quot;vue响应式原理||数据绑定原理？（get，set；proxy）&quot;&gt;&lt;/a&gt;vue响应式原理||数据绑定原理？（get，set；proxy）&lt;/h3&gt;&lt;h3 id=&quot;nextTick的理解&quot;&gt;&lt;a href=&quot;#nextTick的理解&quot; class=&quot;headerlink&quot; title=&quot;nextTick的理解&quot;&gt;&lt;/a&gt;nextTick的理解&lt;/h3&gt;&lt;h4 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h4&gt;&lt;p&gt;官方：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。&lt;br&gt;Vue 实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新，即Vue是异步执行DOM更新的&lt;br&gt;异步执行的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有同步任务都在主线程上执行，形成一个执行栈&lt;/li&gt;
&lt;li&gt;主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。&lt;/li&gt;
&lt;li&gt;一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。&lt;/li&gt;
&lt;li&gt;主线程不断重复上面的第三步。&lt;br&gt;所以Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。&lt;br&gt;同步代码执行 -&amp;gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&amp;gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]…&lt;br&gt;nextTick的作用就是修改数据后需要在视图更新之后，基于新的视图进行操作这是时候就要用到nextTick，它相当于一个回调函数&lt;h4 id=&quot;nextTick的主要应该场景&quot;&gt;&lt;a href=&quot;#nextTick的主要应该场景&quot; class=&quot;headerlink&quot; title=&quot;nextTick的主要应该场景&quot;&gt;&lt;/a&gt;nextTick的主要应该场景&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法，mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted&lt;/li&gt;
&lt;li&gt;点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。获取焦点就需用到nextTick&lt;/li&gt;
&lt;li&gt;点击获取元素宽度。原本隐藏的元素显示然后立即获取其宽度属性&lt;/li&gt;
&lt;li&gt;使用 swiper 插件通过 ajax 请求图片后的滑动问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;vue更新数组&quot;&gt;&lt;a href=&quot;#vue更新数组&quot; class=&quot;headerlink&quot; title=&quot;vue更新数组&quot;&gt;&lt;/a&gt;vue更新数组&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;由于 JavaScript 的限制，Vue 不能检测以下变动的数组：&lt;ul&gt;
&lt;li&gt;当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue&lt;/li&gt;
&lt;li&gt;当你修改数组的长度时，例如：vm.items.length = newLength&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不更新的原因：&lt;br&gt;当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。&lt;br&gt;这是vue实现响应式的原理，也就是说改变data是会触发setter，但是setter和getter是有局限性的，当属性的值为一个数组时，通过索引修改数组某一项的值或使用数组的某些方法修改数组并不能触发set；当属性的值为一对象时，直接修改对象中属性的值时也无法触发set。&lt;/li&gt;
&lt;li&gt;解决&lt;br&gt;解决第一类问题，你可以使用vm.items[indexOfItem] = newValue&lt;br&gt;解决第二类问题，你可以使用 splice：&lt;br&gt;手动触发&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Vue-data为什么必须是函数&quot;&gt;&lt;a href=&quot;#Vue-data为什么必须是函数&quot; class=&quot;headerlink&quot; title=&quot;Vue data为什么必须是函数&quot;&gt;&lt;/a&gt;Vue data为什么必须是函数&lt;/h3&gt;&lt;p&gt;因为vue的组件是可以复用的，如果data是一个对象的话，那么复用的组件一个更改其中数据，另外的组件数据也会被更改，因此每个实例必须维护一份被返回对象的独立的拷贝才行&lt;/p&gt;
&lt;h3 id=&quot;父子组件created，mounted执行顺序？&quot;&gt;&lt;a href=&quot;#父子组件created，mounted执行顺序？&quot; class=&quot;headerlink&quot; title=&quot;父子组件created，mounted执行顺序？&quot;&gt;&lt;/a&gt;父子组件created，mounted执行顺序？&lt;/h3&gt;&lt;p&gt;父组件beforeCreate =&amp;gt; 父组件created =&amp;gt; 父组件beforeMount =&amp;gt; 子组件beforeCreate =&amp;gt; 子组件created =&amp;gt; 子组件 beforeMount =&amp;gt; 子组件mounted =&amp;gt; 父组件mounted =&amp;gt; 父组件beforeDestroy =&amp;gt; 子组件 beforeDestroy。&lt;br&gt;从创建到挂载，是从外到内，再从内到外，且mixins的钩子函数总是在当前组件之前执行&lt;/p&gt;
&lt;h3 id=&quot;组件间如何通信？父子组件，兄弟组件，任意组件？&quot;&gt;&lt;a href=&quot;#组件间如何通信？父子组件，兄弟组件，任意组件？&quot; class=&quot;headerlink&quot; title=&quot;组件间如何通信？父子组件，兄弟组件，任意组件？&quot;&gt;&lt;/a&gt;组件间如何通信？父子组件，兄弟组件，任意组件？&lt;/h3&gt;&lt;p&gt;1.父子组件：props和$emit&lt;br&gt;2.eventBus:$emit/$on&lt;br&gt;    var Event=new Vue();&lt;br&gt;    Event.$emit(事件名,数据);&lt;br&gt;    Event.$on(事件名,data =&amp;gt; {});&lt;br&gt;3.vuex:Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。&lt;br&gt;缺点：&lt;br&gt;4.&lt;/p&gt;
&lt;h3 id=&quot;vue-computed实现。&quot;&gt;&lt;a href=&quot;#vue-computed实现。&quot; class=&quot;headerlink&quot; title=&quot;vue computed实现。&quot;&gt;&lt;/a&gt;vue computed实现。&lt;/h3&gt;&lt;h3 id=&quot;vue-diff算法实现。&quot;&gt;&lt;a href=&quot;#vue-diff算法实现。&quot; class=&quot;headerlink&quot; title=&quot;vue diff算法实现。&quot;&gt;&lt;/a&gt;vue diff算法实现。&lt;/h3&gt;&lt;h3 id=&quot;vue-complier-实现&quot;&gt;&lt;a href=&quot;#vue-complier-实现&quot; class=&quot;headerlink&quot; title=&quot;vue complier 实现&quot;&gt;&lt;/a&gt;vue complier 实现&lt;/h3&gt;&lt;h3 id=&quot;computer和watch用法区别？&quot;&gt;&lt;a href=&quot;#computer和watch用法区别？&quot; class=&quot;headerlink&quot; title=&quot;computer和watch用法区别？&quot;&gt;&lt;/a&gt;computer和watch用法区别？&lt;/h3&gt;&lt;h2 id=&quot;vue-router相关部分&quot;&gt;&lt;a href=&quot;#vue-router相关部分&quot; class=&quot;headerlink&quot; title=&quot;vue-router相关部分&quot;&gt;&lt;/a&gt;vue-router相关部分&lt;/h2&gt;&lt;h2 id=&quot;react相关部分&quot;&gt;&lt;a href=&quot;#react相关部分&quot; class=&quot;headerlink&quot; title=&quot;react相关部分&quot;&gt;&lt;/a&gt;react相关部分&lt;/h2&gt;&lt;h3 id=&quot;虚拟dom实现？&quot;&gt;&lt;a href=&quot;#虚拟dom实现？&quot; class=&quot;headerlink&quot; title=&quot;虚拟dom实现？&quot;&gt;&lt;/a&gt;虚拟dom实现？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;用JS对象模拟DOM（虚拟DOM）&lt;br&gt;createElement =&amp;gt; {tag, props, children}&lt;br&gt;h函数接受三个参数：标签名、属性、子节点，最终返回一个虚拟 DOM 的对象&lt;/li&gt;
&lt;li&gt;把此虚拟DOM转成真实DOM并插入页面中（render）&lt;br&gt;render方法可以将vNode转化成真实dom&lt;ul&gt;
&lt;li&gt;接收一个dom对象，通过dom对象的类型来亲自创建一个元素&lt;/li&gt;
&lt;li&gt;for in遍历该dom对象上的props并且给该元素设置属性setAttr&lt;/li&gt;
&lt;li&gt;遍历子节点，如果子节点也是Element的实例，那就给子节点递归调用render方法；反之就说明子节点是个文本节点，通过createTextNode来创建一个文本节点就可以了。&lt;/li&gt;
&lt;li&gt;最后把子节点添加到创建出的元素中，返回该元素&lt;br&gt;setAttr方法是给元素设置属性的&lt;/li&gt;
&lt;li&gt;switch去判断key的值&lt;br&gt;value 有两种标签带有这样的属性，input和textarea 如果是这两种那就直接将value值赋给它的value上 如果不是那就直接调用setAttribute来设置key和value&lt;br&gt;style style属性就可以直接通过cssText来赋值了&lt;br&gt;其他默认的就直接setAttribute设置即可了&lt;br&gt;renderDom将元素插入到页面内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）&lt;br&gt;先序深度优先遍历&lt;br&gt; function diff (oldNode, newNode) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const patches = [] // 声明变量patches用来存放补丁的对象
let index = 0; // 第一次比较应该是树的第0个索引 
// 递归树 比较后的结果放到补丁里
walk(oldNode, newNode, patches, index) // 进行深度优先遍历 
// 返回收集到的大补丁
return patches
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt;walk方法里面比较新旧dom，规则如下：&lt;br&gt;每个元素都有一个补丁，所以需要创建一个放当前补丁的数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧节点不存在，插入新节点；新节点不存在，删除旧节点&lt;/li&gt;
&lt;li&gt;新旧节点如果都是 VNode，且新旧节点 tag 相同&lt;/li&gt;
&lt;li&gt;对比新旧节点的属性&lt;/li&gt;
&lt;li&gt;对比新旧节点的子节点差异，通过 key 值进行重排序，key 值相同节点继续向下遍历&lt;/li&gt;
&lt;li&gt;新旧节点如果都是 VText，判断两者文本是否发生变化&lt;/li&gt;
&lt;li&gt;其他情况直接用新节点替代旧节点&lt;br&gt;当前补丁里确实有值的情况，就将对应的补丁放进大补丁包里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把差异对象应用到真正的DOM树上（patch）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;用一个变量来得到传递过来的所有补丁allPatches,patch方法接收两个参数(node, patches)&lt;/li&gt;
&lt;li&gt;在方法内部调用walk方法，给某个元素打上补丁,walk方法里获取所有的子节点&lt;/li&gt;
&lt;li&gt;给子节点也进行先序深度优先遍历，递归walk,如果当前的补丁是存在的，那么就对其打补丁(doPatch)&lt;/li&gt;
&lt;li&gt;doPatch打补丁方法会根据传递的patches进行遍历,判断补丁的类型来进行不同的操作&lt;ol&gt;
&lt;li&gt;属性ATTR,for in去遍历attrs对象，当前的key值如果存在，就直接设置属性setAttr； 如果不存在对应的key值那就直接删除这个key键的属性&lt;/li&gt;
&lt;li&gt;文字TEXT,直接将补丁的text赋值给node节点的textContent即可&lt;/li&gt;
&lt;li&gt;替换REPLACE,新节点替换老节点，需要先判断新节点是不是Element的实例，是的话调用render方法渲染新节点；&lt;/li&gt;
&lt;li&gt;不是的话就表明新节点是个文本节点，直接创建一个文本节点就OK了,之后再通过调用父级parentNode的replaceChild方法替换为新的节点&lt;/li&gt;
&lt;li&gt;删除REMOVE,直接调用父级的removeChild方法删除该节点&lt;br&gt;虚拟dom总结：如果没有虚拟dom的话，对比dom是极其困难的，所以最好的方法是重新生成一棵新的树来替换，但这种做性能很差，特别是dom节点过多且改变极少的时候。为了解决这个问题，在dom上方放一层只含有部分必要信息的虚拟dom，当改变发生的时候，精确匹配需要更新的dom，attributes、event listener…然后再精确的更新到真实dom上，减少受影响的dom。但既然有了虚拟层，自然就有了跨平台的副产物，比如像RN，taro等多端统一的框架。事实上，虚拟dom并非那么高效。尤其是dom节点足够小的情况下、或者确实需要整个替换的情况下，直接生成一棵树比diff后再生成要明显高效很多。但虚拟dom的好处是提供了多数场景下的一种通用处理方法。&lt;h2 id=&quot;http相关部分&quot;&gt;&lt;a href=&quot;#http相关部分&quot; class=&quot;headerlink&quot; title=&quot;http相关部分&quot;&gt;&lt;/a&gt;http相关部分&lt;/h2&gt;&lt;h2 id=&quot;html布局渲染等相关部分&quot;&gt;&lt;a href=&quot;#html布局渲染等相关部分&quot; class=&quot;headerlink&quot; title=&quot;html布局渲染等相关部分&quot;&gt;&lt;/a&gt;html布局渲染等相关部分&lt;/h2&gt;&lt;h2 id=&quot;git操作相关部分&quot;&gt;&lt;a href=&quot;#git操作相关部分&quot; class=&quot;headerlink&quot; title=&quot;git操作相关部分&quot;&gt;&lt;/a&gt;git操作相关部分&lt;/h2&gt;&lt;h2 id=&quot;开放问题&quot;&gt;&lt;a href=&quot;#开放问题&quot; class=&quot;headerlink&quot; title=&quot;开放问题&quot;&gt;&lt;/a&gt;开放问题&lt;/h2&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;&lt;p&gt;5种基本类型：undefined,null,number,string,boolean&lt;/p&gt;
&lt;h3 id=&quot;理解原型和原型链&quot;&gt;&lt;a href=&quot;#理解原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;理解原型和原型链&quot;&gt;&lt;/a&gt;理解原型和原型链&lt;/h3&gt;&lt;p&gt;Js对象在创建时就包含一个隐式的内部属性&lt;em&gt;proto&lt;/em&gt;，这个属性是不可以被直接访问的（&lt;em&gt;proto&lt;/em&gt;是chrom和firefox支持查看的，后面Object.getPrototype(object)才正式支持查看内部属性&lt;em&gt;proto&lt;/em&gt;)，这个内部属性指向的就是该对象的原型&lt;br&gt;a.&lt;em&gt;proto&lt;/em&gt; = foo.prototype&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>rem适配</title>
    <link href="http://yaoyue.com/2017/11/16/rem%E9%80%82%E9%85%8D/"/>
    <id>http://yaoyue.com/2017/11/16/rem适配/</id>
    <published>2017-11-16T07:21:38.000Z</published>
    <updated>2017-11-16T06:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>   实在是惭愧，做h5这么久了，居然连适配的问题一直没有搞明白。在公司写项目的时候总是用的模板，一行命令就生成了，直接就上手用了，适配也是模板中直接弄好的。又由于之前的自己一直是做pc端的，h5基础很是不牢靠，忽略了好的基本的知识。直到今天才真正下决心要把这个rem适配给完全弄明白。</p><h3 id="为什么要是适配"><a href="#为什么要是适配" class="headerlink" title="为什么要是适配"></a>为什么要是适配</h3><p>  面对不同分辨率的手机不同屏幕尺寸的手机希望展示的一样比例的页面</p><h3 id="适配的原理"><a href="#适配的原理" class="headerlink" title="适配的原理"></a>适配的原理</h3><h4 id="相关尺寸和名词介绍"><a href="#相关尺寸和名词介绍" class="headerlink" title="相关尺寸和名词介绍"></a>相关尺寸和名词介绍</h4><p>目前我们选取的一款手机屏幕宽高基准为iphone6的375 x 667。<br>物理像素：物理像素是显示屏上最小的物理显示单元<br>设备独立像素：计算机系统中的一个点，可以由程序使用的最小单元，也可称为css像素<br>位图像素：图片最小的数据单元，1个位图像素对应于1个物理像素时，图片才会清晰的展现<br>设备像素比：<br>    设备像素比 = 物理像素／设备独立像素  //在某一方向上的<br>js：window.devicePixelRatio获取到当前设备的dpr<br>css：-webkit-device-pixel-ratio<br>dpr=1时，1个css像素相当于1个物理像素，比例为1:1<br>retina屏幕（dpr=2），1个物理像素相当于2个物理像素 比例为1:4<br>设备的宽高375*667可以理解为设备独立像素也就是css像素，<br><a id="more"></a><br>从以上知识可知，如果我们的设计稿是375 x 667的话，普通屏幕下，1个位图像素对应于1个物理像素，图片是可以清晰的展现的，但是在retina屏幕下由于物理像素变多，位图像素比较少，比例为1:4，所以就会出现图片模糊，解决方法就是使用2倍图片（@2x）然后再将容器缩小一半，这也就是为什么我们现在的设计稿都是 750x1334的（除去导航栏的高度一般我们用的是750x1206）这样下来retina屏幕上位图像素和物理像素的比例就为1:1了，但是这个时候普通屏幕上就会出现一个问题，位图像素为4，物理像素为1，取色就只能通过一定的算法（显示结果就是像素总数只能为原来的四分之一），图片不会模糊但是会缺少锐利度或者有色差，但是这样还算能够接受<br>上述做法还会引申出另外一个问题就是border：1px的问题<br>我们在css中写下border为1px的属性时，在普通屏幕和retina屏幕下其实高度是一样的，但不同的是普通屏幕下border为1px，物理像素为1行，但是retina屏幕下就会是显示无力像素2行，这样设计师其实是希望retina屏幕下只显示1行的，也就是0.5px，但是很多浏览器并不能识别0.5px会被当作0px，所以我们的解决方案就是dpr为2的时候，添加如下的meta标签，把viewport设置为scale为0.5，这样border：1px就达到了border：0.5px的效果，但是又有一个问题，就是viewport缩小为0.5，相应的字体也会被缩小，页面布局也会被缩放。<br>          <meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"><br>所以接下来我们就需要来谈适配了</p><h4 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h4><h5 id="em"><a href="#em" class="headerlink" title="em"></a>em</h5><p>em是一个相对单位，它不是一个固定的值，是相对于父元素的大小，同时它作为line-height的高度时是相对于自身的字体大小的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;p1&quot;&gt;</div><div class="line">   &lt;div class=&quot;s1&quot;&gt;1&lt;div&gt;</div><div class="line">   &lt;div class=&quot;s2&quot;&gt;1&lt;div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;div class=&quot;p2&quot;&gt;</div><div class="line">   &lt;div class=&quot;s3&quot;&gt;1&lt;div&gt;</div><div class="line">   &lt;div class=&quot;s4&quot;&gt;1&lt;div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">.p1 &#123;font-size: 16px; line-height: 32px;&#125;</div><div class="line">.s1 &#123;font-size: 2em;&#125;</div><div class="line">.s2 &#123;font-size: 2em; line-height: 2em;&#125;</div><div class="line"></div><div class="line">.p2 &#123;font-size: 16px; line-height: 2;&#125;</div><div class="line">.s5 &#123;font-size: 2em;&#125;</div><div class="line">.s6 &#123;font-size: 2em; line-height: 2em;&#125;</div><div class="line">这样一道题，你能算出s1，s2，s3，s4的字体行高的px值，那么你就应该是弄懂了em了</div><div class="line">答案：</div><div class="line">p1：font-size: 16px; line-height: 32px</div><div class="line">s1：font-size: 32px; line-height: 32px</div><div class="line">s2：font-size: 32px; line-height: 64px</div><div class="line">p1 无需解释</div><div class="line">s1 em作为字体单位，相对于父元素字体大小；line-height继承父元素计算值</div><div class="line">s2 em作为行高单位时，相对于自身字体大小</div><div class="line"></div><div class="line">p2：font-size: 16px; line-height: 32px</div><div class="line">s3：font-size: 32px; line-height: 64px</div><div class="line">s4：font-size: 32px; line-height: 64px</div><div class="line">p2 line-height: 2自身字体大小的两倍</div><div class="line">s3 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍</div><div class="line">s4  无需解释</div></pre></td></tr></table></figure></p><h5 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h5><p>rem指的是根字体的大小，其他元素可以从px转换为rem就是除以根字体的大小，这个也是适配的最重要的一点了<br>rem = px／根字体大小（基准值）</p><h5 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h5><p>适配的原理其实也就是等比缩放，你想要想跟着屏幕的大小等比的缩放页面，如果能有个x=屏幕大小／100的单位是不是很好，这样元素以x做单位就会跟着屏幕的大小变了，虽然我们没有这样的x单位但是我们有类似的rem。一般浏览器的根字体大小为16px，我们想要根字体的大小跟随着屏幕改变，那么就需要根据屏幕的大小来动态的改变根字体的大小，所以我们是这样设置的：<br>        rem = document.documentElement.clientWidth <em> dpr / 10<br>这里乘dpr是因为dpr为2的时候，我们缩放了页面的，除以10是为了方便计算，所以通过这样一个等式，屏幕大小开始和根字体相关联了，接下来我们只需要把页面中每个元素的宽高由设计稿上的px值转化为rem的值，这样我们就可以实现根据屏幕的大小来动态的缩放页面中的各个元素了。如何转化呢？也就是我提到的公式：rem = px／根字体大小（基准值），px除以根字体的大小。我们现在一般是取iPhone6的大小来作为我们的写页面的基准，iphone6的手机宽高为375</em>667，dpr为2，所以这样我们计算出来的基准值就是： 375 * 2 ／ 10 = 75，我们常用的做法就是用sass写个函数来把px转化为rem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$em-base:75.000px;</div><div class="line">@function px($px) &#123;</div><div class="line">   @return ($px / $em-base) * 1rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)， 只需要把字体乘相应的dpr就可以，这样缩放后字体都保持一样大小，一般会写如下函数做如下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@mixin dpr($cls, $fs) &#123;</div><div class="line">    #&#123;$cls&#125; &#123;</div><div class="line">            font-size: $fs*1px;</div><div class="line">    &#125;</div><div class="line">    @for $index from 1 through length($cls) &#123;</div><div class="line">      $value: nth($cls, $index);</div><div class="line">        [data-dpr=&quot;2&quot;] #&#123;$value&#125; &#123;</div><div class="line">            font-size: $fs * 2px;</div><div class="line">        &#125;</div><div class="line">        [data-dpr=&quot;3&quot;] #&#123;$value&#125; &#123;</div><div class="line">            font-size: $fs * 3px;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[data-dpr=&quot;2&quot;] .hint-box &#123;  </div><div class="line">    padding: 16px !important;</div><div class="line">    font-size: 28px !important;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[data-dpr=&quot;3&quot;] .hint-box &#123;</div><div class="line">    padding: 24px !important;</div><div class="line">    font-size: 42px !important;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在写vue的时候我是使用的npm的postcss-px2rem包来实现rem移动端适配的，使用这个可以直接在style中写px，就跟我们做pc端项目是一样的。页面计算宽度，插入页面的计算屏幕宽度的一段js代码，我从我们项目中copy过来的,是压缩过的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!function(a,b)&#123;function c()&#123;var b=f.getBoundingClientRect().width;b/i&gt;540&amp;&amp;(b=540*i);var c=b/10;f.style.fontSize=c+&quot;px&quot;,k.rem=a.rem=c&#125;var d,e=a.document,f=e.documentElement,g=e.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;),h=e.querySelector(&apos;meta[name=&quot;flexible&quot;]&apos;),i=0,j=0,k=b.flexible||(b.flexible=&#123;&#125;);if(g)&#123;console.warn(&quot;将根据已有的meta标签来设置缩放比例&quot;);var l=g.getAttribute(&quot;content&quot;).match(/initial\-scale=([\d\.]+)/);l&amp;&amp;(j=parseFloat(l[1]),i=parseInt(1/j))&#125;else if(h)&#123;var m=h.getAttribute(&quot;content&quot;);if(m)&#123;var n=m.match(/initial\-dpr=([\d\.]+)/),o=m.match(/maximum\-dpr=([\d\.]+)/);n&amp;&amp;(i=parseFloat(n[1]),j=parseFloat((1/i).toFixed(2))),o&amp;&amp;(i=parseFloat(o[1]),j=parseFloat((1/i).toFixed(2)))&#125;&#125;if(!i&amp;&amp;!j)&#123;var p=a.navigator.userAgent,q=(!!p.match(/android/gi),!!p.match(/iphone/gi)),r=q&amp;&amp;!!p.match(/OS 9_3/),s=a.devicePixelRatio;i=q&amp;&amp;!r?s&gt;=3&amp;&amp;(!i||i&gt;=3)?3:s&gt;=2&amp;&amp;(!i||i&gt;=2)?2:1:1,j=1/i&#125;if(f.setAttribute(&quot;data-dpr&quot;,i),!g)if(g=e.createElement(&quot;meta&quot;),g.setAttribute(&quot;name&quot;,&quot;viewport&quot;),g.setAttribute(&quot;content&quot;,&quot;initial-scale=&quot;+j+&quot;, maximum-scale=&quot;+j+&quot;, minimum-scale=&quot;+j+&quot;, user-scalable=no&quot;),f.firstElementChild)f.firstElementChild.appendChild(g);else&#123;var t=e.createElement(&quot;div&quot;);t.appendChild(g),e.write(t.innerHTML)&#125;a.addEventListener(&quot;resize&quot;,function()&#123;clearTimeout(d),d=setTimeout(c,300)&#125;,!1),a.addEventListener(&quot;pageshow&quot;,function(a)&#123;a.persisted&amp;&amp;(clearTimeout(d),d=setTimeout(c,300))&#125;,!1),&quot;complete&quot;===e.readyState?e.body.style.fontSize=12*i+&quot;px&quot;:e.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;e.body.style.fontSize=12*i+&quot;px&quot;&#125;,!1),c(),k.dpr=a.dpr=i,k.refreshRem=c,k.rem2px=function(a)&#123;var b=parseFloat(a)*this.rem;return&quot;string&quot;==typeof a&amp;&amp;a.match(/rem$/)&amp;&amp;(b+=&quot;px&quot;),b&#125;,k.px2rem=function(a)&#123;var b=parseFloat(a)/this.rem;return&quot;string&quot;==typeof a&amp;&amp;a.match(/px$/)&amp;&amp;(b+=&quot;rem&quot;),b&#125;&#125;(window,window.lib||(window.lib=&#123;&#125;));</div></pre></td></tr></table></figure></p><p>至此rem适配，我也总算是懂一丢丢了，不知道写的对不对，请指教～～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   实在是惭愧，做h5这么久了，居然连适配的问题一直没有搞明白。在公司写项目的时候总是用的模板，一行命令就生成了，直接就上手用了，适配也是模板中直接弄好的。又由于之前的自己一直是做pc端的，h5基础很是不牢靠，忽略了好的基本的知识。直到今天才真正下决心要把这个rem适配给完全弄明白。&lt;/p&gt;
&lt;h3 id=&quot;为什么要是适配&quot;&gt;&lt;a href=&quot;#为什么要是适配&quot; class=&quot;headerlink&quot; title=&quot;为什么要是适配&quot;&gt;&lt;/a&gt;为什么要是适配&lt;/h3&gt;&lt;p&gt;  面对不同分辨率的手机不同屏幕尺寸的手机希望展示的一样比例的页面&lt;/p&gt;
&lt;h3 id=&quot;适配的原理&quot;&gt;&lt;a href=&quot;#适配的原理&quot; class=&quot;headerlink&quot; title=&quot;适配的原理&quot;&gt;&lt;/a&gt;适配的原理&lt;/h3&gt;&lt;h4 id=&quot;相关尺寸和名词介绍&quot;&gt;&lt;a href=&quot;#相关尺寸和名词介绍&quot; class=&quot;headerlink&quot; title=&quot;相关尺寸和名词介绍&quot;&gt;&lt;/a&gt;相关尺寸和名词介绍&lt;/h4&gt;&lt;p&gt;目前我们选取的一款手机屏幕宽高基准为iphone6的375 x 667。&lt;br&gt;物理像素：物理像素是显示屏上最小的物理显示单元&lt;br&gt;设备独立像素：计算机系统中的一个点，可以由程序使用的最小单元，也可称为css像素&lt;br&gt;位图像素：图片最小的数据单元，1个位图像素对应于1个物理像素时，图片才会清晰的展现&lt;br&gt;设备像素比：&lt;br&gt;    设备像素比 = 物理像素／设备独立像素  //在某一方向上的&lt;br&gt;js：window.devicePixelRatio获取到当前设备的dpr&lt;br&gt;css：-webkit-device-pixel-ratio&lt;br&gt;dpr=1时，1个css像素相当于1个物理像素，比例为1:1&lt;br&gt;retina屏幕（dpr=2），1个物理像素相当于2个物理像素 比例为1:4&lt;br&gt;设备的宽高375*667可以理解为设备独立像素也就是css像素，&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://yaoyue.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yaoyue.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>画画画世界</title>
    <link href="http://yaoyue.com/2017/11/15/%E7%94%BB%E7%94%BB%E7%94%BB%E4%B8%96%E7%95%8C/"/>
    <id>http://yaoyue.com/2017/11/15/画画画世界/</id>
    <published>2017-11-15T05:00:43.000Z</published>
    <updated>2017-11-16T07:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;小学时就对画画比较感兴趣，喜欢涂涂画画，到现在还保存着以前的作品，偶尔拿出来看看，这种感觉很奇妙，后面随着学业的繁忙，也就从来没有拿起笔画过了，大学时代也没有，直到最近，偶然在微博上看见别人画彩铅，觉得真棒，萌生出了一种自己想画画的想法，于是立马就淘宝买了各种工具开始了画画。我想我大学时从没想过要画画的原因极大可能是那时候好玩的东西太多，每天跟各种朋友厮混，也就从来没有空闲来想着这事，不过现在不一样了，现在一个人生活在一个城市，又是住的单间，很多时候都是自己一个人，人一旦空闲起来就会想着怎样去打发时间，所以这也算是自己为什么要重新画画，尤其是最近都在看动漫，很想把这些喜欢的人物给画下来，另外一个影响我画画的原因就是我很喜欢张馨予。画画是一个人的修行<br><a id="more"></a><br><img src="http://chuantu.biz/t6/142/1510815261x2728306563.jpg" alt="乔巴"><br><img src="http://chuantu.biz/t6/142/1510815431x2728306563.jpg" alt="温蒂"><br><img src="http://chuantu.biz/t6/142/1510815512x2728306563.jpg" alt="花花"><br>矫情一句，爱生活爱自己，哈哈～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;小学时就对画画比较感兴趣，喜欢涂涂画画，到现在还保存着以前的作品，偶尔拿出来看看，这种感觉很奇妙，后面随着学业的繁忙，也就从来没有拿起笔画过了，大学时代也没有，直到最近，偶然在微博上看见别人画彩铅，觉得真棒，萌生出了一种自己想画画的想法，于是立马就淘宝买了各种工具开始了画画。我想我大学时从没想过要画画的原因极大可能是那时候好玩的东西太多，每天跟各种朋友厮混，也就从来没有空闲来想着这事，不过现在不一样了，现在一个人生活在一个城市，又是住的单间，很多时候都是自己一个人，人一旦空闲起来就会想着怎样去打发时间，所以这也算是自己为什么要重新画画，尤其是最近都在看动漫，很想把这些喜欢的人物给画下来，另外一个影响我画画的原因就是我很喜欢张馨予。画画是一个人的修行&lt;br&gt;
    
    </summary>
    
      <category term="芥末的绘画生活" scheme="http://yaoyue.com/categories/%E8%8A%A5%E6%9C%AB%E7%9A%84%E7%BB%98%E7%94%BB%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="芥末的绘画生活" scheme="http://yaoyue.com/tags/%E8%8A%A5%E6%9C%AB%E7%9A%84%E7%BB%98%E7%94%BB%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>图解http学习笔记</title>
    <link href="http://yaoyue.com/2017/10/31/%E5%9B%BE%E8%A7%A3http%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yaoyue.com/2017/10/31/图解http学习笔记/</id>
    <published>2017-10-31T14:37:12.000Z</published>
    <updated>2017-11-16T06:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>由于对http知识知道的甚少，最近做项目，调试接口的时候老是喜欢出问题，也因此浪费了很多的时间，所有打算恶补一下关于http协议这方面的知识。《图解http》这本书其实买了好久了，但是自己一直都没有去看，立个flag，最近要把它看完。</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h4><p>应用层 =&gt;传输层 =&gt;网络层 =&gt; 数据链路层<br>分层的好处：</p><ul><li>某个地方需要修改只用替换需要变动的层</li><li>处理应用层上的应用只需要考虑分派给自己的任务不需要考虑其他<br>应用层：决定向用户提供应用服务时通信的服务<br>传输层：对上层应用层提供处于网络连接中的两台计算机之间的数据传输<br>网络层：处理在网络上流动的数据包<br>链路层：用来处理连接网路的硬件部分<a id="more"></a><h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4></li><li>ip网际协议位于网络层，ip协议的作用：把各种数据包传送给对方（满足条件：IP地址，指名节点被分配的地址，mac地址，指网卡所属的固定地址，ip地址可以和mac地址进行配对）</li><li>使用ARP协议凭借MAC地址进行通信（arp协议：用以解析地址的协议，根据通信方的ip地址就可以查出对应的mac地址）</li></ul><h4 id="tcp协议"><a href="#tcp协议" class="headerlink" title="tcp协议"></a>tcp协议</h4><ul><li>tcp协议位于传输层，提供可靠的字节流服务</li><li>为了能过更容易的传输大数据，tcp协议把数据进行分割成以报文段为单位的数据包进行管理</li><li>为了准确将数据送达，tcp协议采用了三次握手策略<br>发送端首先发送一个带SYN标志的数据包给对方，接收方收到后回传一个带SYN/ACK的数据包表示传达确认信息，最后，发送端再回传一个带ACK的数据包表示握手结束</li><li>握手过程中任意某个阶段中断，tcp协议会再次以相同的顺序发送数据包</li></ul><h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><ul><li>位于应用层，提供域名到ip地址之间的解析服务</li></ul><h4 id="uri（统一资源标识符）"><a href="#uri（统一资源标识符）" class="headerlink" title="uri（统一资源标识符）"></a>uri（统一资源标识符）</h4><p>由某个协议方案表示的资源的定位标识符，url表示资源的地点，url是uri的子集</p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ol><li>请求是先从客户端开始建立的，服务端在没有接收到请求之前是不会发送响应的</li><li>http是无状态协议，不会对请求和响应之间的通信状态进行保存。</li><li>告知服务器意图的http方法<ul><li>get：请求访问已被uri识别的资源</li><li>post：传输实体的主体</li><li>put：传输文件</li><li>head：获取报文首部，用于确认uri的有效性及资源更新的日期时间等</li><li>delete：删除文件</li><li>options：询问支持的方法</li><li>trace：追踪路径</li></ul><ol><li>持久连接，只要任意一端没有明确的提出断开连接，则保持tcp连接的状态</li></ol><ul><li>减少tcp连接的重复建立和断开造成的额外开销，减轻服务器端的负载</li><li>减少开销的时间，web页面的显示速度相应提高</li></ul><ol><li>管线化，同时并行发送多个请求，不需要一个接一个的等待响应</li><li>使用cookie的状态管理<br>由于http是无状态协议，它不会对之前发生过的请求和响应的状态进行管理。也就是无法更具之前的状态进行接下来的请求处理，cookie技术通过在请求和响应的报文中写入cookie信息来控制客户端的状态（Set-Cookie报文）<br>没有cookie状态下请求：客户端=&gt;请求=&gt;服务器生成cookie=&gt;在响应中添加cookie后返回响应 =&gt; 客户端保存cookie<br>存有cookie状态下的请求：客户端=&gt;请求中添加cookie后放送请求 =&gt;服务器检查cookie =&gt; 返回响应</li></ol></li></ol><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h4 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h4><p>好像也没讲啥</p><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>状态码以3位数字和原因短语组成，数字第一位指定响应的类别，后两位无分类<br>1XX =&gt; 接受的请求正在处理 （信息性状态码）<br>2xx =&gt; 请求正常处理完成 （成功状态码）<br>3xx =&gt; 需要进行附加操作以完成请求 （重定向状态码）<br>4xx =&gt; 服务器无法处理请求（客户端错误状态码）<br>5xx =&gt; 服务器处理请求出错（服务器错误状态码）</p><p>常用状态码：<br>200 – ok<br>204 – no content 请求处理成功但是没有资源可以返回<br>206 – partial content 对资源某一部分请求<br>301 – moved permanently 永久重定向<br>302 – found 临时重定向<br>304 – not modified 客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件<br>400 – bad request！请求报文中存在语法错误<br>403 – forbidden 请求访问的资源被服务器拒绝<br>404 – not found 服务器上没有请求的资源<br>500 – internal server error 服务器端在执行请求时发生了错误<br>503 – service unavailable 服务器暂时处于超负载或者正在进行停机维护</p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="单台虚拟主机实现多个域名"><a href="#单台虚拟主机实现多个域名" class="headerlink" title="单台虚拟主机实现多个域名"></a>单台虚拟主机实现多个域名</h4><p>即使物理层面只有一台服务器，但是只要使用虚拟主机的功能，可以假想成已具有多台服务器</p><h4 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h4><ol><li>代理</li></ol><ul><li>接受由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端，代理不会改变请求的uri</li><li>每次通过代理服务器转发请求或者响应时，会追加写入via首部信息以标出经过的主机信息<br>为什么要使用代理服务器？</li><li>利用缓存技术减少网络带宽的流量（缓存代理会预先将资源的副本缓存保存在代理服务器，当接受到相同请求的时候就不从源服务器那里获取资源，而是将之前的缓存资源作为响应返回）</li><li>组织内部针对特定网站的访问控制</li></ul><ol><li>网关<br>转发其他服务器通信数据的服务器</li></ol><p>缓存服务器，客户端都会缓存，同时这个缓存是有时间限制的，会像源服务器从新确认资源的有效性</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h4 id="4种http首部字段类型"><a href="#4种http首部字段类型" class="headerlink" title="4种http首部字段类型"></a>4种http首部字段类型</h4><ol><li>通用首部字段（geeral header fields）<br>请求报文和响应报文两方都会使用的首部</li><li>请求首部字段（request header fields）<br>从客户端向服务器端发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</li><li>响应首部字段（response header fields）<br>从服务器端向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息</li><li>实体首部字段（entity header fields）<br>针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等和实体有关的信息</li></ol><h3 id="第七章-确保web安全的https"><a href="#第七章-确保web安全的https" class="headerlink" title="第七章 确保web安全的https"></a>第七章 确保web安全的https</h3><p>http不足之处：</p><ul><li>通信使用明文，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改<br>通信加密：http协议</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于对http知识知道的甚少，最近做项目，调试接口的时候老是喜欢出问题，也因此浪费了很多的时间，所有打算恶补一下关于http协议这方面的知识。《图解http》这本书其实买了好久了，但是自己一直都没有去看，立个flag，最近要把它看完。&lt;/p&gt;
&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;h4 id=&quot;TCP-IP的分层管理&quot;&gt;&lt;a href=&quot;#TCP-IP的分层管理&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP的分层管理&quot;&gt;&lt;/a&gt;TCP/IP的分层管理&lt;/h4&gt;&lt;p&gt;应用层 =&amp;gt;传输层 =&amp;gt;网络层 =&amp;gt; 数据链路层&lt;br&gt;分层的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个地方需要修改只用替换需要变动的层&lt;/li&gt;
&lt;li&gt;处理应用层上的应用只需要考虑分派给自己的任务不需要考虑其他&lt;br&gt;应用层：决定向用户提供应用服务时通信的服务&lt;br&gt;传输层：对上层应用层提供处于网络连接中的两台计算机之间的数据传输&lt;br&gt;网络层：处理在网络上流动的数据包&lt;br&gt;链路层：用来处理连接网路的硬件部分
    
    </summary>
    
      <category term="http" scheme="http://yaoyue.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yaoyue.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>three.js初始（一）</title>
    <link href="http://yaoyue.com/2017/10/13/three-js%E5%88%9D%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/10/13/three-js初始（一）/</id>
    <published>2017-10-13T06:02:15.000Z</published>
    <updated>2017-10-16T06:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="三大组建"><a href="#三大组建" class="headerlink" title="三大组建"></a>三大组建</h3><pre><code>渲染物体到网页所需的三大组建：场景（scene）、相机（camera）和渲染器（renderer）场景：var scene = new THREE.Scene();相机： var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);渲染器：var renderer = new THREE.WebGLRenderer();        renderer.setSize(window.innerWidth, window.innerHeight);        document.body.appendChild(renderer.domElement);</code></pre><p>场景=》相机=》渲染器=》添加物体到场景中=》渲染=》渲染循环<br><a id="more"></a><br>芥末</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三大组建&quot;&gt;&lt;a href=&quot;#三大组建&quot; class=&quot;headerlink&quot; title=&quot;三大组建&quot;&gt;&lt;/a&gt;三大组建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;渲染物体到网页所需的三大组建：场景（scene）、相机（camera）和渲染器（renderer）
场景：var scene = new THREE.Scene();
相机： var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
渲染器：var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;场景=》相机=》渲染器=》添加物体到场景中=》渲染=》渲染循环&lt;br&gt;
    
    </summary>
    
      <category term="three.js" scheme="http://yaoyue.com/categories/three-js/"/>
    
    
      <category term="three.js" scheme="http://yaoyue.com/tags/three-js/"/>
    
  </entry>
  
  <entry>
    <title>opacity应用~</title>
    <link href="http://yaoyue.com/2017/09/28/opacity%E5%BA%94%E7%94%A8/"/>
    <id>http://yaoyue.com/2017/09/28/opacity应用/</id>
    <published>2017-09-28T07:41:35.000Z</published>
    <updated>2017-10-13T03:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>首先讲一个悲伤的话题，手机摔坏了… 是的，我又把屏幕给摔坏了（都想揍我自己了），上下班钉钉打卡都打不了了，然后因为屏幕已经没法点击了，所以存在一起手机屏幕里的手机联系人都取不出来了，所以到现在我只记得我爸妈手机号码了~~，昨天摔坏后，就纠结的要死，到底该买哪款手机，本来还是想买个安卓机的，但看来看去不知道买哪款，最后想着又想快点到，所以就决定了在京东上买了苹果6splus.好了，这个话题收~要总结了。<br><a id="more"></a><br>今天刚写完一个项目，<a href="http://h5.in66.com/inpromo/2017/mid-autumn/loading.html" target="_blank" rel="external">地址</a>：<a href="http://h5.in66.com/inpromo/2017/mid-autumn/loading.html，之前拿到这个项目的时候，还以为是需要用到canvas合成的，结果到最后发现根本不需要，是的根本不需要，白高兴了。好像也没有啥难点，唯一，让我有点有必要说说的地方就是opacity的应用。" target="_blank" rel="external">http://h5.in66.com/inpromo/2017/mid-autumn/loading.html，之前拿到这个项目的时候，还以为是需要用到canvas合成的，结果到最后发现根本不需要，是的根本不需要，白高兴了。好像也没有啥难点，唯一，让我有点有必要说说的地方就是opacity的应用。</a></p><p>这个项目是在in内和微信端都要可以玩，所以结果页保存的图片是和展示的结果不一样的，结果页长按保存图片，在in内有走in的协议，但是在微信端却不行，手机能够保存图片，一般是保存的img标签的图片，但是由于结果展示的图片不能和你保存到手机里的一样，所以就必须在微信端做处理，是的，用一个img标签叠在展示的img标签上面，可以看到图中有2个，上面的那个给个opac为0，然后你长按保存的其实就是opacity为0的那张图片了，之前一直没想到要这样做，后面发现这样做是不是超级赞。完了~就这些了。</p><p><img src="https://i.imgur.com/8qGol5o.jpg" alt=""></p><p>写在最后：<br>决定把这个博客不仅仅是当做分享技术的博客了，以后会慢慢分享一些生活上的事情，感触或者是心情吧，就把它当做一个记录的秘密基地吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//yaoyue1.github.io/guang.m4a"></iframe><p>最近超级超级喜欢这首歌，跑步5.7公里单曲循环了这首歌，已经完全被洗脑了，天天上班听。带着耳机，听着这首歌，晚上下班，骑个摩拜，一路上的桂花香味，心情很好。<br>这个季节最喜欢的就是桂花了~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先讲一个悲伤的话题，手机摔坏了… 是的，我又把屏幕给摔坏了（都想揍我自己了），上下班钉钉打卡都打不了了，然后因为屏幕已经没法点击了，所以存在一起手机屏幕里的手机联系人都取不出来了，所以到现在我只记得我爸妈手机号码了~~，昨天摔坏后，就纠结的要死，到底该买哪款手机，本来还是想买个安卓机的，但看来看去不知道买哪款，最后想着又想快点到，所以就决定了在京东上买了苹果6splus.好了，这个话题收~要总结了。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>项目遇坑总结（二）——nextTick及事件循环理解</title>
    <link href="http://yaoyue.com/2017/09/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%9D%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8BnextTick/"/>
    <id>http://yaoyue.com/2017/09/13/项目遇坑总结（一）——初始nextTick/</id>
    <published>2017-09-13T03:13:12.000Z</published>
    <updated>2017-09-15T10:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  此次是在做公司福利社项目的时候遇到的问题，<a href="https://fuli.in66.com" target="_blank" rel="external">链接</a>,可能你点开的时候并没有看到banner，那是因为有时候后台是没有数据的。上线的第一版，swiper是没有问题，因为整个页面的显示是通过后端一个接口传过来的数据，在created中请求接口，在mouted中实例化swiper，并没有出现问题。页面上线后工作的很好，后面后端跟我说他们需要分离接口，因为banner的代码需要要监测什么的，然后我就被忽悠去改了，因为在我觉得，就在created中多加一个 fetch请求嘛，连数据结构都一样，很简单的，所以我连上webtest测试都没有测试就直接上线了，结果到了线上就出现了今天要讲的问题，swiper他罢工了，滑不动了。<br><a id="more"></a></p><h4 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h4><p>swiper之所以会罢工，是因为mouted实例化swiper的时候，swiper的数据并没有加载好，swiper实例化的时候是需要去扫描swiper-wraper中的slide的个数的，也就是说数据没有返回你就去实例化了。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用Vue.nextTick方法，在数据返回成功后，等待dom更新完毕后再调用swiper的实例化方法。</p><pre><code>&lt;script&gt;   mouted () {        fetch(location.protocol + `//www.in66.com/webview/user/incoinbanner?` + location.search.split(&apos;?&apos;)[1], {           method: &apos;GET&apos;,           credentials: &apos;include&apos;,        }).then(response =&gt; {            response.json().then(res =&gt; {               if (res.succ) {                   this.banners = res.data                   Vue.nextTick(()=&gt;{ //dom更新完毕调用swiper实例化方法                      this.initSwiper()                   })                }            })        })   }&lt;/script&gt;</code></pre><h4 id="关于nextTick"><a href="#关于nextTick" class="headerlink" title="关于nextTick()"></a>关于nextTick()</h4><p>vue官方文档上写的用法是：在下次dom更循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的dom<br>由于vue的数据驱动视图更新是异步的，所以修改数据的当下，视图是不会立马更新的，而是要等到同一事件循环中的所有数据发生变化完成后，再统一的进行视图更新。所谓事件循环，就是指Javascript的事件执行机制，主线程执行完了执行栈中的所有同步任务之后，才会去读取任务队列，任务队列是一个先进先出的队列，所有主线程会提取队手的任务放入主线程中去执行，执行完毕后，再去读取任务队列的首个任务。主线程不断重复这个过程，所有称为事件循环。<br>   所以这里nextTick的触发是，同一事件循环的代码执行完毕 =&gt; dom更新 =&gt; nextTick callback触发</p><p>备注：<br>阮一峰老师的这篇事件循环的文字讲的甚好推荐：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  此次是在做公司福利社项目的时候遇到的问题，&lt;a href=&quot;https://fuli.in66.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;,可能你点开的时候并没有看到banner，那是因为有时候后台是没有数据的。上线的第一版，swiper是没有问题，因为整个页面的显示是通过后端一个接口传过来的数据，在created中请求接口，在mouted中实例化swiper，并没有出现问题。页面上线后工作的很好，后面后端跟我说他们需要分离接口，因为banner的代码需要要监测什么的，然后我就被忽悠去改了，因为在我觉得，就在created中多加一个 fetch请求嘛，连数据结构都一样，很简单的，所以我连上webtest测试都没有测试就直接上线了，结果到了线上就出现了今天要讲的问题，swiper他罢工了，滑不动了。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信</title>
    <link href="http://yaoyue.com/2017/08/01/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yaoyue.com/2017/08/01/vue组件通信/</id>
    <published>2017-08-01T03:49:40.000Z</published>
    <updated>2017-09-13T07:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>学习Vue算是有一段时间了，期间公司的项目开发流程也全换成了Vue了，自己也是接了几个Vue的项目了，不过总感觉，知道的不是特别多，每次做起项目也总会遇到这样或者是那样的问题，这次总结一下项目中用到的比较频繁的组件之间的通信。</p><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>props方式：<br><a id="more"></a><br>父组件当中的nearbyData传递给子组件</p><pre><code>&lt;nearby :nearbyDate=&quot;nearbyDate&quot; :key=&quot;idx&quot; v-for=&quot;(nearbyDate,idx) in nearbyItems&quot;&gt;&lt;/nearby&gt;</code></pre><p>子组件中通过声明props后使用父组件传递过来的nearbyData来进行页面的渲染</p><pre><code> &lt;div class=&quot;left-box&quot; @click=&quot;openinji(nearbyDate.user_id)&quot;&gt;    &lt;img :src=&quot;nearbyDate.self_url&quot;/&gt;    &lt;div class=&quot;name&quot; :class=&quot;{name_xia:nearbyDate.label.length &gt; 0 ? false:true}&quot;&gt;{{nearbyDate.name}}&lt;/div&gt;    &lt;div class=&quot;label-box&quot;&gt;        &lt;p class=&quot;label&quot; :key=&quot;idx&quot; v-for=&quot;(labelintro,idx) in nearbyDate.label&quot;&gt;{{labelintro}}&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>$emit方式</p><p>子组件通过$emit像父组件传递一个自定义事件和一个参数</p><pre><code>&lt;template&gt;   &lt;div class=&quot;box&quot; @click=&quot;sendMessage&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {   methods: {      sendMessage () {        this.$emit(&apos;listen&apos;, &apos;data&apos;)      }   }}&lt;/script&gt;</code></pre><p>在父组件的子组件标签中监听该自定义事件，并且用一个对应的方法来处理事件</p><pre><code> &lt;template&gt;   &lt;div class=&quot;wrap&quot;&gt;    &lt;child :sendMessage=&quot;handleMessage&quot;&gt;&lt;/child&gt;    &lt;/div&gt; &lt;template&gt;&lt;script&gt;export default {  methods: {    handleMessage (data) {        console.log(data)    }  }}&lt;/script&gt;</code></pre><p>总结上述，即可以得出，父传子是通过props属性来传值，子传父则是通过自定义事件。</p><h3 id="子传子"><a href="#子传子" class="headerlink" title="子传子"></a>子传子</h3><p>中央事件总线，也称为事件巴士，听名字就知道是一个担任组件与组件之间通信介质的东西。</p><h4 id="创建eventBus"><a href="#创建eventBus" class="headerlink" title="创建eventBus"></a>创建eventBus</h4><p>创建一个名为eventBus.js的文件，新建一个Vue实例<br>      import Vue from ‘Vue’<br>      export default new Vue</p><h4 id="子组件中引入eventBus，传入自定义事件和参数"><a href="#子组件中引入eventBus，传入自定义事件和参数" class="headerlink" title="子组件中引入eventBus，传入自定义事件和参数"></a>子组件中引入eventBus，传入自定义事件和参数</h4><p>子组件中引入eventBus,并像其传入自定义事件和参数，$emit实例方法触发的是当前实例上的事件，附加参数都会传给监听器回调。</p><pre><code>&lt;template&gt;  &lt;div class=&quot;box&quot; @click=&quot;sendMessage&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import bus  from &quot;../assets/eventBus&quot;;export default {   methods: {       sendMessage () {          bus.$emit(&apos;sendmsg&apos;, &apos;data&apos;)       }   }}&lt;/script&gt;</code></pre><h4 id="子组件中引入eventBus-监听事件获取传入参数"><a href="#子组件中引入eventBus-监听事件获取传入参数" class="headerlink" title="子组件中引入eventBus,监听事件获取传入参数"></a>子组件中引入eventBus,监听事件获取传入参数</h4><p>$on监听当前实例上的自定义事件，事件可以是由$emit触发的，回调函数会接受所有传入事件触发函数（$emit）的额外参数。</p><pre><code> mounted () {  bus.$on(&apos;sendmsg&apos;, (data) =&gt; {    console.log(data)  })}</code></pre><h3 id="父调用子"><a href="#父调用子" class="headerlink" title="父调用子"></a>父调用子</h3><p>通过$refs，父组件能够调用子组件里的属性与方法</p><pre><code>&lt;template&gt; &lt;iAudio id=&quot;audio&quot; ref=&quot;auido&quot; loop autoplay src=&quot;//inimg05.jiuyan.info/in/2017/07/26/FC889FF2-55B1-1C3B-146A-F3E966EC6803.mp3&quot;&gt;&lt;/iAudio&gt; &lt;div @click=&quot;paly&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  methods: {      play () {          this.$refs.auido.pause()      }  }}&lt;/script&gt;</code></pre><p>注意：当 ref 和 v-for 一起使用时，ref 是一个数组，包含相应的子组件。$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs。</p><p>组件之间的通信大概就是这几种方式了，一般中小型的项目，以上的通信方式以及足够用了，但如果是比较大型的项目可能就会需要用到vuex来集中管理状态了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Vue算是有一段时间了，期间公司的项目开发流程也全换成了Vue了，自己也是接了几个Vue的项目了，不过总感觉，知道的不是特别多，每次做起项目也总会遇到这样或者是那样的问题，这次总结一下项目中用到的比较频繁的组件之间的通信。&lt;/p&gt;
&lt;h3 id=&quot;父传子&quot;&gt;&lt;a href=&quot;#父传子&quot; class=&quot;headerlink&quot; title=&quot;父传子&quot;&gt;&lt;/a&gt;父传子&lt;/h3&gt;&lt;p&gt;props方式：&lt;br&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://yaoyue.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack初识（一）</title>
    <link href="http://yaoyue.com/2017/07/26/webpack%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/07/26/webpack初识（一）/</id>
    <published>2017-07-26T02:54:55.000Z</published>
    <updated>2017-07-26T03:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>  虽然在公司用webpack好多次了，但是对其一直不是很了解，此次为了弄清楚目录结构，必须要学一下webpack。</p><h3 id="webpack是做什么的"><a href="#webpack是做什么的" class="headerlink" title="webpack是做什么的"></a>webpack是做什么的</h3><p>  官方的文档上是这样描述webpack的，说它是前端资源模块化管理和打包的工具，它能把任何形式的资源都看做是模块，根据其依赖关系，打包成为静态文件资源。</p><p><img src="http://www.css88.com/doc/webpack2/img/webpack.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;  虽然在公司用webpack好多次了，但是对其一直不是很了解，此次为了弄清楚目录结构，必须要学一下webpack。&lt;/p&gt;
&lt;h3 id=&quot;webpack是做什么的&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yaoyue.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（四）--仿知乎登录页</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BB%BF%E7%9F%A5%E4%B9%8E%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（四）-仿知乎登录页/</id>
    <published>2017-04-05T07:28:04.000Z</published>
    <updated>2017-04-05T08:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:<a href="https://yaoyue1.github.io/dot.html" target="_blank" rel="external">传送门</a>,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。<br>看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码<br><a id="more"></a></p><p><pre><br><code><br>    $(function(){<br>      var cvs = document.getElementById(“mycanvas”);<br>      var ctx = cvs.getContext(‘2d’);<br>      var docWidth = document.documentElement.clientWidth;<br>      var docHeight = document.documentElement.clientHeight;<br>      cvs.width = docWidth;<br>      cvs.height = docHeight;//初始化准备，让canvas的宽高等于可视区的宽高<br>      var dotNum = 100;//整个区域粒子的数量<br>      var dots = [];//用来存放粒子对象的数组<br>      var mouse = new Object();//声明的对象用来存放鼠标的初始X、Y值<br>      mouse.x = 800;<br>      mouse.y = 350;<br>      for(var i=0;i<dotnum;i++){ 循环dotnum数量的粒子为每个粒子对象添加属性="" var="" dotobj="new" object();="" dotobj.x="Math.random()*docWidth;//初始的x坐标位置" dotobj.y="Math.random()*docHeight;//初始的y坐标位置" dotobj.r="Math.ceil(Math.random()*4);//粒子半径" dotobj.color="white" ;="" 粒子颜色="" dotobj.speedx="Math.floor(Math.random()*2)?1:-1//粒子X轴的运动方向" dotobj.speedy="Math.floor(Math.random()*2)?1:-1//粒子Y轴的运动方向" dots[i]="dotObj;//把粒子对象装进数组" }="" function="" drawball(x,y,r,color){="" 画每个粒子圆="" ctx.beginpath();="" ctx.arc(x,y,r,0,math.pi*2,false);="" ctx.fillstyle="color;" ctx.fill()="" move(obj){="" 粒子的移动函数="" obj.x="" +="obj.speedX*0.2;//粒子x轴方向每次移动的距离" obj.y="" if(obj.y<="obj.r){//上边界小球反弹处理" obj.speedy*="-1;" if(obj.y="">= docHeight-obj.r){//下边界小球反弹处理<br>          obj.y = docHeight-obj.r;<br>          obj.speedY<em>=-1;<br>        }<br>        if(obj.x&lt;=obj.r){//左边界的小球反弹处理<br>          obj.x = obj.x;<br>          obj.speedX</em>=-1;<br>        }<br>        if(obj.x &gt;= docWidth-obj.r){//右边界的小球反弹处理<br>          obj.x = docWidth-obj.r;<br>          obj.speedX<em>=-1;<br>        }<br>      }<br>      function ballAndball(obj1,obj2){//封装函数用来求两个球或者是球和鼠标直接的直线距离<br>        var disX = Math.abs(obj1.x-obj2.x);//相距的X绝对值<br>        var disY = Math.abs(obj1.y-obj2.y);//相距的Y绝对值<br>        return Math.sqrt(disX</em>disX+disY*disY)//平方根求直线距离<br>      }<br>      function mouseball(mouse,obj){//鼠标移动，把鼠标和距离其130内的小球连成线<br>        if(ballAndball(mouse,obj)&lt;130){<br>          ctx.lineWidth = 0.2;<br>          ctx.beginPath();<br>          ctx.moveTo(obj.x,obj.y);<br>          ctx.lineTo(mouse.x,mouse.y);<br>          ctx.strokeStyle = obj.color;<br>          ctx.stroke();</dotnum;i++){></code></pre></p><pre><code>    }  }  render();  function render(){    ctx.clearRect(0, 0, docWidth, docHeight);//清除画布    for(var j= 0;j &lt; dots.length;j++){//两层for循环，第一层是先画小球然后让每个小球移动，鼠标移动连线      little = dots[j]      move(little)      drawball(little.x,little.y,little.r,little.color)      mouseball(mouse,little)      for(var k = 0;k &lt; dots.length;k++){//第二层循环是用来找出两个球如果相距100就把他们用线连接起来        if(ballAndball(dots[j],dots[k])&lt;100){          ctx.lineWidth = 0.2;          ctx.globalAlpha = (130 - ballAndball(dots[j], dots[k])) * 1 / 100;//这句代码是用来控制线的消失和出现的效果          ctx.beginPath();          ctx.moveTo(dots[j].x, dots[j].y);          ctx.lineTo(dots[k].x, dots[k].y);          ctx.strokeStyle = dots[j].color;          ctx.stroke();        }      }      ctx.globalAlpha = 1.0    }    requestAnimationFrame(render);//浏览器自动刷新时间来循环调用render  }  cvs.onmousemove = function(event){//鼠标移动是的X、Y坐标    e = event || window.event;    mouse = new Object();    mouse.x = e.offsetX;    mouse.y = e.offsetY;  }})</code></pre><p><br>代码的核心部分可能就是求两个小球的距离来再次循环连线了。因为注释写的比较清楚，所以我就不多说了，下次的canvas学习一点点（五）还不知道些什么？？？纠结啊，你有啥想法可以告诉我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas学习一点点的第四篇啦~，这次写的是一个仿知乎的登录页面:&lt;a href=&quot;https://yaoyue1.github.io/dot.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,感觉这效果已经被n多人写(wan)过(huai)了，但是感觉这个效果还是很适合做背景的，于是我还是跟风了一把。&lt;br&gt;看完你会发现其实这个效果的写法和下雨那个很像，只不过下雪那个运动会稍微简单点，但是本质是不变的，都是控制粒子的运动。上代码&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（三）--黑客帝国</title>
    <link href="http://yaoyue.com/2017/04/05/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"/>
    <id>http://yaoyue.com/2017/04/05/canvas学习一点点（三）-黑客帝国/</id>
    <published>2017-04-05T07:27:28.000Z</published>
    <updated>2017-04-05T07:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间戳</title>
    <link href="http://yaoyue.com/2017/03/31/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <id>http://yaoyue.com/2017/03/31/时间戳/</id>
    <published>2017-03-31T09:31:09.000Z</published>
    <updated>2017-09-14T02:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>再次更新：</p><p>最近再回看自己写的文章的时候，才发现写的地方没讲清楚，哈哈哈，也许是当时并没有理解清楚，重新更新一下。</p><p>关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。稍微吐槽一下自己写的代码，不过有点扯远了，今天主要讲时间戳。<br>我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳过来：1505232000，这样一串数字就是时间戳。<br><a id="more"></a><br>你会想知道明明js可以获取到时间啊，为啥还需要这样传，那是因为js是获取到你系统本地的时间，你想如果你自己调快了时间那岂不是不准确了。所以时间戳的用处就是这样。<br>拿到一串时间戳你要怎样把它转化成为XX年xx月xx日这样的呢？<br>这里必须要提到PHP的时间戳和js的时间戳是不一样的，你通过new Data().getTime()或者是通过Date.parse(new Date())方法获取到的js时间戳是13位，而你会发现php传过来的时间戳是10位，是的，js获取的时间戳和PHP获取的时间戳是有区别的：</p><ul><li>单位区别：PHP获取的时间戳是以秒为单位的，而js获取的时间戳是以毫秒为单位的，所以你必须要转换单位，1秒=1000毫秒</li><li>时区区别：PHP通过time()获取的时间戳，通常会跟服务器所在的时区有关，js获取的时间戳则是依据你的系统时间确定的，如果你把你的手机或者电脑的时间设置比正常快或慢，js获取的时间会以你的设置时间为准，这也是为什么我们用实际不能通过js本地获取。<br><img src="http://i.imgur.com/ljI4ovd.png" alt=""></li></ul><p>封装一个方法format（）；这样你只有把时间戳传进去就可以给你返回xx年xx月xx日xx:xx</p><pre><code> function add0(m) {    return m &lt; 10 ? &apos;0&apos; + m : m;}function format(t) {    var time = new Date(parseInt(t) * 1000);//这里为什么乘以1000，也就是因为PHP和js的时间戳的单位不一致    var y = time.getFullYear();    var m = time.getMonth() + 1;    var d = time.getDate();    var h = time.getHours();    var mm = time.getMinutes();    var s = time.getSeconds();    return y+&apos;年&apos;+add0(m) + &apos;月&apos; + add0(d) + &apos;日 &apos; + add0(h) + &apos;:&apos; + add0(mm);}</code></pre><p>截图放一张我这次做的活动的签到日历：<br>！<a href=""></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再次更新：&lt;/p&gt;
&lt;p&gt;最近再回看自己写的文章的时候，才发现写的地方没讲清楚，哈哈哈，也许是当时并没有理解清楚，重新更新一下。&lt;/p&gt;
&lt;p&gt;关于时间戳这个东西，其实是我第一次单独做项目的时候就遇到过的，但是当时忙着项目上线我就利索的直接copy了别人的代码来用。后面就忘记这事了，最近这几天在看之前自己写的项目，一个字形容：惨。连我自己都快认不出这事我自己写的代码，因为要渲染页面所以js里面掺杂了大量的html代码，我真佩服当时自己咋写出来的。稍微吐槽一下自己写的代码，不过有点扯远了，今天主要讲时间戳。&lt;br&gt;我们前端调用后端接口的时候，他们通常传时间都不是传“2017年4月1日”这样的东西过来，而是直接传一个时间戳过来：1505232000，这样一串数字就是时间戳。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（二）--</title>
    <link href="http://yaoyue.com/2017/03/31/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/31/canvas学习一点点（二）/</id>
    <published>2017-03-31T05:49:34.000Z</published>
    <updated>2017-04-01T07:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。<br>最终的效果：<a href="https://yaoyue1.github.io/bar.html" target="_blank" rel="external">传送门</a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;canvas id= &quot;mycanvas&quot; width=&apos;500&apos; height=&apos;500&apos;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure><pre><code>//js$(function(){      var cvs = document.getElementById(&apos;mycanvas&apos;);      var ctx = cvs.getContext(&apos;2d&apos;);      var centerX = cvs.width/2;//圆心的x坐标      var centerY = cvs.height/2;//圆心的y坐标      var rad = Math.PI*2/100;//把2π弧度分成100份，每一份的弧度值      var initNum = 0.1;//初始化的基础百分比      var speed = 0.2;//加载速度      function blueCircle(n){画进度的展示蓝圈          ctx.save();//保存画布状态          ctx.strokeStyle = &quot;#49f&quot;;          ctx.lineWidth = 5;          ctx.beginPath();          ctx.arc(centerX, centerY, 200,-Math.PI/2, -Math.PI/2+n*rad,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function  initCircle(){//画最开始的初始化圆圈          ctx.save();          ctx.beginPath();          ctx.strokeStyle = &quot;white&quot;;          ctx.arc(centerX, centerY, 200, 0,Math.PI*2,false);          ctx.stroke();          ctx.closePath();          ctx.restore();      }      function text(n){//画中间的文字          ctx.save();          ctx.strokeStyle = &quot;#49f&quot;;          ctx.font = &apos;40px Arial&apos;          ctx.strokeText(n.toFixed(0)+&apos;%&apos;,centerX-25, centerY+10);          ctx.stroke();          ctx.restore();      }      draw()      function draw(){          window.requestAnimationFrame(draw);//浏览器的刷新频率自动调整动画的时间间隔          ctx.clearRect(0, 0, cvs.width, cvs.height);//清除上一次画布的内容          initCircle()//调用方法          text(initNum);          blueCircle(initNum);          initNum+=speed;          if(initNum&gt;100){//当进度达到100的时候就让他一直为100，不然你的进度条要破100的~~~~              initNum = 100          }      }  })</code></pre><p>是不是觉得很简单~~代码不多确实jq很难做到的，之前用jq写一般都只能写长条形状的进度条。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次说过“canvas学习一点点”是一个连载的篇目哈哈~~，将会记录一些我学习canvas的实例或者是我觉得好玩的canvas应用分享，反正你记住是关于canvas的东西就好了。今天是第二篇，这一篇打算写个简单的进度条~（哎呀~被你猜中了，是因为我还不会太难的啦），说实话之前我虽然懂一些些canvas图片方面的东西，但是除开操作图片外倒真是对其他的canvas知识知道的甚少。不过我个人觉得canvas好好玩呀~比起写页面来我还是比较喜欢写这种动画，只是比较悲伤的是，一些属性到现在我都是处于一个懵懂的状态中。&lt;br&gt;最终的效果：&lt;a href=&quot;https://yaoyue1.github.io/bar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>ios touch事件导致的CSS3动画问题</title>
    <link href="http://yaoyue.com/2017/03/30/ios-touch%E4%BA%8B%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84CSS3%E5%8A%A8%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yaoyue.com/2017/03/30/ios-touch事件导致的CSS3动动画问题/</id>
    <published>2017-03-30T05:57:06.000Z</published>
    <updated>2017-03-31T02:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>刚刚做完一个腾讯动漫的项目：<a href="https://www.in66.com/html/tonglingfei/index.html" target="_blank" rel="external">传送门</a>,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当你到达这个页面的时候，你会看到5个不同的美男子，你点击其中任何一个都会去一个相对应的故事，假如你点击第二个你会看到第二张图。第二张图中我用红色框框出来的这些对话框都是需要一个一个的接着出现，所以我当时的第一反应是采用CSS3的animation-delay属性来解决，只需要给每个对话框设置一个延迟的属性，让她依次出来不就行了，我也确实是这样做了。然而因为我穷，只买得起安卓手机，所以只测了安卓一点问题都木有，在chrome模拟器上也啥事没有，我就真信了这样做简直不能太好，等全部做完了，来测试上线的时候才发现ios尼玛的又出现问题了。因为这些故事的页面都超过了一屏，所以必须要滑动屏幕才能看下面的，ios出问题就出现在这：ios当你触摸屏幕或者滑动屏幕时它会暂停掉你屏幕上CSS的渲染，所以只要你的手还在屏幕上，对话框的出现就会被截断，你放开手后才能继续加载。但是蛋疼的是后来加载的对话框它的延迟时间会重头开始算起而不是从你松开手的那一刻算，这就真是坑了，等半天都出不来。</p><p><img src="http://i.imgur.com/YVK0j59.png" alt=""><br><img src="http://i.imgur.com/Ch5vXwA.png" alt=""></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>赶紧去google一下才发现这事前端真的很无辜，是ios事件的处理机制有关。<br>ios和安卓不同，他们处理事情的机制顺序不一样。</p><ul><li>ios的处理机制是：它的响应顺序依次为：Touch——Media——Service——Core架构，你可以看到它最先响应的是屏幕的反应，所以只要用户触摸屏幕，系统最先去处理的就是touch了，此时会暂停屏幕上包括js、css的渲染，这个时候不光是css动画不动了，哪怕页面没有加载完如果你手指头还停留在屏幕上那么页面也不会继续加载，直到你的手松开</li><li>Android的处理机制是：它的响应顺序依次为：Application——Framework——Library——Kernal架构，和屏幕显示相关的处于library这一层，所以当你对屏幕操作之后，Android首先会激活应用、框架，然后才是屏幕最后是核心架构。</li></ul><p>以上就是为啥安卓手机很流畅，ios却出现了CSS3动画的滚动停止了。<br>那到底该咋解决呢？？到底该咋解决呢？？<br>其实到现在我的解决方式都不算太好，我把原先用CSS3控制顺序的方式改成了用js的setTimeout()的方式，你也看到了，这真的很不好，写了一堆的setTimeout函数，但是这样做虽不能解决滚动时停止加载，但是最起码时间的计算方式不是从头开始算的了。找不到更好的方法了，如果你知道，请不要害羞的多多指教~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚做完一个腾讯动漫的项目：&lt;a href=&quot;https://www.in66.com/html/tonglingfei/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;,这项目就是一个漫画类的，有许多图片对话框啥的，所以当初切图都快切死。本来我也觉得应该就是切图和顺序方面的事情比较麻烦的，但却还是遇到另外一个问题，而且是一个比较麻烦的。下面开始讲这个麻烦了啦啦啦~&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://yaoyue.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://yaoyue.com/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习一点点（一）</title>
    <link href="http://yaoyue.com/2017/03/30/canvas%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yaoyue.com/2017/03/30/canvas学习一点点（一）/</id>
    <published>2017-03-30T05:47:18.000Z</published>
    <updated>2017-03-31T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~</p><p>今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。<br>最终效果链接：<a href="https://yaoyue1.github.io/snow.html" target="_blank" rel="external">传送门</a><br>快和你的妹纸一起来看雪吧~~~<br><a id="more"></a></p><pre><code>//html&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;//js$(function(){ snow()function snow(){    var docWidth = document.documentElement.clientWidth //可见区域宽度    var docHeight = document.documentElement.clientHeight //可见区域高度    // initPage()    function initPage(){        containerWidth = $(&quot;.container&quot;).width();//获取外层容器container宽度        containerHeight = $(&quot;.container&quot;).height();//获取外层容器container高度        initFloatAnimation()    }    function initFloatAnimation(){        var canvas = document.createElement(&apos;canvas&apos;);//创建canvas元素        var ctx = canvas.getContext(&apos;2d&apos;);            canvas.id = &apos;floatCanvas&apos;;//给canvas一个id            canvas.width = containerWidth;//让canvas的宽度等于container的宽度            canvas.height = containerHeight;//让canvas的高度等于container的高度        $(&quot;.container&quot;).append(canvas);//把canvas追加进html的container        var particleNum = 100;//粒子的数量        var particles = [];//定义空数组用来存储每个粒子对象        for (var i=0;i&lt;particleNum;i++){            var particleObj = new Object();//创建一个对象            particleObj.x = Math.random()*docWidth;//在可视区域宽度的范围内随机生成粒子的初始x坐标            particleObj.y = Math.random()*docHeight;//在可视区域g的范围内随机生成粒子的初始y坐标            particleObj.vx = Math.random() * 2-1;//生成粒子横向移动的距离            particleObj.vy = (Math.random() * 0.8 + 0.2);//生成粒子纵向移动的距离：[0.2-1]            particleObj.dw = particleObj.vy*20;//随机生成粒子的宽度            particleObj.dh = particleObj.dw;//粒子的宽度等于高度            particleObj.ag = (Math.random()*2-1)*10;//粒子的初始角度            particles[i] = particleObj;//把这些对象装进事先定义的数组        }        console.log(particles)        // 以上把需要的元素都准备好了，接下来就是渲染让粒子动起来        render()        function render(){            ctx.clearRect(0, 0, containerWidth, containerHeight);//清除画布            var little;            for(var j=0;j&lt;particles.length;j++){                little = particles[j];                if(little.x &lt; 0 || little.x &gt; containerWidth || little.y &gt; containerHeight){//if判断如果粒子已经超出了可视的边界就再重新产生它的x,y值                    little.x = Math.random() * containerWidth;                    little.y = Math.random() * -200;                }                little.x += little.vx;                little.y += little.vy;                drawImage(ctx,img,little.x,little.y,little.dw,little.dh,1,little.ag);            }            requestAnimationFrame(render);//循环调用自身，requestAnimationFrame是一个新的API,作用与setTimeInterval一样，不同的是它会根据浏览器的刷新频率自动调整动画的时间间隔。        }    }    function drawImage (ctx,img,dx,dy,dw,dh,scale,angle) {        ctx.save();        ctx.translate(dx + dw / 2, dy + dh / 2);//移动画布        ctx.scale(scale, scale);        ctx.rotate(angle);        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -1 * dw / 2, -1 * dh / 2, dw, dh);//重新绘制新的粒子        ctx.restore();    }var _base = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAlCAMAAADyQNAxAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALnRSTlMArr2Dd6phklkuBYhdNo0yOmpFFZd/exkOCW4/VkqecqdlJh4Ro04jtVG5KpuwTP8QawAAArlJREFUOMuVlNmSsjAQhXUIIYGEhM0g+6Igou//ev9hsZwZay7+ruLuq3O6T7o5/H+5Z/cQRZfzOT3/DZ2jyHRc8Xmcxz76g7n0nHOpda5zqTg3509BNzWz0mVZDkMxFVMZytlcUve32chlODEmmKCUClaEuebd+BMyXOYDEy0NsqCuSZZRUbCcj5fvVNrLsBBtRjKSnBIrOZEsoGLQSkbfpEaVFzQghCQWyvMsK6kDysJcjm8lrmBHM3KyPN/3HccHCrlWwNS8KKN0yFqYeb4TV3FVxbHjexYhgRjkvLfmrk1lEAJztRvbbppr7HgJIS0LVb931elBBMSynMf1uJZt2wsGU1poHm1SvCxonVh+3NhAXlzlL54s3AZIOzmIzIJUtVK3++22YjE8M6FVdwYVcc0g5fmxDeh5/0Ldnke7iSEWiFKOKaieY0ACwweg29dWd6hVjnWqKZNm0yqhhQErUKvSqnZsFoq0g+wuC6VKaFm+c7WPz51BHe3HEgZluYowouGhCJCo0+yOe2MNKKteori4mBGOATktWvbz3Ra0kP+Wq7vOONH65DkPiN12qYWKHQxJi9XxYDo1tASNVfba/v2G77ik72NGMW1JuEZOYnnqRwOx5yJzB7U+EYIY0NZCjSpk6wshi+a4F3JA8xkddAdqe6JSoH9g2BobZnZzvWJ3EkiVsl8M1yzyYt1By4mxO9fq+oAdIg1oKHnk7rs6qm0LLQ+L6sTOtq01bilUJn3dYjTrSWDv1533EZOXnBYlkSPS93X0Ki9xHjXBAaFgRgCxKefRfuD7AFh9RmlN1sraIKBFoRXme5d7McAG2LYBBbFcd5nnyryR3XTmWheTEAxVsAnTjbD7XVHfzVLn5YRfShhikU0Ku49y3bSbuVKSK87n/tXSJ5deTGd6E6XpT7NPQffwKfIPFOtCNONyh58AAAAASUVORK5CYII=&quot;    //图片我直接用的base64来写的    var img = new Image();    img.src = _base;    img.onload = function() {        initPage()    }}})</code></pre><p>   个人感觉注释已经写的比较详细了，就不再多说了哈~~，来和你的妹纸一起来看雪吧！！！</p><p>   什么？？？你没有没有啊？？</p><p><img src="https://a-ssl.duitang.com/uploads/item/201609/04/20160904102522_Fadn4.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这将会是一个长期更新的篇目~前段时间在朋友圈刚立完flag说要把买的那本canvas的书看完的，现在觉得不做点什么东西出来好像也少点什么，所以以后如果有时间，就每周写一篇关于canvas的实际应用。就让我们一起沉醉在canvas的世界里吧~~&lt;/p&gt;
&lt;p&gt;今天第一次就写一个我最喜欢的canvas雪花呀花瓣呀的飘落效果，其实jQuery操作dom也是可以实现这效果的，但是性能非常的不好，一旦粒子过多，页面就开始抖动不流畅，这方面还是canvas比较好。&lt;br&gt;最终效果链接：&lt;a href=&quot;https://yaoyue1.github.io/snow.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;快和你的妹纸一起来看雪吧~~~&lt;br&gt;
    
    </summary>
    
      <category term="canvas" scheme="http://yaoyue.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yaoyue.com/tags/canvas/"/>
    
  </entry>
  
</feed>
